

The simplest FastAPI file could look like this:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Hello World&quot;}`

Copy that to a file `main.py`.

Run the live server:

`$ uvicorn main:app --reload  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Started reloader process [28720] &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Started server process [28722] &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Waiting for application startup. &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Application startup complete.`

Note

The command `uvicorn main:app` refers to:

- `main`: the file `main.py` (the Python "module").
- `app`: the object created inside of `main.py` with the line `app = FastAPI()`.
- `--reload`: make the server restart after code changes. Only use for development.

In the output, there's a line with something like:

`INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

That line shows the URL where your app is being served, in your local machine.

#### Check it

Open your browser at http://127.0.0.1:8000.

You will see the JSON response as:

`{&quot;message&quot;: &quot;Hello World&quot;}`

#### Interactive API docs

Now go to http://127.0.0.1:8000/docs.

You will see the automatic interactive API documentation (provided by Swagger UI):

<image @ https://fastapi.tiangolo.com/img/index/index-01-swagger-ui-simple.png>

#### Alternative API docs

And now, go to http://127.0.0.1:8000/redoc.

You will see the alternative automatic documentation (provided by ReDoc):

<image @ https://fastapi.tiangolo.com/img/index/index-02-redoc-simple.png>

#### OpenAPI

**FastAPI** generates a "schema" with all your API using the **OpenAPI** standard for defining APIs.

##### "Schema"

A "schema" is a definition or description of something. Not the code that implements it, but just an abstract description.

##### API "schema"

In this case, OpenAPI is a specification that dictates how to define a schema of your API.

This schema definition includes your API paths, the possible parameters they take, etc.

##### Data "schema"

The term "schema" might also refer to the shape of some data, like a JSON content.

In that case, it would mean the JSON attributes, and data types they have, etc.

##### OpenAPI and JSON Schema

OpenAPI defines an API schema for your API. And that schema includes definitions (or "schemas") of the data sent and received by your API using **JSON Schema**, the standard for JSON data schemas.

##### Check the `openapi.json`

If you are curious about how the raw OpenAPI schema looks like, FastAPI automatically generates a JSON (schema) with the descriptions of all your API.

You can see it directly at: http://127.0.0.1:8000/openapi.json.

It will show a JSON starting with something like:

`{     &quot;openapi&quot;: &quot;3.1.0&quot;,     &quot;info&quot;: {         &quot;title&quot;: &quot;FastAPI&quot;,         &quot;version&quot;: &quot;0.1.0&quot;     },     &quot;paths&quot;: {         &quot;/items/&quot;: {             &quot;get&quot;: {                 &quot;responses&quot;: {                     &quot;200&quot;: {                         &quot;description&quot;: &quot;Successful Response&quot;,                         &quot;content&quot;: {                             &quot;application/json&quot;: {  ...`

##### What is OpenAPI for

The OpenAPI schema is what powers the two interactive documentation systems included.

And there are dozens of alternatives, all based on OpenAPI. You could easily add any of those alternatives to your application built with **FastAPI**.

You could also use it to generate code automatically, for clients that communicate with your API. For example, frontend, mobile or IoT applications.

### Recap, step by step

#### Step 1: import `FastAPI`

`from fastapi import FastAPI app = FastAPI()  @app.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Hello World&quot;}`

`FastAPI` is a Python class that provides all the functionality for your API.

Technical Details

`FastAPI` is a class that inherits directly from `Starlette`.

You can use all the Starlette functionality with `FastAPI` too.

#### Step 2: create a `FastAPI` "instance"

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Hello World&quot;}`

Here the `app` variable will be an "instance" of the class `FastAPI`.

This will be the main point of interaction to create all your API.

This `app` is the same one referred by `uvicorn` in the command:

`$ uvicorn main:app --reload  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

If you create your app like:

`from fastapi import FastAPI  my_awesome_api = FastAPI()  @my_awesome_api.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Hello World&quot;}`

And put it in a file `main.py`, then you would call `uvicorn` like:

`$ uvicorn main:my_awesome_api --reload  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

#### Step 3: create a *path operation*

##### Path

"Path" here refers to the last part of the URL starting from the first `/`.

So, in a URL like:

`https://example.com/items/foo`

...the path would be:

Info

A "path" is also commonly called an "endpoint" or a "route".

While building an API, the "path" is the main way to separate "concerns" and "resources".

##### Operation

"Operation" here refers to one of the HTTP "methods".

One of:

- `POST`
- `GET`
- `PUT`
- `DELETE`

...and the more exotic ones:

- `OPTIONS`
- `HEAD`
- `PATCH`
- `TRACE`

In the HTTP protocol, you can communicate to each path using one (or more) of these "methods".

***

When building APIs, you normally use these specific HTTP methods to perform a specific action.

Normally you use:

- `POST`: to create data.
- `GET`: to read data.
- `PUT`: to update data.
- `DELETE`: to delete data.

So, in OpenAPI, each of the HTTP methods is called an "operation".

We are going to call them "**operations**" too.

##### Define a *path operation decorator*

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Hello World&quot;}`

The `@app.get(&quot;/&quot;)` tells **FastAPI** that the function right below is in charge of handling requests that go to:

- the path `/`
- using a `get` operation

`@decorator` Info

That `@something` syntax in Python is called a "decorator".

You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from).

A "decorator" takes the function below and does something with it.

In our case, this decorator tells **FastAPI** that the function below corresponds to the **path** `/` with an **operation** `get`.

It is the "**path operation decorator**".

You can also use the other operations:

- `@app.post()`
- `@app.put()`
- `@app.delete()`

And the more exotic ones:

- `@app.options()`
- `@app.head()`
- `@app.patch()`
- `@app.trace()`

Tip

You are free to use each operation (HTTP method) as you wish.

**FastAPI** doesn't enforce any specific meaning.

The information here is presented as a guideline, not a requirement.

For example, when using GraphQL you normally perform all the actions using only `POST` operations.

#### Step 4: define the **path operation function**

This is our "**path operation function**":

- **path**: is `/`.
- **operation**: is `get`.
- **function**: is the function below the "decorator" (below `@app.get(&quot;/&quot;)`).

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Hello World&quot;}`

This is a Python function.

It will be called by **FastAPI** whenever it receives a request to the URL "`/`" using a `GET` operation.

In this case, it is an `async` function.

***

You could also define it as a normal function instead of `async def`:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/&quot;) def root():     return {&quot;message&quot;: &quot;Hello World&quot;}`

#### Step 5: return the content

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Hello World&quot;}`

You can return a `dict`, `list`, singular values as `str`, `int`, etc.

You can also return Pydantic models (you'll see more about that later).

There are many other objects and models that will be automatically converted to JSON (including ORMs, etc). Try using your favorite ones, it's highly probable that they are already supported.

### Recap

- Import `FastAPI`.
- Create an `app` instance.
- Write a **path operation decorator** (like `@app.get(&quot;/&quot;)`).
- Write a **path operation function** (like `def root(): ...` above).
- Run the development server (like `uvicorn main:app --reload`).




You can declare path "parameters" or "variables" with the same syntax used by Python format strings:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_item(item_id):     return {&quot;item_id&quot;: item_id}`

The value of the path parameter `item_id` will be passed to your function as the argument `item_id`.

So, if you run this example and go to http://127.0.0.1:8000/items/foo, you will see a response of:

### Path parameters with types

You can declare the type of a path parameter in the function, using standard Python type annotations:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_item(item_id: int):     return {&quot;item_id&quot;: item_id}`

In this case, `item_id` is declared to be an `int`.

Check

This will give you editor support inside of your function, with error checks, completion, etc.

### Data conversion

If you run this example and open your browser at http://127.0.0.1:8000/items/3, you will see a response of:

Check

Notice that the value your function received (and returned) is `3`, as a Python `int`, not a string `&quot;3&quot;`.

So, with that type declaration, **FastAPI** gives you automatic request "parsing".

### Data validation

But if you go to the browser at http://127.0.0.1:8000/items/foo, you will see a nice HTTP error of:

`{     &quot;detail&quot;: [         {             &quot;loc&quot;: [                 &quot;path&quot;,                 &quot;item_id&quot;             ],             &quot;msg&quot;: &quot;value is not a valid integer&quot;,             &quot;type&quot;: &quot;type_error.integer&quot;         }     ] }`

because the path parameter `item_id` had a value of `&quot;foo&quot;`, which is not an `int`.

The same error would appear if you provided a `float` instead of an `int`, as in: http://127.0.0.1:8000/items/4.2

Check

So, with the same Python type declaration, **FastAPI** gives you data validation.

Notice that the error also clearly states exactly the point where the validation didn't pass.

This is incredibly helpful while developing and debugging code that interacts with your API.

### Documentation

And when you open your browser at http://127.0.0.1:8000/docs, you will see an automatic, interactive, API documentation like:

<image @ https://fastapi.tiangolo.com/img/tutorial/path-params/image01.png>

Check

Again, just with that same Python type declaration, **FastAPI** gives you automatic, interactive documentation (integrating Swagger UI).

Notice that the path parameter is declared to be an integer.

### Standards-based benefits, alternative documentation

And because the generated schema is from the OpenAPI standard, there are many compatible tools.

Because of this, **FastAPI** itself provides an alternative API documentation (using ReDoc), which you can access at http://127.0.0.1:8000/redoc:

<image @ https://fastapi.tiangolo.com/img/tutorial/path-params/image02.png>

The same way, there are many compatible tools. Including code generation tools for many languages.

### Pydantic

All the data validation is performed under the hood by Pydantic, so you get all the benefits from it. And you know you are in good hands.

You can use the same type declarations with `str`, `float`, `bool` and many other complex data types.

Several of these are explored in the next chapters of the tutorial.

### Order matters

When creating *path operations*, you can find situations where you have a fixed path.

Like `/users/me`, let's say that it's to get data about the current user.

And then you can also have a path `/users/{user_id}` to get data about a specific user by some user ID.

Because *path operations* are evaluated in order, you need to make sure that the path for `/users/me` is declared before the one for `/users/{user_id}`:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/users/me&quot;) async def read_user_me():     return {&quot;user_id&quot;: &quot;the current user&quot;}  @app.get(&quot;/users/{user_id}&quot;) async def read_user(user_id: str):     return {&quot;user_id&quot;: user_id}`

Otherwise, the path for `/users/{user_id}` would match also for `/users/me`, "thinking" that it's receiving a parameter `user_id` with a value of `&quot;me&quot;`.

Similarly, you cannot redefine a path operation:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/users&quot;) async def read_users():     return [&quot;Rick&quot;, &quot;Morty&quot;]  @app.get(&quot;/users&quot;) async def read_users2():     return [&quot;Bean&quot;, &quot;Elfo&quot;]`

The first one will always be used since the path matches first.

### Predefined values

If you have a *path operation* that receives a *path parameter*, but you want the possible valid *path parameter* values to be predefined, you can use a standard Python `Enum`.

#### Create an `Enum` class

Import `Enum` and create a sub-class that inherits from `str` and from `Enum`.

By inheriting from `str` the API docs will be able to know that the values must be of type `string` and will be able to render correctly.

Then create class attributes with fixed values, which will be the available valid values:

`from enum import Enum from fastapi import FastAPI  class ModelName(str, Enum):     alexnet = &quot;alexnet&quot;    resnet = &quot;resnet&quot;    lenet = &quot;lenet&quot;  app = FastAPI()  @app.get(&quot;/models/{model_name}&quot;) async def get_model(model_name: ModelName):     if model_name is ModelName.alexnet:         return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;Deep Learning FTW!&quot;}      if model_name.value == &quot;lenet&quot;:         return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;LeCNN all the images&quot;}      return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;Have some residuals&quot;}`

Tip

If you are wondering, "AlexNet", "ResNet", and "LeNet" are just names of Machine Learning models.

#### Declare a *path parameter*

Then create a *path parameter* with a type annotation using the enum class you created (`ModelName`):

`from enum import Enum  from fastapi import FastAPI  class ModelName(str, Enum):     alexnet = &quot;alexnet&quot;     resnet = &quot;resnet&quot;     lenet = &quot;lenet&quot;  app = FastAPI()  @app.get(&quot;/models/{model_name}&quot;) async def get_model(model_name: ModelName):     if model_name is ModelName.alexnet:         return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;Deep Learning FTW!&quot;}      if model_name.value == &quot;lenet&quot;:         return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;LeCNN all the images&quot;}      return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;Have some residuals&quot;}`

#### Check the docs

Because the available values for the *path parameter* are predefined, the interactive docs can show them nicely:

<image @ https://fastapi.tiangolo.com/img/tutorial/path-params/image03.png>

#### Working with Python *enumerations*

The value of the *path parameter* will be an *enumeration member*.

##### Compare *enumeration members*

You can compare it with the *enumeration member* in your created enum `ModelName`:

`from enum import Enum  from fastapi import FastAPI  class ModelName(str, Enum):     alexnet = &quot;alexnet&quot;     resnet = &quot;resnet&quot;     lenet = &quot;lenet&quot;  app = FastAPI()  @app.get(&quot;/models/{model_name}&quot;) async def get_model(model_name: ModelName):     if model_name is ModelName.alexnet:        return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;Deep Learning FTW!&quot;}      if model_name.value == &quot;lenet&quot;:         return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;LeCNN all the images&quot;}      return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;Have some residuals&quot;}`

##### Get the *enumeration value*

You can get the actual value (a `str` in this case) using `model_name.value`, or in general, `your_enum_member.value`:

`from enum import Enum  from fastapi import FastAPI  class ModelName(str, Enum):     alexnet = &quot;alexnet&quot;     resnet = &quot;resnet&quot;     lenet = &quot;lenet&quot;  app = FastAPI()  @app.get(&quot;/models/{model_name}&quot;) async def get_model(model_name: ModelName):     if model_name is ModelName.alexnet:         return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;Deep Learning FTW!&quot;}      if model_name.value == &quot;lenet&quot;:        return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;LeCNN all the images&quot;}      return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;Have some residuals&quot;}`

Tip

You could also access the value `&quot;lenet&quot;` with `ModelName.lenet.value`.

##### Return *enumeration members*

You can return *enum members* from your *path operation*, even nested in a JSON body (e.g. a `dict`).

They will be converted to their corresponding values (strings in this case) before returning them to the client:

`from enum import Enum  from fastapi import FastAPI  class ModelName(str, Enum):     alexnet = &quot;alexnet&quot;     resnet = &quot;resnet&quot;     lenet = &quot;lenet&quot;  app = FastAPI()  @app.get(&quot;/models/{model_name}&quot;) async def get_model(model_name: ModelName):     if model_name is ModelName.alexnet:         return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;Deep Learning FTW!&quot;}     if model_name.value == &quot;lenet&quot;:         return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;LeCNN all the images&quot;}     return {&quot;model_name&quot;: model_name, &quot;message&quot;: &quot;Have some residuals&quot;}`

In your client you will get a JSON response like:

`{   &quot;model_name&quot;: &quot;alexnet&quot;,   &quot;message&quot;: &quot;Deep Learning FTW!&quot; }`

### Path parameters containing paths

Let's say you have a *path operation* with a path `/files/{file_path}`.

But you need `file_path` itself to contain a *path*, like `home/johndoe/myfile.txt`.

So, the URL for that file would be something like: `/files/home/johndoe/myfile.txt`.

#### OpenAPI support

OpenAPI doesn't support a way to declare a *path parameter* to contain a *path* inside, as that could lead to scenarios that are difficult to test and define.

Nevertheless, you can still do it in **FastAPI**, using one of the internal tools from Starlette.

And the docs would still work, although not adding any documentation telling that the parameter should contain a path.

#### Path convertor

Using an option directly from Starlette you can declare a *path parameter* containing a *path* using a URL like:

In this case, the name of the parameter is `file_path`, and the last part, `:path`, tells it that the parameter should match any *path*.

So, you can use it with:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/files/{file_path:path}&quot;) async def read_file(file_path: str):     return {&quot;file_path&quot;: file_path}`

Tip

You could need the parameter to contain `/home/johndoe/myfile.txt`, with a leading slash (`/`).

In that case, the URL would be: `/files//home/johndoe/myfile.txt`, with a double slash (`//`) between `files` and `home`.

### Recap

With **FastAPI**, by using short, intuitive and standard Python type declarations, you get:

- Editor support: error checks, autocompletion, etc.
- Data "parsing"
- Data validation
- API annotation and automatic documentation

And you only have to declare them once.

That's probably the main visible advantage of **FastAPI** compared to alternative frameworks (apart from the raw performance).




When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as "query" parameters.

`from fastapi import FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  @app.get(&quot;/items/&quot;) async def read_item(skip: int = 0, limit: int = 10):     return fake_items_db[skip : skip + limit]`

The query is the set of key-value pairs that go after the `?` in a URL, separated by `&amp;` characters.

For example, in the URL:

`http://127.0.0.1:8000/items/?skip=0&amp;limit=10`

...the query parameters are:

- `skip`: with a value of `0`
- `limit`: with a value of `10`

As they are part of the URL, they are "naturally" strings.

But when you declare them with Python types (in the example above, as `int`), they are converted to that type and validated against it.

All the same process that applied for path parameters also applies for query parameters:

- Editor support (obviously)
- Data "parsing"
- Data validation
- Automatic documentation

### Defaults

As query parameters are not a fixed part of a path, they can be optional and can have default values.

In the example above they have default values of `skip=0` and `limit=10`.

So, going to the URL:

`http://127.0.0.1:8000/items/`

would be the same as going to:

`http://127.0.0.1:8000/items/?skip=0&amp;limit=10`

But if you go to, for example:

`http://127.0.0.1:8000/items/?skip=20`

The parameter values in your function will be:

- `skip=20`: because you set it in the URL
- `limit=10`: because that was the default value

### Optional parameters

The same way, you can declare optional query parameters, by setting their default to `None`:

Python 3.10+Python 3.6+

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_item(item_id: str, q: str | None = None):     if q:         return {&quot;item_id&quot;: item_id, &quot;q&quot;: q}     return {&quot;item_id&quot;: item_id}`

`from typing import Union  from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_item(item_id: str, q: Union[str, None] = None):     if q:         return {&quot;item_id&quot;: item_id, &quot;q&quot;: q}     return {&quot;item_id&quot;: item_id}`

In this case, the function parameter `q` will be optional, and will be `None` by default.

Check

Also notice that **FastAPI** is smart enough to notice that the path parameter `item_id` is a path parameter and `q` is not, so, it's a query parameter.

### Query parameter type conversion

You can also declare `bool` types, and they will be converted:

Python 3.10+Python 3.6+

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_item(item_id: str, q: str | None = None, short: bool = False):     item = {&quot;item_id&quot;: item_id}     if q:         item.update({&quot;q&quot;: q})     if not short:         item.update(             {&quot;description&quot;: &quot;This is an amazing item that has a long description&quot;}         )     return item`

`from typing import Union  from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_item(item_id: str, q: Union[str, None] = None, short: bool = False):     item = {&quot;item_id&quot;: item_id}     if q:         item.update({&quot;q&quot;: q})     if not short:         item.update(             {&quot;description&quot;: &quot;This is an amazing item that has a long description&quot;}         )     return item`

In this case, if you go to:

`http://127.0.0.1:8000/items/foo?short=1`

or

`http://127.0.0.1:8000/items/foo?short=True`

or

`http://127.0.0.1:8000/items/foo?short=true`

or

`http://127.0.0.1:8000/items/foo?short=on`

or

`http://127.0.0.1:8000/items/foo?short=yes`

or any other case variation (uppercase, first letter in uppercase, etc), your function will see the parameter `short` with a `bool` value of `True`. Otherwise as `False`.

### Multiple path and query parameters

You can declare multiple path parameters and query parameters at the same time, **FastAPI** knows which is which.

And you don't have to declare them in any specific order.

They will be detected by name:

Python 3.10+Python 3.6+

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/users/{user_id}/items/{item_id}&quot;) async def read_user_item(     user_id: int, item_id: str, q: str | None = None, short: bool = False ):     item = {&quot;item_id&quot;: item_id, &quot;owner_id&quot;: user_id}     if q:         item.update({&quot;q&quot;: q})     if not short:         item.update(             {&quot;description&quot;: &quot;This is an amazing item that has a long description&quot;}         )     return item`

`from typing import Union  from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/users/{user_id}/items/{item_id}&quot;) async def read_user_item(     user_id: int, item_id: str, q: Union[str, None] = None, short: bool = False ):     item = {&quot;item_id&quot;: item_id, &quot;owner_id&quot;: user_id}     if q:         item.update({&quot;q&quot;: q})     if not short:         item.update(             {&quot;description&quot;: &quot;This is an amazing item that has a long description&quot;}         )     return item`

### Required query parameters

When you declare a default value for non-path parameters (for now, we have only seen query parameters), then it is not required.

If you don't want to add a specific value but just make it optional, set the default as `None`.

But when you want to make a query parameter required, you can just not declare any default value:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_user_item(item_id: str, needy: str):     item = {&quot;item_id&quot;: item_id, &quot;needy&quot;: needy}     return item`

Here the query parameter `needy` is a required query parameter of type `str`.

If you open in your browser a URL like:

`http://127.0.0.1:8000/items/foo-item`

...without adding the required parameter `needy`, you will see an error like:

`{     &quot;detail&quot;: [         {             &quot;loc&quot;: [                 &quot;query&quot;,                 &quot;needy&quot;             ],             &quot;msg&quot;: &quot;field required&quot;,             &quot;type&quot;: &quot;value_error.missing&quot;         }     ] }`

As `needy` is a required parameter, you would need to set it in the URL:

`http://127.0.0.1:8000/items/foo-item?needy=sooooneedy`

...this would work:

`{     &quot;item_id&quot;: &quot;foo-item&quot;,     &quot;needy&quot;: &quot;sooooneedy&quot; }`

And of course, you can define some parameters as required, some as having a default value, and some entirely optional:

Python 3.10+Python 3.6+

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_user_item(     item_id: str, needy: str, skip: int = 0, limit: int | None = None ):     item = {&quot;item_id&quot;: item_id, &quot;needy&quot;: needy, &quot;skip&quot;: skip, &quot;limit&quot;: limit}     return item`

`from typing import Union  from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_user_item(     item_id: str, needy: str, skip: int = 0, limit: Union[int, None] = None ):     item = {&quot;item_id&quot;: item_id, &quot;needy&quot;: needy, &quot;skip&quot;: skip, &quot;limit&quot;: limit}     return item`

In this case, there are 3 query parameters:

- `needy`, a required `str`.
- `skip`, an `int` with a default value of `0`.
- `limit`, an optional `int`.




When you need to send data from a client (let's say, a browser) to your API, you send it as a **request body**.

A **request** body is data sent by the client to your API. A **response** body is the data your API sends to the client.

Your API almost always has to send a **response** body. But clients don't necessarily need to send **request** bodies all the time.

To declare a **request** body, you use Pydantic models with all their power and benefits.

Info

To send data, you should use one of: `POST` (the more common), `PUT`, `DELETE` or `PATCH`.

Sending a body with a `GET` request has an undefined behavior in the specifications, nevertheless, it is supported by FastAPI, only for very complex/extreme use cases.

As it is discouraged, the interactive docs with Swagger UI won't show the documentation for the body when using `GET`, and proxies in the middle might not support it.

### Import Pydantic's `BaseModel`

First, you need to import `BaseModel` from `pydantic`:

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  app = FastAPI()  @app.post(&quot;/items/&quot;) async def create_item(item: Item):     return item`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  app = FastAPI()  @app.post(&quot;/items/&quot;) async def create_item(item: Item):     return item`

### Create your data model

Then you declare your data model as a class that inherits from `BaseModel`.

Use standard Python types for all the attributes:

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  class Item(BaseModel):     name: str    description: str | None = None    price: float    tax: float | None = None  app = FastAPI()  @app.post(&quot;/items/&quot;) async def create_item(item: Item):     return item`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  class Item(BaseModel):     name: str    description: Union[str, None] = None    price: float    tax: Union[float, None] = None  app = FastAPI()  @app.post(&quot;/items/&quot;) async def create_item(item: Item):     return item`

The same as when declaring query parameters, when a model attribute has a default value, it is not required. Otherwise, it is required. Use `None` to make it just optional.

For example, this model above declares a JSON "`object`" (or Python `dict`) like:

`{     &quot;name&quot;: &quot;Foo&quot;,     &quot;description&quot;: &quot;An optional description&quot;,     &quot;price&quot;: 45.2,     &quot;tax&quot;: 3.5 }`

...as `description` and `tax` are optional (with a default value of `None`), this JSON "`object`" would also be valid:

`{     &quot;name&quot;: &quot;Foo&quot;,     &quot;price&quot;: 45.2 }`

### Declare it as a parameter

To add it to your *path operation*, declare it the same way you declared path and query parameters:

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  app = FastAPI()  @app.post(&quot;/items/&quot;) async def create_item(item: Item):     return item`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  app = FastAPI()  @app.post(&quot;/items/&quot;) async def create_item(item: Item):     return item`

...and declare its type as the model you created, `Item`.

### Results

With just that Python type declaration, **FastAPI** will:

- Read the body of the request as JSON.
- Convert the corresponding types (if needed).
- Validate the data.
  - If the data is invalid, it will return a nice and clear error, indicating exactly where and what was the incorrect data.
- Give you the received data in the parameter `item`.
  - As you declared it in the function to be of type `Item`, you will also have all the editor support (completion, etc) for all of the attributes and their types.
- Generate JSON Schema definitions for your model, you can also use them anywhere else you like if it makes sense for your project.
- Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation UIs.

### Automatic docs

The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs:

<image @ https://fastapi.tiangolo.com/img/tutorial/body/image01.png>

And will be also used in the API docs inside each *path operation* that needs them:

<image @ https://fastapi.tiangolo.com/img/tutorial/body/image02.png>

### Editor support

In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a `dict` instead of a Pydantic model):

<image @ https://fastapi.tiangolo.com/img/tutorial/body/image03.png>

You also get error checks for incorrect type operations:

<image @ https://fastapi.tiangolo.com/img/tutorial/body/image04.png>

This is not by chance, the whole framework was built around that design.

And it was thoroughly tested at the design phase, before any implementation, to ensure it would work with all the editors.

There were even some changes to Pydantic itself to support this.

The previous screenshots were taken with Visual Studio Code.

But you would get the same editor support with PyCharm and most of the other Python editors:

<image @ https://fastapi.tiangolo.com/img/tutorial/body/image05.png>

Tip

If you use PyCharm as your editor, you can use the Pydantic PyCharm Plugin.

It improves editor support for Pydantic models, with:

- auto-completion
- type checks
- refactoring
- searching
- inspections

### Use the model

Inside of the function, you can access all the attributes of the model object directly:

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  app = FastAPI()  @app.post(&quot;/items/&quot;) async def create_item(item: Item):     item_dict = item.dict()     if item.tax:         price_with_tax = item.price + item.tax        item_dict.update({&quot;price_with_tax&quot;: price_with_tax})     return item_dict`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  app = FastAPI()  @app.post(&quot;/items/&quot;) async def create_item(item: Item):     item_dict = item.dict()     if item.tax:         price_with_tax = item.price + item.tax        item_dict.update({&quot;price_with_tax&quot;: price_with_tax})     return item_dict`

### Request body + path parameters

You can declare path parameters and request body at the same time.

**FastAPI** will recognize that the function parameters that match path parameters should be **taken from the path**, and that function parameters that are declared to be Pydantic models should be **taken from the request body**.

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def create_item(item_id: int, item: Item):     return {&quot;item_id&quot;: item_id, **item.dict()}`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def create_item(item_id: int, item: Item):     return {&quot;item_id&quot;: item_id, **item.dict()}`

### Request body + path + query parameters

You can also declare **body**, **path** and **query** parameters, all at the same time.

**FastAPI** will recognize each of them and take the data from the correct place.

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def create_item(item_id: int, item: Item, q: str | None = None):     result = {&quot;item_id&quot;: item_id, **item.dict()}     if q:         result.update({&quot;q&quot;: q})     return result`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def create_item(item_id: int, item: Item, q: Union[str, None] = None):     result = {&quot;item_id&quot;: item_id, **item.dict()}     if q:         result.update({&quot;q&quot;: q})     return result`

The function parameters will be recognized as follows:

- If the parameter is also declared in the **path**, it will be used as a path parameter.
- If the parameter is of a **singular type** (like `int`, `float`, `str`, `bool`, etc) it will be interpreted as a **query** parameter.
- If the parameter is declared to be of the type of a **Pydantic model**, it will be interpreted as a request **body**.

Note

FastAPI will know that the value of `q` is not required because of the default value `= None`.

The `Union` in `Union[str, None]` is not used by FastAPI, but will allow your editor to give you better support and detect errors.

### Without Pydantic

If you don't want to use Pydantic models, you can also use **Body** parameters. See the docs for Body - Multiple Parameters: Singular values in body.




The same way you can declare additional validation and metadata in *path operation function* parameters with `Query`, `Path` and `Body`, you can declare validation and metadata inside of Pydantic models using Pydantic's `Field`.

### Import `Field`

First, you have to import it:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Body, FastAPI from pydantic import BaseModel, Field app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = Field(         default=None, title=&quot;The description of the item&quot;, max_length=300     )     price: float = Field(gt=0, description=&quot;The price must be greater than zero&quot;)     tax: float | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Annotated, Union  from fastapi import Body, FastAPI from pydantic import BaseModel, Field app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = Field(         default=None, title=&quot;The description of the item&quot;, max_length=300     )     price: float = Field(gt=0, description=&quot;The price must be greater than zero&quot;)     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel, Field from typing_extensions import Annotated  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = Field(         default=None, title=&quot;The description of the item&quot;, max_length=300     )     price: float = Field(gt=0, description=&quot;The price must be greater than zero&quot;)     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Body, FastAPI from pydantic import BaseModel, Field app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = Field(         default=None, title=&quot;The description of the item&quot;, max_length=300     )     price: float = Field(gt=0, description=&quot;The price must be greater than zero&quot;)     tax: float | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item = Body(embed=True)):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel, Field app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = Field(         default=None, title=&quot;The description of the item&quot;, max_length=300     )     price: float = Field(gt=0, description=&quot;The price must be greater than zero&quot;)     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item = Body(embed=True)):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

Warning

Notice that `Field` is imported directly from `pydantic`, not from `fastapi` as are all the rest (`Query`, `Path`, `Body`, etc).

### Declare model attributes

You can then use `Field` with model attributes:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Body, FastAPI from pydantic import BaseModel, Field  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = Field(        default=None, title=&quot;The description of the item&quot;, max_length=300    )    price: float = Field(gt=0, description=&quot;The price must be greater than zero&quot;)    tax: float | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Annotated, Union  from fastapi import Body, FastAPI from pydantic import BaseModel, Field  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = Field(        default=None, title=&quot;The description of the item&quot;, max_length=300    )    price: float = Field(gt=0, description=&quot;The price must be greater than zero&quot;)    tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel, Field from typing_extensions import Annotated  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = Field(        default=None, title=&quot;The description of the item&quot;, max_length=300    )    price: float = Field(gt=0, description=&quot;The price must be greater than zero&quot;)    tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Body, FastAPI from pydantic import BaseModel, Field  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = Field(        default=None, title=&quot;The description of the item&quot;, max_length=300    )    price: float = Field(gt=0, description=&quot;The price must be greater than zero&quot;)    tax: float | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item = Body(embed=True)):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel, Field  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = Field(        default=None, title=&quot;The description of the item&quot;, max_length=300    )    price: float = Field(gt=0, description=&quot;The price must be greater than zero&quot;)    tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item = Body(embed=True)):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`Field` works the same way as `Query`, `Path` and `Body`, it has all the same parameters, etc.

Technical Details

Actually, `Query`, `Path` and others you'll see next create objects of subclasses of a common `Param` class, which is itself a subclass of Pydantic's `FieldInfo` class.

And Pydantic's `Field` returns an instance of `FieldInfo` as well.

`Body` also returns objects of a subclass of `FieldInfo` directly. And there are others you will see later that are subclasses of the `Body` class.

Remember that when you import `Query`, `Path`, and others from `fastapi`, those are actually functions that return special classes.

Tip

Notice how each model's attribute with a type, default value and `Field` has the same structure as a *path operation function's* parameter, with `Field` instead of `Path`, `Query` and `Body`.

You can declare extra information in `Field`, `Query`, `Body`, etc. And it will be included in the generated JSON Schema.

You will learn more about adding extra information later in the docs, when learning to declare examples.

Warning

Extra keys passed to `Field` will also be present in the resulting OpenAPI schema for your application. As these keys may not necessarily be part of the OpenAPI specification, some OpenAPI tools, for example the OpenAPI validator, may not work with your generated schema.

### Recap

You can use Pydantic's `Field` to declare extra validations and metadata for model attributes.

You can also use the extra keyword arguments to pass additional JSON Schema metadata.




**FastAPI** allows you to declare additional information and validation for your parameters.

Let's take this application as example:

Python 3.10+Python 3.6+

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: str | None = None):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Union  from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Union[str, None] = None):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

The query parameter `q` is of type `Union[str, None]` (or `str | None` in Python 3.10), that means that it's of type `str` but could also be `None`, and indeed, the default value is `None`, so FastAPI will know it's not required.

Note

FastAPI will know that the value of `q` is not required because of the default value `= None`.

The `Union` in `Union[str, None]` will allow your editor to give you better support and detect errors.

### Additional validation

We are going to enforce that even though `q` is optional, whenever it is provided, **its length doesn't exceed 50 characters**.

#### Import `Query` and `Annotated`

To achieve that, first import:

- `Query` from `fastapi`
- `Annotated` from `typing` (or from `typing_extensions` in Python below 3.9)

Python 3.10+Python 3.6+

In Python 3.9 or above, `Annotated` is part of the standard library, so you can import it from `typing`.

`from typing import Annotated from fastapi import FastAPI, Query app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[str | None, Query(max_length=50)] = None):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

In versions of Python below Python 3.9 you import `Annotated` from `typing_extensions`.

It will already be installed with FastAPI.

`from typing import Union  from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[Union[str, None], Query(max_length=50)] = None):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Info

FastAPI added support for `Annotated` (and started recommending it) in version 0.95.0.

If you have an older version, you would get errors when trying to use `Annotated`.

Make sure you Upgrade the FastAPI version to at least 0.95.1 before using `Annotated`.

### Use `Annotated` in the type for the `q` parameter

Remember I told you before that `Annotated` can be used to add metadata to your parameters in the Python Types Intro?

Now it's the time to use it with FastAPI. 🚀

We had this type annotation:

Python 3.10+Python 3.6+

`q: Union[str, None] = None`

What we will do is wrap that with `Annotated`, so it becomes:

Python 3.10+Python 3.6+

`q: Annotated[str | None] = None`

`q: Annotated[Union[str, None]] = None`

Both of those versions mean the same thing, `q` is a parameter that can be a `str` or `None`, and by default, it is `None`.

Now let's jump to the fun stuff. 🎉

### Add `Query` to `Annotated` in the `q` parameter

Now that we have this `Annotated` where we can put more metadata, add `Query` to it, and set the parameter `max_length` to 50:

Python 3.10+Python 3.6+

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[str | None, Query(max_length=50)] = None):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Union  from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[Union[str, None], Query(max_length=50)] = None):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Notice that the default value is still `None`, so the parameter is still optional.

But now, having `Query(max_length=50)` inside of `Annotated`, we are telling FastAPI that we want it to extract this value from the query parameters (this would have been the default anyway 🤷) and that we want to have **additional validation** for this value (that's why we do this, to get the additional validation). 😎

FastAPI will now:

- **Validate** the data making sure that the max length is 50 characters
- Show a **clear error** for the client when the data is not valid
- **Document** the parameter in the OpenAPI schema *path operation* (so it will show up in the **automatic docs UI**)

### Alternative (old) `Query` as the default value

Previous versions of FastAPI (before 0.95.0) required you to use `Query` as the default value of your parameter, instead of putting it in `Annotated`, there's a high chance that you will see code using it around, so I'll explain it to you.

Tip

For new code and whenever possible, use `Annotated` as explained above. There are multiple advantages (explained below) and no disadvantages. 🍰

This is how you would use `Query()` as the default value of your function parameter, setting the parameter `max_length` to 50:

Python 3.10+Python 3.6+

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: str | None = Query(default=None, max_length=50)):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Union[str, None] = Query(default=None, max_length=50)):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

As in this case (without using `Annotated`) we have to replace the default value `None` in the function with `Query()`, we now need to set the default value with the parameter `Query(default=None)`, it serves the same purpose of defining that default value (at least for FastAPI).

So:

`q: Union[str, None] = Query(default=None)`

...makes the parameter optional, with a default value of `None`, the same as:

`q: Union[str, None] = None`

And in Python 3.10 and above:

`q: str | None = Query(default=None)`

...makes the parameter optional, with a default value of `None`, the same as:

But it declares it explicitly as being a query parameter.

Info

Have in mind that the most important part to make a parameter optional is the part:

or the:

as it will use that `None` as the default value, and that way make the parameter **not required**.

The `Union[str, None]` part allows your editor to provide better support, but it is not what tells FastAPI that this parameter is not required.

Then, we can pass more parameters to `Query`. In this case, the `max_length` parameter that applies to strings:

`q: Union[str, None] = Query(default=None, max_length=50)`

This will validate the data, show a clear error when the data is not valid, and document the parameter in the OpenAPI schema *path operation*.

#### `Query` as the default value or in `Annotated`

Have in mind that when using `Query` inside of `Annotated` you cannot use the `default` parameter for `Query`.

Instead use the actual default value of the function parameter. Otherwise, it would be inconsistent.

For example, this is not allowed:

`q: Annotated[str, Query(default=&quot;rick&quot;)] = &quot;morty&quot;`

...because it's not clear if the default value should be `&quot;rick&quot;` or `&quot;morty&quot;`.

So, you would use (preferably):

`q: Annotated[str, Query()] = &quot;rick&quot;`

...or in older code bases you will find:

`q: str = Query(default=&quot;rick&quot;)`

#### Advantages of `Annotated`

**Using `Annotated` is recommended** instead of the default value in function parameters, it is **better** for multiple reasons. 🤓

The **default** value of the **function parameter** is the **actual default** value, that's more intuitive with Python in general. 😌

You could **call** that same function in **other places** without FastAPI, and it would **work as expected**. If there's a **required** parameter (without a default value), your **editor** will let you know with an error, **Python** will also complain if you run it without passing the required parameter.

When you don't use `Annotated` and instead use the **(old) default value style**, if you call that function without FastAPI in **other place**, you have to **remember** to pass the arguments to the function for it to work correctly, otherwise the values will be different from what you expect (e.g. `QueryInfo` or something similar instead of `str`). And your editor won't complain, and Python won't complain running that function, only when the operations inside error out.

Because `Annotated` can have more than one metadata annotation, you could now even use the same function with other tools, like Typer. 🚀

### Add more validations

You can also add a parameter `min_length`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[str | None, Query(min_length=3, max_length=50)] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Annotated, Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[Union[str, None], Query(min_length=3, max_length=50)] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Union  from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[Union[str, None], Query(min_length=3, max_length=50)] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: str | None = Query(default=None, min_length=3, max_length=50)):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Union[str, None] = Query(default=None, min_length=3, max_length=50) ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

### Add regular expressions

You can define a regular expression `pattern` that the parameter should match:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[         str | None, Query(min_length=3, max_length=50, pattern=&quot;^fixedquery$&quot;)    ] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Annotated, Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[         Union[str, None], Query(min_length=3, max_length=50, pattern=&quot;^fixedquery$&quot;)    ] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Union  from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[         Union[str, None], Query(min_length=3, max_length=50, pattern=&quot;^fixedquery$&quot;)    ] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: str     | None = Query(default=None, min_length=3, max_length=50, pattern=&quot;^fixedquery$&quot;) ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Union[str, None] = Query(         default=None, min_length=3, max_length=50, pattern=&quot;^fixedquery$&quot;    ) ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

This specific regular expression pattern checks that the received parameter value:

- `^`: starts with the following characters, doesn't have characters before.
- `fixedquery`: has the exact value `fixedquery`.
- `$`: ends there, doesn't have any more characters after `fixedquery`.

If you feel lost with all these **"regular expression"** ideas, don't worry. They are a hard topic for many people. You can still do a lot of stuff without needing regular expressions yet.

But whenever you need them and go and learn them, know that you can already use them directly in **FastAPI**.

#### Pydantic v1 `regex` instead of `pattern`

Before Pydantic version 2 and before FastAPI 0.100.0, the parameter was called `regex` instead of `pattern`, but it's now deprecated.

You could still see some code using it:

Python 3.10+ Pydantic v1

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[         str | None, Query(min_length=3, max_length=50, regex=&quot;^fixedquery$&quot;)    ] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

But know that this is deprecated and it should be updated to use the new parameter `pattern`. 🤓

### Default values

You can, of course, use default values other than `None`.

Let's say that you want to declare the `q` query parameter to have a `min_length` of `3`, and to have a default value of `&quot;fixedquery&quot;`:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[str, Query(min_length=3)] = &quot;fixedquery&quot;):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[str, Query(min_length=3)] = &quot;fixedquery&quot;):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: str = Query(default=&quot;fixedquery&quot;, min_length=3)):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Note

Having a default value of any type, including `None`, makes the parameter optional (not required).

### Make it required

When we don't need to declare more validations or metadata, we can make the `q` query parameter required just by not declaring a default value, like:

instead of:

`q: Union[str, None] = None`

But we are now declaring it with `Query`, for example like:

Annotatednon-Annotated

`q: Annotated[Union[str, None], Query(min_length=3)] = None`

`q: Union[str, None] = Query(default=None, min_length=3)`

So, when you need to declare a value as required while using `Query`, you can simply not declare a default value:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[str, Query(min_length=3)]):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[str, Query(min_length=3)]):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: str = Query(min_length=3)):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Notice that, even though in this case the `Query()` is used as the function parameter default value, we don't pass the `default=None` to `Query()`.

Still, probably better to use the `Annotated` version. 😉

#### Required with Ellipsis (`...`)

There's an alternative way to explicitly declare that a value is required. You can set the default to the literal value `...`:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[str, Query(min_length=3)] = ...):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[str, Query(min_length=3)] = ...):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: str = Query(default=..., min_length=3)):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Info

If you hadn't seen that `...` before: it is a special single value, it is part of Python and is called "Ellipsis".

It is used by Pydantic and FastAPI to explicitly declare that a value is required.

This will let **FastAPI** know that this parameter is required.

#### Required with `None`

You can declare that a parameter can accept `None`, but that it's still required. This would force clients to send a value, even if the value is `None`.

To do that, you can declare that `None` is a valid type but still use `...` as the default:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[str | None, Query(min_length=3)] = ...):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Annotated, Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[Union[str, None], Query(min_length=3)] = ...):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Union  from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[Union[str, None], Query(min_length=3)] = ...):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: str | None = Query(default=..., min_length=3)):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Union[str, None] = Query(default=..., min_length=3)):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Pydantic, which is what powers all the data validation and serialization in FastAPI, has a special behavior when you use `Optional` or `Union[Something, None]` without a default value, you can read more about it in the Pydantic docs about Required Optional fields.

#### Use Pydantic's `Required` instead of Ellipsis (`...`)

If you feel uncomfortable using `...`, you can also import and use `Required` from Pydantic:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query from pydantic import Required app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[str, Query(min_length=3)] = Required):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from fastapi import FastAPI, Query from pydantic import Required from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[str, Query(min_length=3)] = Required):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query from pydantic import Required app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: str = Query(default=Required, min_length=3)):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Remember that in most of the cases, when something is required, you can simply omit the default, so you normally don't have to use `...` nor `Required`.

### Query parameter list / multiple values

When you define a query parameter explicitly with `Query` you can also declare it to receive a list of values, or said in other way, to receive multiple values.

For example, to declare a query parameter `q` that can appear multiple times in the URL, you can write:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.9+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[list[str] | None, Query()] = None):     query_items = {&quot;q&quot;: q}     return query_items`

`from typing import Annotated, Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[Union[list[str], None], Query()] = None):     query_items = {&quot;q&quot;: q}     return query_items`

`from typing import List, Union  from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[Union[List[str], None], Query()] = None):     query_items = {&quot;q&quot;: q}     return query_items`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: list[str] | None = Query(default=None)):     query_items = {&quot;q&quot;: q}     return query_items`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Union[list[str], None] = Query(default=None)):     query_items = {&quot;q&quot;: q}     return query_items`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import List, Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Union[List[str], None] = Query(default=None)):     query_items = {&quot;q&quot;: q}     return query_items`

Then, with a URL like:

`http://localhost:8000/items/?q=foo&amp;q=bar`

you would receive the multiple `q` *query parameters'* values (`foo` and `bar`) in a Python `list` inside your *path operation function*, in the *function parameter* `q`.

So, the response to that URL would be:

`{   &quot;q&quot;: [     &quot;foo&quot;,     &quot;bar&quot;   ] }`

Tip

To declare a query parameter with a type of `list`, like in the example above, you need to explicitly use `Query`, otherwise it would be interpreted as a request body.

The interactive API docs will update accordingly, to allow multiple values:

<image @ https://fastapi.tiangolo.com/img/tutorial/query-params-str-validations/image02.png>

#### Query parameter list / multiple values with defaults

And you can also define a default `list` of values if none are provided:

Python 3.9+Python 3.6+Python 3.9+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[list[str], Query()] = [&quot;foo&quot;, &quot;bar&quot;]):     query_items = {&quot;q&quot;: q}     return query_items`

`from typing import List  from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[List[str], Query()] = [&quot;foo&quot;, &quot;bar&quot;]):     query_items = {&quot;q&quot;: q}     return query_items`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: list[str] = Query(default=[&quot;foo&quot;, &quot;bar&quot;])):     query_items = {&quot;q&quot;: q}     return query_items`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import List  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: List[str] = Query(default=[&quot;foo&quot;, &quot;bar&quot;])):     query_items = {&quot;q&quot;: q}     return query_items`

If you go to:

`http://localhost:8000/items/`

the default of `q` will be: `[&quot;foo&quot;, &quot;bar&quot;]` and your response will be:

`{   &quot;q&quot;: [     &quot;foo&quot;,     &quot;bar&quot;   ] }`

##### Using `list`

You can also use `list` directly instead of `List[str]` (or `list[str]` in Python 3.9+):

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[list, Query()] = []):     query_items = {&quot;q&quot;: q}     return query_items`

`from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[list, Query()] = []):     query_items = {&quot;q&quot;: q}     return query_items`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: list = Query(default=[])):     query_items = {&quot;q&quot;: q}     return query_items`

Note

Have in mind that in this case, FastAPI won't check the contents of the list.

For example, `List[int]` would check (and document) that the contents of the list are integers. But `list` alone wouldn't.

You can add more information about the parameter.

That information will be included in the generated OpenAPI and used by the documentation user interfaces and external tools.

Note

Have in mind that different tools might have different levels of OpenAPI support.

Some of them might not show all the extra information declared yet, although in most of the cases, the missing feature is already planned for development.

You can add a `title`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[str | None, Query(title=&quot;Query string&quot;, min_length=3)] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Annotated, Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[Union[str, None], Query(title=&quot;Query string&quot;, min_length=3)] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Union  from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[Union[str, None], Query(title=&quot;Query string&quot;, min_length=3)] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: str | None = Query(default=None, title=&quot;Query string&quot;, min_length=3) ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Union[str, None] = Query(default=None, title=&quot;Query string&quot;, min_length=3) ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

And a `description`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[         str | None,         Query(             title=&quot;Query string&quot;,             description=&quot;Query string for the items to search in the database that have a good match&quot;,            min_length=3,         ),     ] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Annotated, Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[         Union[str, None],         Query(             title=&quot;Query string&quot;,             description=&quot;Query string for the items to search in the database that have a good match&quot;,            min_length=3,         ),     ] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Union  from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[         Union[str, None],         Query(             title=&quot;Query string&quot;,             description=&quot;Query string for the items to search in the database that have a good match&quot;,            min_length=3,         ),     ] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: str     | None = Query(         default=None,         title=&quot;Query string&quot;,         description=&quot;Query string for the items to search in the database that have a good match&quot;,        min_length=3,     ) ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Union[str, None] = Query(         default=None,         title=&quot;Query string&quot;,         description=&quot;Query string for the items to search in the database that have a good match&quot;,        min_length=3,     ) ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

### Alias parameters

Imagine that you want the parameter to be `item-query`.

Like in:

`http://127.0.0.1:8000/items/?item-query=foobaritems`

But `item-query` is not a valid Python variable name.

The closest would be `item_query`.

But you still need it to be exactly `item-query`...

Then you can declare an `alias`, and that alias is what will be used to find the parameter value:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[str | None, Query(alias=&quot;item-query&quot;)] = None):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Annotated, Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[Union[str, None], Query(alias=&quot;item-query&quot;)] = None):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Union  from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Annotated[Union[str, None], Query(alias=&quot;item-query&quot;)] = None):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: str | None = Query(default=None, alias=&quot;item-query&quot;)):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(q: Union[str, None] = Query(default=None, alias=&quot;item-query&quot;)):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

### Deprecating parameters

Now let's say you don't like this parameter anymore.

You have to leave it there a while because there are clients using it, but you want the docs to clearly show it as deprecated.

Then pass the parameter `deprecated=True` to `Query`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[         str | None,         Query(             alias=&quot;item-query&quot;,             title=&quot;Query string&quot;,             description=&quot;Query string for the items to search in the database that have a good match&quot;,             min_length=3,             max_length=50,             pattern=&quot;^fixedquery$&quot;,             deprecated=True,        ),     ] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Annotated, Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[         Union[str, None],         Query(             alias=&quot;item-query&quot;,             title=&quot;Query string&quot;,             description=&quot;Query string for the items to search in the database that have a good match&quot;,             min_length=3,             max_length=50,             pattern=&quot;^fixedquery$&quot;,             deprecated=True,        ),     ] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Union  from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Annotated[         Union[str, None],         Query(             alias=&quot;item-query&quot;,             title=&quot;Query string&quot;,             description=&quot;Query string for the items to search in the database that have a good match&quot;,             min_length=3,             max_length=50,             pattern=&quot;^fixedquery$&quot;,             deprecated=True,        ),     ] = None ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: str     | None = Query(         default=None,         alias=&quot;item-query&quot;,         title=&quot;Query string&quot;,         description=&quot;Query string for the items to search in the database that have a good match&quot;,         min_length=3,         max_length=50,         pattern=&quot;^fixedquery$&quot;,         deprecated=True,    ) ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     q: Union[str, None] = Query(         default=None,         alias=&quot;item-query&quot;,         title=&quot;Query string&quot;,         description=&quot;Query string for the items to search in the database that have a good match&quot;,         min_length=3,         max_length=50,         pattern=&quot;^fixedquery$&quot;,         deprecated=True,    ) ):     results = {&quot;items&quot;: [{&quot;item_id&quot;: &quot;Foo&quot;}, {&quot;item_id&quot;: &quot;Bar&quot;}]}     if q:         results.update({&quot;q&quot;: q})     return results`

The docs will show it like this:

<image @ https://fastapi.tiangolo.com/img/tutorial/query-params-str-validations/image01.png>

### Exclude from OpenAPI

To exclude a query parameter from the generated OpenAPI schema (and thus, from the automatic documentation systems), set the parameter `include_in_schema` of `Query` to `False`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     hidden_query: Annotated[str | None, Query(include_in_schema=False)] = None ):     if hidden_query:         return {&quot;hidden_query&quot;: hidden_query}     else:         return {&quot;hidden_query&quot;: &quot;Not found&quot;}`

`from typing import Annotated, Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     hidden_query: Annotated[Union[str, None], Query(include_in_schema=False)] = None ):     if hidden_query:         return {&quot;hidden_query&quot;: hidden_query}     else:         return {&quot;hidden_query&quot;: &quot;Not found&quot;}`

`from typing import Union  from fastapi import FastAPI, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     hidden_query: Annotated[Union[str, None], Query(include_in_schema=False)] = None ):     if hidden_query:         return {&quot;hidden_query&quot;: hidden_query}     else:         return {&quot;hidden_query&quot;: &quot;Not found&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     hidden_query: str | None = Query(default=None, include_in_schema=False) ):     if hidden_query:         return {&quot;hidden_query&quot;: hidden_query}     else:         return {&quot;hidden_query&quot;: &quot;Not found&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Query  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     hidden_query: Union[str, None] = Query(default=None, include_in_schema=False) ):     if hidden_query:         return {&quot;hidden_query&quot;: hidden_query}     else:         return {&quot;hidden_query&quot;: &quot;Not found&quot;}`

### Recap

You can declare additional validations and metadata for your parameters.

Generic validations and metadata:

- `alias`
- `title`
- `description`
- `deprecated`

Validations specific for strings:

- `min_length`
- `max_length`
- `regex`

In these examples you saw how to declare validations for `str` values.

See the next chapters to see how to declare validations for other types, like numbers.




In the same way that you can declare more validations and metadata for query parameters with `Query`, you can declare the same type of validations and metadata for path parameters with `Path`.

### Import Path

First, import `Path` from `fastapi`, and import `Annotated`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated from fastapi import FastAPI, Path, Query app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;)],     q: Annotated[str | None, Query(alias=&quot;item-query&quot;)] = None, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Annotated, Union from fastapi import FastAPI, Path, Query app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;)],     q: Annotated[Union[str, None], Query(alias=&quot;item-query&quot;)] = None, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Union  from fastapi import FastAPI, Path, Query from typing_extensions import Annotated app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;)],     q: Annotated[Union[str, None], Query(alias=&quot;item-query&quot;)] = None, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Path, Query app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: int = Path(title=&quot;The ID of the item to get&quot;),     q: str | None = Query(default=None, alias=&quot;item-query&quot;), ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Path, Query app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: int = Path(title=&quot;The ID of the item to get&quot;),     q: Union[str, None] = Query(default=None, alias=&quot;item-query&quot;), ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

Info

FastAPI added support for `Annotated` (and started recommending it) in version 0.95.0.

If you have an older version, you would get errors when trying to use `Annotated`.

Make sure you Upgrade the FastAPI version to at least 0.95.1 before using `Annotated`.

You can declare all the same parameters as for `Query`.

For example, to declare a `title` metadata value for the path parameter `item_id` you can type:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Path, Query  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;)],    q: Annotated[str | None, Query(alias=&quot;item-query&quot;)] = None, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Annotated, Union  from fastapi import FastAPI, Path, Query  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;)],    q: Annotated[Union[str, None], Query(alias=&quot;item-query&quot;)] = None, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Union  from fastapi import FastAPI, Path, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;)],    q: Annotated[Union[str, None], Query(alias=&quot;item-query&quot;)] = None, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Path, Query  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: int = Path(title=&quot;The ID of the item to get&quot;),    q: str | None = Query(default=None, alias=&quot;item-query&quot;), ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Path, Query  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: int = Path(title=&quot;The ID of the item to get&quot;),    q: Union[str, None] = Query(default=None, alias=&quot;item-query&quot;), ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

Note

A path parameter is always required as it has to be part of the path.

So, you should declare it with `...` to mark it as required.

Nevertheless, even if you declared it with `None` or set a default value, it would not affect anything, it would still be always required.

### Order the parameters as you need

Tip

This is probably not as important or necessary if you use `Annotated`.

Let's say that you want to declare the query parameter `q` as a required `str`.

And you don't need to declare anything else for that parameter, so you don't really need to use `Query`.

But you still need to use `Path` for the `item_id` path parameter. And you don't want to use `Annotated` for some reason.

Python will complain if you put a value with a "default" before a value that doesn't have a "default".

But you can re-order them, and have the value without a default (the query parameter `q`) first.

It doesn't matter for **FastAPI**. It will detect the parameters by their names, types and default declarations (`Query`, `Path`, etc), it doesn't care about the order.

So, you can declare your function as:

Python 3.6 non-Annotated

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Path  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(q: str, item_id: int = Path(title=&quot;The ID of the item to get&quot;)):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

But have in mind that if you use `Annotated`, you won't have this problem, it won't matter as you're not using the function parameter default values for `Query()` or `Path()`.

Python 3.9+Python 3.6+

`from typing import Annotated  from fastapi import FastAPI, Path  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     q: str, item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;)] ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

`from fastapi import FastAPI, Path from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     q: str, item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;)] ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

### Order the parameters as you need, tricks

Tip

This is probably not as important or necessary if you use `Annotated`.

Here's a **small trick** that can be handy, but you won't need it often.

If you want to:

- declare the `q` query parameter without a `Query` nor any default value
- declare the path parameter `item_id` using `Path`
- have them in a different order
- not use `Annotated`

...Python has a little special syntax for that.

Pass `*`, as the first parameter of the function.

Python won't do anything with that `*`, but it will know that all the following parameters should be called as keyword arguments (key-value pairs), also known as `kwargs`. Even if they don't have a default value.

`from fastapi import FastAPI, Path  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(*, item_id: int = Path(title=&quot;The ID of the item to get&quot;), q: str):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

#### Better with `Annotated`

Have in mind that if you use `Annotated`, as you are not using function parameter default values, you won't have this problem, and you probably won't need to use `*`.

Python 3.9+Python 3.6+

`from typing import Annotated  from fastapi import FastAPI, Path  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;)], q: str ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

`from fastapi import FastAPI, Path from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;)], q: str ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

### Number validations: greater than or equal

With `Query` and `Path` (and others you'll see later) you can declare number constraints.

Here, with `ge=1`, `item_id` will need to be an integer number "`g`reater than or `e`qual" to `1`.

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Path  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;, ge=1)], q: str ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

`from fastapi import FastAPI, Path from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;, ge=1)], q: str ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Path  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     *, item_id: int = Path(title=&quot;The ID of the item to get&quot;, ge=1), q: str ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

### Number validations: greater than and less than or equal

The same applies for:

- `gt`: `g`reater `t`han
- `le`: `l`ess than or `e`qual

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Path  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;, gt=0, le=1000)],    q: str, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

`from fastapi import FastAPI, Path from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;, gt=0, le=1000)],    q: str, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Path  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     *,     item_id: int = Path(title=&quot;The ID of the item to get&quot;, gt=0, le=1000),    q: str, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

### Number validations: floats, greater than and less than

Number validations also work for `float` values.

Here's where it becomes important to be able to declare `gt` and not just `ge`. As with it you can require, for example, that a value must be greater than `0`, even if it is less than `1`.

So, `0.5` would be a valid value. But `0.0` or `0` would not.

And the same for `lt`.

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Path, Query  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     *,     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;, ge=0, le=1000)],     q: str,     size: Annotated[float, Query(gt=0, lt=10.5)], ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

`from fastapi import FastAPI, Path, Query from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     *,     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;, ge=0, le=1000)],     q: str,     size: Annotated[float, Query(gt=0, lt=10.5)], ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Path, Query  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) async def read_items(     *,     item_id: int = Path(title=&quot;The ID of the item to get&quot;, ge=0, le=1000),     q: str,     size: float = Query(gt=0, lt=10.5), ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     return results`

### Recap

With `Query`, `Path` (and others you haven't seen yet) you can declare metadata and string validations in the same ways as with Query Parameters and String Validations.

And you can also declare numeric validations:

- `gt`: `g`reater `t`han
- `ge`: `g`reater than or `e`qual
- `lt`: `l`ess `t`han
- `le`: `l`ess than or `e`qual

Info

`Query`, `Path`, and other classes you will see later are subclasses of a common `Param` class.

All of them share the same parameters for additional validation and metadata you have seen.

Technical Details

When you import `Query`, `Path` and others from `fastapi`, they are actually functions.

That when called, return instances of classes of the same name.

So, you import `Query`, which is a function. And when you call it, it returns an instance of a class also named `Query`.

These functions are there (instead of just using the classes directly) so that your editor doesn't mark errors about their types.

That way you can use your normal editor and coding tools without having to add custom configurations to disregard those errors.




Now that we have seen how to use `Path` and `Query`, let's see more advanced uses of request body declarations.

### Mix `Path`, `Query` and body parameters

First, of course, you can mix `Path`, `Query` and request body parameter declarations freely and **FastAPI** will know what to do.

And you can also declare body parameters as optional, by setting the default to `None`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Path from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;, ge=0, le=1000)],    q: str | None = None,    item: Item | None = None, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     if item:         results.update({&quot;item&quot;: item})     return results`

`from typing import Annotated, Union  from fastapi import FastAPI, Path from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;, ge=0, le=1000)],    q: Union[str, None] = None,    item: Union[Item, None] = None, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     if item:         results.update({&quot;item&quot;: item})     return results`

`from typing import Union  from fastapi import FastAPI, Path from pydantic import BaseModel from typing_extensions import Annotated  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     item_id: Annotated[int, Path(title=&quot;The ID of the item to get&quot;, ge=0, le=1000)],    q: Union[str, None] = None,    item: Union[Item, None] = None, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     if item:         results.update({&quot;item&quot;: item})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Path from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     *,     item_id: int = Path(title=&quot;The ID of the item to get&quot;, ge=0, le=1000),    q: str | None = None,    item: Item | None = None, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     if item:         results.update({&quot;item&quot;: item})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Path from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     *,     item_id: int = Path(title=&quot;The ID of the item to get&quot;, ge=0, le=1000),    q: Union[str, None] = None,    item: Union[Item, None] = None, ):     results = {&quot;item_id&quot;: item_id}     if q:         results.update({&quot;q&quot;: q})     if item:         results.update({&quot;item&quot;: item})     return results`

Note

Notice that, in this case, the `item` that would be taken from the body is optional. As it has a `None` default value.

### Multiple body parameters

In the previous example, the *path operations* would expect a JSON body with the attributes of an `Item`, like:

`{     &quot;name&quot;: &quot;Foo&quot;,     &quot;description&quot;: &quot;The pretender&quot;,     &quot;price&quot;: 42.0,     &quot;tax&quot;: 3.2 }`

But you can also declare multiple body parameters, e.g. `item` and `user`:

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  class User(BaseModel):     username: str     full_name: str | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item, user: User):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user}     return results`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  class User(BaseModel):     username: str     full_name: Union[str, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item, user: User):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user}     return results`

In this case, **FastAPI** will notice that there are more than one body parameters in the function (two parameters that are Pydantic models).

So, it will then use the parameter names as keys (field names) in the body, and expect a body like:

`{     &quot;item&quot;: {         &quot;name&quot;: &quot;Foo&quot;,         &quot;description&quot;: &quot;The pretender&quot;,         &quot;price&quot;: 42.0,         &quot;tax&quot;: 3.2     },     &quot;user&quot;: {         &quot;username&quot;: &quot;dave&quot;,         &quot;full_name&quot;: &quot;Dave Grohl&quot;     } }`

Note

Notice that even though the `item` was declared the same way as before, it is now expected to be inside of the body with a key `item`.

**FastAPI** will do the automatic conversion from the request, so that the parameter `item` receives it's specific content and the same for `user`.

It will perform the validation of the compound data, and will document it like that for the OpenAPI schema and automatic docs.

### Singular values in body

The same way there is a `Query` and `Path` to define extra data for query and path parameters, **FastAPI** provides an equivalent `Body`.

For example, extending the previous model, you could decide that you want to have another key `importance` in the same body, besides the `item` and `user`.

If you declare it as is, because it is a singular value, **FastAPI** will assume that it is a query parameter.

But you can instruct **FastAPI** to treat it as another body key using `Body`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  class User(BaseModel):     username: str     full_name: str | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     item_id: int, item: Item, user: User, importance: Annotated[int, Body()] ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user, &quot;importance&quot;: importance}     return results`

`from typing import Annotated, Union  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  class User(BaseModel):     username: str     full_name: Union[str, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     item_id: int, item: Item, user: User, importance: Annotated[int, Body()] ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user, &quot;importance&quot;: importance}     return results`

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel from typing_extensions import Annotated  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  class User(BaseModel):     username: str     full_name: Union[str, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     item_id: int, item: Item, user: User, importance: Annotated[int, Body()] ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user, &quot;importance&quot;: importance}     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  class User(BaseModel):     username: str     full_name: str | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item, user: User, importance: int = Body()):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user, &quot;importance&quot;: importance}     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  class User(BaseModel):     username: str     full_name: Union[str, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item, user: User, importance: int = Body()):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user, &quot;importance&quot;: importance}     return results`

In this case, **FastAPI** will expect a body like:

`{     &quot;item&quot;: {         &quot;name&quot;: &quot;Foo&quot;,         &quot;description&quot;: &quot;The pretender&quot;,         &quot;price&quot;: 42.0,         &quot;tax&quot;: 3.2     },     &quot;user&quot;: {         &quot;username&quot;: &quot;dave&quot;,         &quot;full_name&quot;: &quot;Dave Grohl&quot;     },     &quot;importance&quot;: 5 }`

Again, it will convert the data types, validate, document, etc.

### Multiple body params and query

Of course, you can also declare additional query parameters whenever you need, additional to any body parameters.

As, by default, singular values are interpreted as query parameters, you don't have to explicitly add a `Query`, you can just do:

`q: Union[str, None] = None`

Or in Python 3.10 and above:

For example:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  class User(BaseModel):     username: str     full_name: str | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     *,     item_id: int,     item: Item,     user: User,     importance: Annotated[int, Body(gt=0)],    q: str | None = None, ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user, &quot;importance&quot;: importance}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Annotated, Union  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  class User(BaseModel):     username: str     full_name: Union[str, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     *,     item_id: int,     item: Item,     user: User,     importance: Annotated[int, Body(gt=0)],    q: Union[str, None] = None, ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user, &quot;importance&quot;: importance}     if q:         results.update({&quot;q&quot;: q})     return results`

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel from typing_extensions import Annotated  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  class User(BaseModel):     username: str     full_name: Union[str, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     *,     item_id: int,     item: Item,     user: User,     importance: Annotated[int, Body(gt=0)],    q: Union[str, None] = None, ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user, &quot;importance&quot;: importance}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  class User(BaseModel):     username: str     full_name: str | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     *,     item_id: int,     item: Item,     user: User,     importance: int = Body(gt=0),    q: str | None = None, ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user, &quot;importance&quot;: importance}     if q:         results.update({&quot;q&quot;: q})     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  class User(BaseModel):     username: str     full_name: Union[str, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     *,     item_id: int,     item: Item,     user: User,     importance: int = Body(gt=0),    q: Union[str, None] = None, ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item, &quot;user&quot;: user, &quot;importance&quot;: importance}     if q:         results.update({&quot;q&quot;: q})     return results`

Info

`Body` also has all the same extra validation and metadata parameters as `Query`,`Path` and others you will see later.

### Embed a single body parameter

Let's say you only have a single `item` body parameter from a Pydantic model `Item`.

By default, **FastAPI** will then expect its body directly.

But if you want it to expect a JSON with a key `item` and inside of it the model contents, as it does when you declare extra body parameters, you can use the special `Body` parameter `embed`:

`item: Item = Body(embed=True)`

as in:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Annotated, Union  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel from typing_extensions import Annotated  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item = Body(embed=True)):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item = Body(embed=True)):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

In this case **FastAPI** will expect a body like:

`{     &quot;item&quot;: {        &quot;name&quot;: &quot;Foo&quot;,         &quot;description&quot;: &quot;The pretender&quot;,         &quot;price&quot;: 42.0,         &quot;tax&quot;: 3.2     } }`

instead of:

`{     &quot;name&quot;: &quot;Foo&quot;,     &quot;description&quot;: &quot;The pretender&quot;,     &quot;price&quot;: 42.0,     &quot;tax&quot;: 3.2 }`

### Recap

You can add multiple body parameters to your *path operation function*, even though a request can only have a single body.

But **FastAPI** will handle it, give you the correct data in your function, and validate and document the correct schema in the *path operation*.

You can also declare singular values to be received as part of the body.

And you can instruct **FastAPI** to embed the body in a key even when there is only a single parameter declared.




With **FastAPI**, you can define, validate, document, and use arbitrarily deeply nested models (thanks to Pydantic).

### List fields

You can define an attribute to be a subtype. For example, a Python `list`:

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: list = []  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: list = []  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

This will make `tags` be a list, although it doesn't declare the type of the elements of the list.

### List fields with type parameter

But Python has a specific way to declare lists with internal types, or "type parameters":

#### Import typing's `List`

In Python 3.9 and above you can use the standard `list` to declare these type annotations as we'll see below. 💡

But in Python versions before 3.9 (3.6 and above), you first need to import `List` from standard Python's `typing` module:

`from typing import List, Union from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: List[str] = []  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

#### Declare a `list` with a type parameter

To declare types that have type parameters (internal types), like `list`, `dict`, `tuple`:

- If you are in a Python version lower than 3.9, import their equivalent version from the `typing` module
- Pass the internal type(s) as "type parameters" using square brackets: `[` and `]`

In Python 3.9 it would be:

In versions of Python before 3.9, it would be:

`from typing import List  my_list: List[str]`

That's all standard Python syntax for type declarations.

Use that same standard syntax for model attributes with internal types.

So, in our example, we can make `tags` be specifically a "list of strings":

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: list[str] = []  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: list[str] = []  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import List, Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: List[str] = []  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

### Set types

But then we think about it, and realize that tags shouldn't repeat, they would probably be unique strings.

And Python has a special data type for sets of unique items, the `set`.

Then we can declare `tags` as a set of strings:

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: set[str] = set()  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: set[str] = set()  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Set, Union from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: Set[str] = set()  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

With this, even if you receive a request with duplicate data, it will be converted to a set of unique items.

And whenever you output that data, even if the source had duplicates, it will be output as a set of unique items.

And it will be annotated / documented accordingly too.

### Nested Models

Each attribute of a Pydantic model has a type.

But that type can itself be another Pydantic model.

So, you can declare deeply nested JSON "objects" with specific attribute names, types and validations.

All that, arbitrarily nested.

#### Define a submodel

For example, we can define an `Image` model:

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Image(BaseModel):     url: str    name: str  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: set[str] = set()     image: Image | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Image(BaseModel):     url: str    name: str  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: set[str] = set()     image: Union[Image, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Set, Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Image(BaseModel):     url: str    name: str  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: Set[str] = set()     image: Union[Image, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

#### Use the submodel as a type

And then we can use it as the type of an attribute:

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Image(BaseModel):     url: str     name: str  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: set[str] = set()     image: Image | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Image(BaseModel):     url: str     name: str  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: set[str] = set()     image: Union[Image, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Set, Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Image(BaseModel):     url: str     name: str  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: Set[str] = set()     image: Union[Image, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

This would mean that **FastAPI** would expect a body similar to:

`{     &quot;name&quot;: &quot;Foo&quot;,     &quot;description&quot;: &quot;The pretender&quot;,     &quot;price&quot;: 42.0,     &quot;tax&quot;: 3.2,     &quot;tags&quot;: [&quot;rock&quot;, &quot;metal&quot;, &quot;bar&quot;],     &quot;image&quot;: {         &quot;url&quot;: &quot;http://example.com/baz.jpg&quot;,         &quot;name&quot;: &quot;The Foo live&quot;     } }`

Again, doing just that declaration, with **FastAPI** you get:

- Editor support (completion, etc), even for nested models
- Data conversion
- Data validation
- Automatic documentation

### Special types and validation

Apart from normal singular types like `str`, `int`, `float`, etc. You can use more complex singular types that inherit from `str`.

To see all the options you have, checkout the docs for Pydantic's exotic types. You will see some examples in the next chapter.

For example, as in the `Image` model we have a `url` field, we can declare it to be instead of a `str`, a Pydantic's `HttpUrl`:

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI()  class Image(BaseModel):     url: HttpUrl    name: str  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: set[str] = set()     image: Image | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI()  class Image(BaseModel):     url: HttpUrl    name: str  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: set[str] = set()     image: Union[Image, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Set, Union  from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI()  class Image(BaseModel):     url: HttpUrl    name: str  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: Set[str] = set()     image: Union[Image, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

The string will be checked to be a valid URL, and documented in JSON Schema / OpenAPI as such.

### Attributes with lists of submodels

You can also use Pydantic models as subtypes of `list`, `set`, etc:

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel, HttpUrl  app = FastAPI()  class Image(BaseModel):     url: HttpUrl     name: str  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: set[str] = set()     images: list[Image] | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel, HttpUrl  app = FastAPI()  class Image(BaseModel):     url: HttpUrl     name: str  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: set[str] = set()     images: Union[list[Image], None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import List, Set, Union  from fastapi import FastAPI from pydantic import BaseModel, HttpUrl  app = FastAPI()  class Image(BaseModel):     url: HttpUrl     name: str  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: Set[str] = set()     images: Union[List[Image], None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

This will expect (convert, validate, document, etc) a JSON body like:

`{     &quot;name&quot;: &quot;Foo&quot;,     &quot;description&quot;: &quot;The pretender&quot;,     &quot;price&quot;: 42.0,     &quot;tax&quot;: 3.2,     &quot;tags&quot;: [         &quot;rock&quot;,         &quot;metal&quot;,         &quot;bar&quot;     ],     &quot;images&quot;: [        {             &quot;url&quot;: &quot;http://example.com/baz.jpg&quot;,             &quot;name&quot;: &quot;The Foo live&quot;         },         {             &quot;url&quot;: &quot;http://example.com/dave.jpg&quot;,             &quot;name&quot;: &quot;The Baz&quot;         }     ] }`

Info

Notice how the `images` key now has a list of image objects.

### Deeply nested models

You can define arbitrarily deeply nested models:

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel, HttpUrl  app = FastAPI()  class Image(BaseModel):     url: HttpUrl     name: str  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: set[str] = set()     images: list[Image] | None = None  class Offer(BaseModel):     name: str     description: str | None = None     price: float     items: list[Item]  @app.post(&quot;/offers/&quot;) async def create_offer(offer: Offer):     return offer`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel, HttpUrl  app = FastAPI()  class Image(BaseModel):     url: HttpUrl     name: str  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: set[str] = set()     images: Union[list[Image], None] = None  class Offer(BaseModel):     name: str     description: Union[str, None] = None     price: float     items: list[Item]  @app.post(&quot;/offers/&quot;) async def create_offer(offer: Offer):     return offer`

`from typing import List, Set, Union  from fastapi import FastAPI from pydantic import BaseModel, HttpUrl  app = FastAPI()  class Image(BaseModel):     url: HttpUrl     name: str  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: Set[str] = set()     images: Union[List[Image], None] = None  class Offer(BaseModel):     name: str     description: Union[str, None] = None     price: float     items: List[Item]  @app.post(&quot;/offers/&quot;) async def create_offer(offer: Offer):     return offer`

Info

Notice how `Offer` has a list of `Item`s, which in turn have an optional list of `Image`s

### Bodies of pure lists

If the top level value of the JSON body you expect is a JSON `array` (a Python `list`), you can declare the type in the parameter of the function, the same as in Pydantic models:

or in Python 3.9 and above:

as in:

Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel, HttpUrl  app = FastAPI()  class Image(BaseModel):     url: HttpUrl     name: str  @app.post(&quot;/images/multiple/&quot;) async def create_multiple_images(images: list[Image]):     return images`

`from typing import List  from fastapi import FastAPI from pydantic import BaseModel, HttpUrl  app = FastAPI()  class Image(BaseModel):     url: HttpUrl     name: str  @app.post(&quot;/images/multiple/&quot;) async def create_multiple_images(images: List[Image]):     return images`

### Editor support everywhere

And you get editor support everywhere.

Even for items inside of lists:

<image @ https://fastapi.tiangolo.com/img/tutorial/body-nested-models/image01.png>

You couldn't get this kind of editor support if you were working directly with `dict` instead of Pydantic models.

But you don't have to worry about them either, incoming dicts are converted automatically and your output is converted automatically to JSON too.

### Bodies of arbitrary `dict`s

You can also declare a body as a `dict` with keys of some type and values of other type.

Without having to know beforehand what are the valid field/attribute names (as would be the case with Pydantic models).

This would be useful if you want to receive keys that you don't already know.

***

Other useful case is when you want to have keys of other type, e.g. `int`.

That's what we are going to see here.

In this case, you would accept any `dict` as long as it has `int` keys with `float` values:

Python 3.9+Python 3.6+

`from fastapi import FastAPI  app = FastAPI()  @app.post(&quot;/index-weights/&quot;) async def create_index_weights(weights: dict[int, float]):     return weights`

`from typing import Dict  from fastapi import FastAPI  app = FastAPI()  @app.post(&quot;/index-weights/&quot;) async def create_index_weights(weights: Dict[int, float]):     return weights`

Tip

Have in mind that JSON only supports `str` as keys.

But Pydantic has automatic data conversion.

This means that, even though your API clients can only send strings as keys, as long as those strings contain pure integers, Pydantic will convert them and validate them.

And the `dict` you receive as `weights` will actually have `int` keys and `float` values.

### Recap

With **FastAPI** you have the maximum flexibility provided by Pydantic models, while keeping your code simple, short and elegant.

But with all the benefits:

- Editor support (completion everywhere!)
- Data conversion (a.k.a. parsing / serialization)
- Data validation
- Schema documentation
- Automatic docs




You can declare examples of the data your app can receive.

Here are several ways to do it.

You can declare `examples` for a Pydantic model that will be added to the generated JSON Schema.

Python 3.10+ Pydantic v2Python 3.10+ Pydantic v1Python 3.6+ Pydantic v2Python 3.6+ Pydantic v1

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None      model_config = {        &quot;json_schema_extra&quot;: {            &quot;examples&quot;: [                {                    &quot;name&quot;: &quot;Foo&quot;,                    &quot;description&quot;: &quot;A very nice Item&quot;,                    &quot;price&quot;: 35.4,                    &quot;tax&quot;: 3.2,                }            ]        }    }  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None      class Config:        schema_extra = {            &quot;examples&quot;: [                {                    &quot;name&quot;: &quot;Foo&quot;,                    &quot;description&quot;: &quot;A very nice Item&quot;,                    &quot;price&quot;: 35.4,                    &quot;tax&quot;: 3.2,                }            ]        }  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None      model_config = {        &quot;json_schema_extra&quot;: {            &quot;examples&quot;: [                {                    &quot;name&quot;: &quot;Foo&quot;,                    &quot;description&quot;: &quot;A very nice Item&quot;,                    &quot;price&quot;: 35.4,                    &quot;tax&quot;: 3.2,                }            ]        }    }  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None      class Config:        schema_extra = {            &quot;examples&quot;: [                {                    &quot;name&quot;: &quot;Foo&quot;,                    &quot;description&quot;: &quot;A very nice Item&quot;,                    &quot;price&quot;: 35.4,                    &quot;tax&quot;: 3.2,                }            ]        }  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

That extra info will be added as-is to the output **JSON Schema** for that model, and it will be used in the API docs.

Pydantic v2Pydantic v1

In Pydantic version 2, you would use the attribute `model_config`, that takes a `dict` as described in Pydantic's docs: Model Config.

You can set `&quot;json_schema_extra&quot;` with a `dict` containing any additonal data you would like to show up in the generated JSON Schema, including `examples`.

In Pydantic version 1, you would use an internal class `Config` and `schema_extra`, as described in Pydantic's docs: Schema customization.

You can set `schema_extra` with a `dict` containing any additonal data you would like to show up in the generated JSON Schema, including `examples`.

Tip

You could use the same technique to extend the JSON Schema and add your own custom extra info.

For example you could use it to add metadata for a frontend user interface, etc.

Info

OpenAPI 3.1.0 (used since FastAPI 0.99.0) added support for `examples`, which is part of the **JSON Schema** standard.

Before that, it only supported the keyword `example` with a single example. That is still supported by OpenAPI 3.1.0, but is deprecated and is not part of the JSON Schema standard. So you are encouraged to migrate `example` to `examples`. 🤓

You can read more at the end of this page.

### `Field` additional arguments

When using `Field()` with Pydantic models, you can also declare additional `examples`:

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel, Field app = FastAPI()  class Item(BaseModel):     name: str = Field(examples=[&quot;Foo&quot;])    description: str | None = Field(default=None, examples=[&quot;A very nice Item&quot;])    price: float = Field(examples=[35.4])    tax: float | None = Field(default=None, examples=[3.2])  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel, Field app = FastAPI()  class Item(BaseModel):     name: str = Field(examples=[&quot;Foo&quot;])    description: Union[str, None] = Field(default=None, examples=[&quot;A very nice Item&quot;])    price: float = Field(examples=[35.4])    tax: Union[float, None] = Field(default=None, examples=[3.2])  @app.put(&quot;/items/{item_id}&quot;) async def update_item(item_id: int, item: Item):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

### `examples` in OpenAPI

When using any of:

- `Path()`
- `Query()`
- `Header()`
- `Cookie()`
- `Body()`
- `Form()`
- `File()`

you can also declare a group of `examples` with additional information that will be added to **OpenAPI**.

#### `Body` with `examples`

Here we pass `examples` containing one example of the data expected in `Body()`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     item_id: int,     item: Annotated[         Item,         Body(             examples=[                {                    &quot;name&quot;: &quot;Foo&quot;,                    &quot;description&quot;: &quot;A very nice Item&quot;,                    &quot;price&quot;: 35.4,                    &quot;tax&quot;: 3.2,                }            ],        ),     ], ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Annotated, Union  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     item_id: int,     item: Annotated[         Item,         Body(             examples=[                {                    &quot;name&quot;: &quot;Foo&quot;,                    &quot;description&quot;: &quot;A very nice Item&quot;,                    &quot;price&quot;: 35.4,                    &quot;tax&quot;: 3.2,                }            ],        ),     ], ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel from typing_extensions import Annotated  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     item_id: int,     item: Annotated[         Item,         Body(             examples=[                {                    &quot;name&quot;: &quot;Foo&quot;,                    &quot;description&quot;: &quot;A very nice Item&quot;,                    &quot;price&quot;: 35.4,                    &quot;tax&quot;: 3.2,                }            ],        ),     ], ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     item_id: int,     item: Item = Body(         examples=[            {                &quot;name&quot;: &quot;Foo&quot;,                &quot;description&quot;: &quot;A very nice Item&quot;,                &quot;price&quot;: 35.4,                &quot;tax&quot;: 3.2,            }        ],    ), ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     item_id: int,     item: Item = Body(         examples=[            {                &quot;name&quot;: &quot;Foo&quot;,                &quot;description&quot;: &quot;A very nice Item&quot;,                &quot;price&quot;: 35.4,                &quot;tax&quot;: 3.2,            }        ],    ), ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

#### Example in the docs UI

With any of the methods above it would look like this in the `/docs`:

<image @ https://fastapi.tiangolo.com/img/tutorial/body-fields/image01.png>

#### `Body` with multiple `examples`

You can of course also pass multiple `examples`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     *,     item_id: int,     item: Annotated[         Item,         Body(             examples=[                {                    &quot;name&quot;: &quot;Foo&quot;,                    &quot;description&quot;: &quot;A very nice Item&quot;,                    &quot;price&quot;: 35.4,                    &quot;tax&quot;: 3.2,                },                {                    &quot;name&quot;: &quot;Bar&quot;,                    &quot;price&quot;: &quot;35.4&quot;,                },                {                    &quot;name&quot;: &quot;Baz&quot;,                    &quot;price&quot;: &quot;thirty five point four&quot;,                },            ],        ),     ], ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Annotated, Union  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     *,     item_id: int,     item: Annotated[         Item,         Body(             examples=[                {                    &quot;name&quot;: &quot;Foo&quot;,                    &quot;description&quot;: &quot;A very nice Item&quot;,                    &quot;price&quot;: 35.4,                    &quot;tax&quot;: 3.2,                },                {                    &quot;name&quot;: &quot;Bar&quot;,                    &quot;price&quot;: &quot;35.4&quot;,                },                {                    &quot;name&quot;: &quot;Baz&quot;,                    &quot;price&quot;: &quot;thirty five point four&quot;,                },            ],        ),     ], ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel from typing_extensions import Annotated  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     *,     item_id: int,     item: Annotated[         Item,         Body(             examples=[                {                    &quot;name&quot;: &quot;Foo&quot;,                    &quot;description&quot;: &quot;A very nice Item&quot;,                    &quot;price&quot;: 35.4,                    &quot;tax&quot;: 3.2,                },                {                    &quot;name&quot;: &quot;Bar&quot;,                    &quot;price&quot;: &quot;35.4&quot;,                },                {                    &quot;name&quot;: &quot;Baz&quot;,                    &quot;price&quot;: &quot;thirty five point four&quot;,                },            ],        ),     ], ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     *,     item_id: int,     item: Item = Body(         examples=[            {                &quot;name&quot;: &quot;Foo&quot;,                &quot;description&quot;: &quot;A very nice Item&quot;,                &quot;price&quot;: 35.4,                &quot;tax&quot;: 3.2,            },            {                &quot;name&quot;: &quot;Bar&quot;,                &quot;price&quot;: &quot;35.4&quot;,            },            {                &quot;name&quot;: &quot;Baz&quot;,                &quot;price&quot;: &quot;thirty five point four&quot;,            },        ],    ), ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Body, FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None  @app.put(&quot;/items/{item_id}&quot;) async def update_item(     *,     item_id: int,     item: Item = Body(         examples=[            {                &quot;name&quot;: &quot;Foo&quot;,                &quot;description&quot;: &quot;A very nice Item&quot;,                &quot;price&quot;: 35.4,                &quot;tax&quot;: 3.2,            },            {                &quot;name&quot;: &quot;Bar&quot;,                &quot;price&quot;: &quot;35.4&quot;,            },            {                &quot;name&quot;: &quot;Baz&quot;,                &quot;price&quot;: &quot;thirty five point four&quot;,            },        ],    ), ):     results = {&quot;item_id&quot;: item_id, &quot;item&quot;: item}     return results`

#### Examples in the docs UI

With `examples` added to `Body()` the `/docs` would look like:

<image @ https://fastapi.tiangolo.com/img/tutorial/body-fields/image02.png>

### Technical Details

Tip

If you are already using **FastAPI** version **0.99.0 or above**, you can probably **skip** these details.

They are more relevant for older versions, before OpenAPI 3.1.0 was available.

You can consider this a brief OpenAPI and JSON Schema **history lesson**. 🤓

Warning

These are very technical details about the standards **JSON Schema** and **OpenAPI**.

If the ideas above already work for you, that might be enough, and you probably don't need these details, feel free to skip them.

Before OpenAPI 3.1.0, OpenAPI used an older and modified version of **JSON Schema**.

JSON Schema didn't have `examples`, so OpenAPI added it's own `example` field to its own modified version.

OpenAPI also added `example` and `examples` fields to other parts of the specification:

- `Parameter Object` (in the specification) that was used by FastAPI's:
  - `Path()`
  - `Query()`
  - `Header()`
  - `Cookie()`
- `Request Body Object`, in the field `content`, on the `Media Type Object` (in the specification) that was used by FastAPI's:
  - `Body()`
  - `File()`
  - `Form()`

#### OpenAPI's `examples` field

The shape of this field `examples` from OpenAPI is a `dict` with **multiple examples**, each with extra information that will be added to **OpenAPI** too.

The keys of the `dict` identify each example, and each value is another `dict`.

Each specific example `dict` in the `examples` can contain:

- `summary`: Short description for the example.
- `description`: A long description that can contain Markdown text.
- `value`: This is the actual example shown, e.g. a `dict`.
- `externalValue`: alternative to `value`, a URL pointing to the example. Although this might not be supported by as many tools as `value`.

This applies to those other parts of the OpenAPI specification apart from JSON Schema.

#### JSON Schema's `examples` field

But then JSON Schema added an `examples` field to a new version of the specification.

And then the new OpenAPI 3.1.0 was based on the latest version (JSON Schema 2020-12) that included this new field `examples`.

And now this new `examples` field takes precedence over the old single (and custom) `example` field, that is now deprecated.

This new `examples` field in JSON Schema is **just a `list`** of examples, not a dict with extra metadata as in the other places in OpenAPI (described above).

Info

Even after OpenAPI 3.1.0 was released with this new simpler integration with JSON Schema, for a while, Swagger UI, the tool that provides the automatic docs, didn't support OpenAPI 3.1.0 (it does since version 5.0.0 🎉).

Because of that, versions of FastAPI previous to 0.99.0 still used versions of OpenAPI lower than 3.1.0.

#### Pydantic and FastAPI `examples`

When you add `examples` inside of a Pydantic model, using `schema_extra` or `Field(examples=[&quot;something&quot;])` that example is added to the **JSON Schema** for that Pydantic model.

And that **JSON Schema** of the Pydantic model is included in the **OpenAPI** of your API, and then it's used in the docs UI.

In versions of FastAPI before 0.99.0 (0.99.0 and above use the newer OpenAPI 3.1.0) when you used `example` or `examples` with any of the other utilities (`Query()`, `Body()`, etc.) those examples were not added to the JSON Schema that describes that data (not even to OpenAPI's own version of JSON Schema), they were added directly to the *path operation* declaration in OpenAPI (outside the parts of OpenAPI that use JSON Schema).

But now that FastAPI 0.99.0 and above uses OpenAPI 3.1.0, that uses JSON Schema 2020-12, and Swagger UI 5.0.0 and above, everything is more consistent and the examples are included in JSON Schema.

#### Summary

I used to say I didn't like history that much... and look at me now giving "tech history" lessons. 😅

In short, **upgrade to FastAPI 0.99.0 or above**, and things are much **simpler, consistent, and intuitive**, and you don't have to know all these historic details. 😎




You can define Cookie parameters the same way you define `Query` and `Path` parameters.

### Import `Cookie`

First import `Cookie`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Cookie, FastAPI app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(ads_id: Annotated[str | None, Cookie()] = None):     return {&quot;ads_id&quot;: ads_id}`

`from typing import Annotated, Union  from fastapi import Cookie, FastAPI app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(ads_id: Annotated[Union[str, None], Cookie()] = None):     return {&quot;ads_id&quot;: ads_id}`

`from typing import Union  from fastapi import Cookie, FastAPI from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(ads_id: Annotated[Union[str, None], Cookie()] = None):     return {&quot;ads_id&quot;: ads_id}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Cookie, FastAPI app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(ads_id: str | None = Cookie(default=None)):     return {&quot;ads_id&quot;: ads_id}`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Cookie, FastAPI app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(ads_id: Union[str, None] = Cookie(default=None)):     return {&quot;ads_id&quot;: ads_id}`

### Declare `Cookie` parameters

Then declare the cookie parameters using the same structure as with `Path` and `Query`.

The first value is the default value, you can pass all the extra validation or annotation parameters:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Cookie, FastAPI  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(ads_id: Annotated[str | None, Cookie()] = None):     return {&quot;ads_id&quot;: ads_id}`

`from typing import Annotated, Union  from fastapi import Cookie, FastAPI  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(ads_id: Annotated[Union[str, None], Cookie()] = None):     return {&quot;ads_id&quot;: ads_id}`

`from typing import Union  from fastapi import Cookie, FastAPI from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(ads_id: Annotated[Union[str, None], Cookie()] = None):     return {&quot;ads_id&quot;: ads_id}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Cookie, FastAPI  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(ads_id: str | None = Cookie(default=None)):     return {&quot;ads_id&quot;: ads_id}`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Cookie, FastAPI  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(ads_id: Union[str, None] = Cookie(default=None)):     return {&quot;ads_id&quot;: ads_id}`

Technical Details

`Cookie` is a "sister" class of `Path` and `Query`. It also inherits from the same common `Param` class.

But remember that when you import `Query`, `Path`, `Cookie` and others from `fastapi`, those are actually functions that return special classes.

Info

To declare cookies, you need to use `Cookie`, because otherwise the parameters would be interpreted as query parameters.

### Recap

Declare cookies with `Cookie`, using the same common pattern as `Query` and `Path`.




Up to now, you have been using common data types, like:

- `int`
- `float`
- `str`
- `bool`

But you can also use more complex data types.

And you will still have the same features as seen up to now:

- Great editor support.
- Data conversion from incoming requests.
- Data conversion for response data.
- Data validation.
- Automatic annotation and documentation.

### Other data types

Here are some of the additional data types you can use:

- `UUID`:
  - A standard "Universally Unique Identifier", common as an ID in many databases and systems.
  - In requests and responses will be represented as a `str`.
- `datetime.datetime`:
  - A Python `datetime.datetime`.
  - In requests and responses will be represented as a `str` in ISO 8601 format, like: `2008-09-15T15:53:00+05:00`.
- `datetime.date`:
  - Python `datetime.date`.
  - In requests and responses will be represented as a `str` in ISO 8601 format, like: `2008-09-15`.
- `datetime.time`:
  - A Python `datetime.time`.
  - In requests and responses will be represented as a `str` in ISO 8601 format, like: `14:23:55.003`.
- `datetime.timedelta`:
  - A Python `datetime.timedelta`.
  - In requests and responses will be represented as a `float` of total seconds.
  - Pydantic also allows representing it as a "ISO 8601 time diff encoding", see the docs for more info.
- `frozenset`:
  - In requests and responses, treated the same as a `set`:
    - In requests, a list will be read, eliminating duplicates and converting it to a `set`.
    - In responses, the `set` will be converted to a `list`.
    - The generated schema will specify that the `set` values are unique (using JSON Schema's `uniqueItems`).
- `bytes`:
  - Standard Python `bytes`.
  - In requests and responses will be treated as `str`.
  - The generated schema will specify that it's a `str` with `binary` "format".
- `Decimal`:
  - Standard Python `Decimal`.
  - In requests and responses, handled the same as a `float`.
- You can check all the valid pydantic data types here: Pydantic data types.

### Example

Here's an example *path operation* with parameters using some of the above types.

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, time, timedelta from typing import Annotated from uuid import UUID from fastapi import Body, FastAPI  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def read_items(     item_id: UUID,    start_datetime: Annotated[datetime | None, Body()] = None,    end_datetime: Annotated[datetime | None, Body()] = None,    repeat_at: Annotated[time | None, Body()] = None,    process_after: Annotated[timedelta | None, Body()] = None, ):     start_process = start_datetime + process_after     duration = end_datetime - start_process     return {         &quot;item_id&quot;: item_id,         &quot;start_datetime&quot;: start_datetime,         &quot;end_datetime&quot;: end_datetime,         &quot;repeat_at&quot;: repeat_at,         &quot;process_after&quot;: process_after,         &quot;start_process&quot;: start_process,         &quot;duration&quot;: duration,     }`

`from datetime import datetime, time, timedelta from typing import Annotated, Union from uuid import UUID from fastapi import Body, FastAPI  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def read_items(     item_id: UUID,    start_datetime: Annotated[Union[datetime, None], Body()] = None,    end_datetime: Annotated[Union[datetime, None], Body()] = None,    repeat_at: Annotated[Union[time, None], Body()] = None,    process_after: Annotated[Union[timedelta, None], Body()] = None, ):     start_process = start_datetime + process_after     duration = end_datetime - start_process     return {         &quot;item_id&quot;: item_id,         &quot;start_datetime&quot;: start_datetime,         &quot;end_datetime&quot;: end_datetime,         &quot;repeat_at&quot;: repeat_at,         &quot;process_after&quot;: process_after,         &quot;start_process&quot;: start_process,         &quot;duration&quot;: duration,     }`

`from datetime import datetime, time, timedelta from typing import Union from uuid import UUID from fastapi import Body, FastAPI from typing_extensions import Annotated  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def read_items(     item_id: UUID,    start_datetime: Annotated[Union[datetime, None], Body()] = None,    end_datetime: Annotated[Union[datetime, None], Body()] = None,    repeat_at: Annotated[Union[time, None], Body()] = None,    process_after: Annotated[Union[timedelta, None], Body()] = None, ):     start_process = start_datetime + process_after     duration = end_datetime - start_process     return {         &quot;item_id&quot;: item_id,         &quot;start_datetime&quot;: start_datetime,         &quot;end_datetime&quot;: end_datetime,         &quot;repeat_at&quot;: repeat_at,         &quot;process_after&quot;: process_after,         &quot;start_process&quot;: start_process,         &quot;duration&quot;: duration,     }`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, time, timedelta from uuid import UUID from fastapi import Body, FastAPI  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def read_items(     item_id: UUID,    start_datetime: datetime | None = Body(default=None),    end_datetime: datetime | None = Body(default=None),    repeat_at: time | None = Body(default=None),    process_after: timedelta | None = Body(default=None), ):     start_process = start_datetime + process_after     duration = end_datetime - start_process     return {         &quot;item_id&quot;: item_id,         &quot;start_datetime&quot;: start_datetime,         &quot;end_datetime&quot;: end_datetime,         &quot;repeat_at&quot;: repeat_at,         &quot;process_after&quot;: process_after,         &quot;start_process&quot;: start_process,         &quot;duration&quot;: duration,     }`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, time, timedelta from typing import Union from uuid import UUID  from fastapi import Body, FastAPI  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def read_items(     item_id: UUID,    start_datetime: Union[datetime, None] = Body(default=None),    end_datetime: Union[datetime, None] = Body(default=None),    repeat_at: Union[time, None] = Body(default=None),    process_after: Union[timedelta, None] = Body(default=None), ):     start_process = start_datetime + process_after     duration = end_datetime - start_process     return {         &quot;item_id&quot;: item_id,         &quot;start_datetime&quot;: start_datetime,         &quot;end_datetime&quot;: end_datetime,         &quot;repeat_at&quot;: repeat_at,         &quot;process_after&quot;: process_after,         &quot;start_process&quot;: start_process,         &quot;duration&quot;: duration,     }`

Note that the parameters inside the function have their natural data type, and you can, for example, perform normal date manipulations, like:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, time, timedelta from typing import Annotated from uuid import UUID  from fastapi import Body, FastAPI  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def read_items(     item_id: UUID,     start_datetime: Annotated[datetime | None, Body()] = None,     end_datetime: Annotated[datetime | None, Body()] = None,     repeat_at: Annotated[time | None, Body()] = None,     process_after: Annotated[timedelta | None, Body()] = None, ):     start_process = start_datetime + process_after    duration = end_datetime - start_process    return {         &quot;item_id&quot;: item_id,         &quot;start_datetime&quot;: start_datetime,         &quot;end_datetime&quot;: end_datetime,         &quot;repeat_at&quot;: repeat_at,         &quot;process_after&quot;: process_after,         &quot;start_process&quot;: start_process,         &quot;duration&quot;: duration,     }`

`from datetime import datetime, time, timedelta from typing import Annotated, Union from uuid import UUID  from fastapi import Body, FastAPI  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def read_items(     item_id: UUID,     start_datetime: Annotated[Union[datetime, None], Body()] = None,     end_datetime: Annotated[Union[datetime, None], Body()] = None,     repeat_at: Annotated[Union[time, None], Body()] = None,     process_after: Annotated[Union[timedelta, None], Body()] = None, ):     start_process = start_datetime + process_after    duration = end_datetime - start_process    return {         &quot;item_id&quot;: item_id,         &quot;start_datetime&quot;: start_datetime,         &quot;end_datetime&quot;: end_datetime,         &quot;repeat_at&quot;: repeat_at,         &quot;process_after&quot;: process_after,         &quot;start_process&quot;: start_process,         &quot;duration&quot;: duration,     }`

`from datetime import datetime, time, timedelta from typing import Union from uuid import UUID  from fastapi import Body, FastAPI from typing_extensions import Annotated  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def read_items(     item_id: UUID,     start_datetime: Annotated[Union[datetime, None], Body()] = None,     end_datetime: Annotated[Union[datetime, None], Body()] = None,     repeat_at: Annotated[Union[time, None], Body()] = None,     process_after: Annotated[Union[timedelta, None], Body()] = None, ):     start_process = start_datetime + process_after    duration = end_datetime - start_process    return {         &quot;item_id&quot;: item_id,         &quot;start_datetime&quot;: start_datetime,         &quot;end_datetime&quot;: end_datetime,         &quot;repeat_at&quot;: repeat_at,         &quot;process_after&quot;: process_after,         &quot;start_process&quot;: start_process,         &quot;duration&quot;: duration,     }`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, time, timedelta from uuid import UUID  from fastapi import Body, FastAPI  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def read_items(     item_id: UUID,     start_datetime: datetime | None = Body(default=None),     end_datetime: datetime | None = Body(default=None),     repeat_at: time | None = Body(default=None),     process_after: timedelta | None = Body(default=None), ):     start_process = start_datetime + process_after    duration = end_datetime - start_process    return {         &quot;item_id&quot;: item_id,         &quot;start_datetime&quot;: start_datetime,         &quot;end_datetime&quot;: end_datetime,         &quot;repeat_at&quot;: repeat_at,         &quot;process_after&quot;: process_after,         &quot;start_process&quot;: start_process,         &quot;duration&quot;: duration,     }`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, time, timedelta from typing import Union from uuid import UUID  from fastapi import Body, FastAPI  app = FastAPI()  @app.put(&quot;/items/{item_id}&quot;) async def read_items(     item_id: UUID,     start_datetime: Union[datetime, None] = Body(default=None),     end_datetime: Union[datetime, None] = Body(default=None),     repeat_at: Union[time, None] = Body(default=None),     process_after: Union[timedelta, None] = Body(default=None), ):     start_process = start_datetime + process_after    duration = end_datetime - start_process    return {         &quot;item_id&quot;: item_id,         &quot;start_datetime&quot;: start_datetime,         &quot;end_datetime&quot;: end_datetime,         &quot;repeat_at&quot;: repeat_at,         &quot;process_after&quot;: process_after,         &quot;start_process&quot;: start_process,         &quot;duration&quot;: duration,     }`




You can define Header parameters the same way you define `Query`, `Path` and `Cookie` parameters.

First import `Header`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Header app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(user_agent: Annotated[str | None, Header()] = None):     return {&quot;User-Agent&quot;: user_agent}`

`from typing import Annotated, Union  from fastapi import FastAPI, Header app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(user_agent: Annotated[Union[str, None], Header()] = None):     return {&quot;User-Agent&quot;: user_agent}`

`from typing import Union  from fastapi import FastAPI, Header from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(user_agent: Annotated[Union[str, None], Header()] = None):     return {&quot;User-Agent&quot;: user_agent}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Header app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(user_agent: str | None = Header(default=None)):     return {&quot;User-Agent&quot;: user_agent}`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Header app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(user_agent: Union[str, None] = Header(default=None)):     return {&quot;User-Agent&quot;: user_agent}`

Then declare the header parameters using the same structure as with `Path`, `Query` and `Cookie`.

The first value is the default value, you can pass all the extra validation or annotation parameters:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Header  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(user_agent: Annotated[str | None, Header()] = None):     return {&quot;User-Agent&quot;: user_agent}`

`from typing import Annotated, Union  from fastapi import FastAPI, Header  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(user_agent: Annotated[Union[str, None], Header()] = None):     return {&quot;User-Agent&quot;: user_agent}`

`from typing import Union  from fastapi import FastAPI, Header from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(user_agent: Annotated[Union[str, None], Header()] = None):     return {&quot;User-Agent&quot;: user_agent}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Header  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(user_agent: str | None = Header(default=None)):     return {&quot;User-Agent&quot;: user_agent}`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Header  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(user_agent: Union[str, None] = Header(default=None)):     return {&quot;User-Agent&quot;: user_agent}`

Technical Details

`Header` is a "sister" class of `Path`, `Query` and `Cookie`. It also inherits from the same common `Param` class.

But remember that when you import `Query`, `Path`, `Header`, and others from `fastapi`, those are actually functions that return special classes.

Info

To declare headers, you need to use `Header`, because otherwise the parameters would be interpreted as query parameters.

### Automatic conversion

`Header` has a little extra functionality on top of what `Path`, `Query` and `Cookie` provide.

Most of the standard headers are separated by a "hyphen" character, also known as the "minus symbol" (`-`).

But a variable like `user-agent` is invalid in Python.

So, by default, `Header` will convert the parameter names characters from underscore (`_`) to hyphen (`-`) to extract and document the headers.

Also, HTTP headers are case-insensitive, so, you can declare them with standard Python style (also known as "snake_case").

So, you can use `user_agent` as you normally would in Python code, instead of needing to capitalize the first letters as `User_Agent` or something similar.

If for some reason you need to disable automatic conversion of underscores to hyphens, set the parameter `convert_underscores` of `Header` to `False`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Header  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     strange_header: Annotated[str | None, Header(convert_underscores=False)] = None ):     return {&quot;strange_header&quot;: strange_header}`

`from typing import Annotated, Union  from fastapi import FastAPI, Header  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     strange_header: Annotated[         Union[str, None], Header(convert_underscores=False)    ] = None ):     return {&quot;strange_header&quot;: strange_header}`

`from typing import Union  from fastapi import FastAPI, Header from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     strange_header: Annotated[         Union[str, None], Header(convert_underscores=False)    ] = None ):     return {&quot;strange_header&quot;: strange_header}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Header  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     strange_header: str | None = Header(default=None, convert_underscores=False) ):     return {&quot;strange_header&quot;: strange_header}`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Header  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(     strange_header: Union[str, None] = Header(default=None, convert_underscores=False) ):     return {&quot;strange_header&quot;: strange_header}`

Warning

Before setting `convert_underscores` to `False`, bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores.

It is possible to receive duplicate headers. That means, the same header with multiple values.

You can define those cases using a list in the type declaration.

You will receive all the values from the duplicate header as a Python `list`.

For example, to declare a header of `X-Token` that can appear more than once, you can write:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.9+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Header  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(x_token: Annotated[list[str] | None, Header()] = None):     return {&quot;X-Token values&quot;: x_token}`

`from typing import Annotated, List, Union  from fastapi import FastAPI, Header  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(x_token: Annotated[Union[List[str], None], Header()] = None):     return {&quot;X-Token values&quot;: x_token}`

`from typing import List, Union  from fastapi import FastAPI, Header from typing_extensions import Annotated  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(x_token: Annotated[Union[List[str], None], Header()] = None):     return {&quot;X-Token values&quot;: x_token}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Header  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(x_token: list[str] | None = Header(default=None)):     return {&quot;X-Token values&quot;: x_token}`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Header  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(x_token: Union[list[str], None] = Header(default=None)):     return {&quot;X-Token values&quot;: x_token}`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import List, Union  from fastapi import FastAPI, Header  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items(x_token: Union[List[str], None] = Header(default=None)):     return {&quot;X-Token values&quot;: x_token}`

If you communicate with that *path operation* sending two HTTP headers like:

`X-Token: foo X-Token: bar`

The response would be like:

`{     &quot;X-Token values&quot;: [         &quot;bar&quot;,         &quot;foo&quot;     ] }`

### Recap

Declare headers with `Header`, using the same common pattern as `Query`, `Path` and `Cookie`.

And don't worry about underscores in your variables, **FastAPI** will take care of converting them.




The same way you can specify a response model, you can also declare the HTTP status code used for the response with the parameter `status_code` in any of the *path operations*:

- `@app.get()`
- `@app.post()`
- `@app.put()`
- `@app.delete()`
- etc.

`from fastapi import FastAPI  app = FastAPI()  @app.post(&quot;/items/&quot;, status_code=201) async def create_item(name: str):     return {&quot;name&quot;: name}`

Note

Notice that `status_code` is a parameter of the "decorator" method (`get`, `post`, etc). Not of your *path operation function*, like all the parameters and body.

The `status_code` parameter receives a number with the HTTP status code.

Info

`status_code` can alternatively also receive an `IntEnum`, such as Python's `http.HTTPStatus`.

It will:

- Return that status code in the response.
- Document it as such in the OpenAPI schema (and so, in the user interfaces):

<image @ https://fastapi.tiangolo.com/img/tutorial/response-status-code/image01.png>

Note

Some response codes (see the next section) indicate that the response does not have a body.

FastAPI knows this, and will produce OpenAPI docs that state there is no response body.

### About HTTP status codes

Note

If you already know what HTTP status codes are, skip to the next section.

In HTTP, you send a numeric status code of 3 digits as part of the response.

These status codes have a name associated to recognize them, but the important part is the number.

In short:

- `100` and above are for "Information". You rarely use them directly. Responses with these status codes cannot have a body.
- **`200`** and above are for "Successful" responses. These are the ones you would use the most.
  - `200` is the default status code, which means everything was "OK".
  - Another example would be `201`, "Created". It is commonly used after creating a new record in the database.
  - A special case is `204`, "No Content". This response is used when there is no content to return to the client, and so the response must not have a body.
- **`300`** and above are for "Redirection". Responses with these status codes may or may not have a body, except for `304`, "Not Modified", which must not have one.
- **`400`** and above are for "Client error" responses. These are the second type you would probably use the most.
  - An example is `404`, for a "Not Found" response.
  - For generic errors from the client, you can just use `400`.
- `500` and above are for server errors. You almost never use them directly. When something goes wrong at some part in your application code, or server, it will automatically return one of these status codes.

### Shortcut to remember the names

Let's see the previous example again:

`from fastapi import FastAPI  app = FastAPI()  @app.post(&quot;/items/&quot;, status_code=201) async def create_item(name: str):     return {&quot;name&quot;: name}`

`201` is the status code for "Created".

But you don't have to memorize what each of these codes mean.

You can use the convenience variables from `fastapi.status`.

`from fastapi import FastAPI, status app = FastAPI()  @app.post(&quot;/items/&quot;, status_code=status.HTTP_201_CREATED) async def create_item(name: str):     return {&quot;name&quot;: name}`

They are just a convenience, they hold the same number, but that way you can use the editor's autocomplete to find them:

<image @ https://fastapi.tiangolo.com/img/tutorial/response-status-code/image02.png>

Technical Details

You could also use `from starlette import status`.

**FastAPI** provides the same `starlette.status` as `fastapi.status` just as a convenience for you, the developer. But it comes directly from Starlette.

### Changing the default

Later, in the Advanced User Guide, you will see how to return a different status code than the default you are declaring here.




Continuing with the previous example, it will be common to have more than one related model.

This is especially the case for user models, because:

- The **input model** needs to be able to have a password.
- The **output model** should not have a password.
- The **database model** would probably need to have a hashed password.

Danger

Never store user's plaintext passwords. Always store a "secure hash" that you can then verify.

If you don't know, you will learn what a "password hash" is in the security chapters.

### Multiple models

Here's a general idea of how the models could look like with their password fields and the places where they are used:

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserIn(BaseModel):     username: str     password: str    email: EmailStr     full_name: str | None = None  class UserOut(BaseModel):     username: str     email: EmailStr     full_name: str | None = None  class UserInDB(BaseModel):     username: str     hashed_password: str    email: EmailStr     full_name: str | None = None  def fake_password_hasher(raw_password: str):     return &quot;supersecret&quot; + raw_password  def fake_save_user(user_in: UserIn):     hashed_password = fake_password_hasher(user_in.password)    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)    print(&quot;User saved! ..not really&quot;)     return user_in_db  @app.post(&quot;/user/&quot;, response_model=UserOut) async def create_user(user_in: UserIn):     user_saved = fake_save_user(user_in)     return user_saved`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserIn(BaseModel):     username: str     password: str    email: EmailStr     full_name: Union[str, None] = None  class UserOut(BaseModel):     username: str     email: EmailStr     full_name: Union[str, None] = None  class UserInDB(BaseModel):     username: str     hashed_password: str    email: EmailStr     full_name: Union[str, None] = None  def fake_password_hasher(raw_password: str):     return &quot;supersecret&quot; + raw_password  def fake_save_user(user_in: UserIn):     hashed_password = fake_password_hasher(user_in.password)    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)    print(&quot;User saved! ..not really&quot;)     return user_in_db  @app.post(&quot;/user/&quot;, response_model=UserOut) async def create_user(user_in: UserIn):     user_saved = fake_save_user(user_in)     return user_saved`

#### About `**user_in.dict()`

##### Pydantic's `.dict()`

`user_in` is a Pydantic model of class `UserIn`.

Pydantic models have a `.dict()` method that returns a `dict` with the model's data.

So, if we create a Pydantic object `user_in` like:

`user_in = UserIn(username=&quot;john&quot;, password=&quot;secret&quot;, email=&quot;john.doe@example.com&quot;)`

and then we call:

`user_dict = user_in.dict()`

we now have a `dict` with the data in the variable `user_dict` (it's a `dict` instead of a Pydantic model object).

And if we call:

we would get a Python `dict` with:

`{     'username': 'john',     'password': 'secret',     'email': 'john.doe@example.com',     'full_name': None, }`

##### Unwrapping a `dict`

If we take a `dict` like `user_dict` and pass it to a function (or class) with `**user_dict`, Python will "unwrap" it. It will pass the keys and values of the `user_dict` directly as key-value arguments.

So, continuing with the `user_dict` from above, writing:

Would result in something equivalent to:

`UserInDB(     username=&quot;john&quot;,     password=&quot;secret&quot;,     email=&quot;john.doe@example.com&quot;,     full_name=None, )`

Or more exactly, using `user_dict` directly, with whatever contents it might have in the future:

`UserInDB(     username = user_dict[&quot;username&quot;],     password = user_dict[&quot;password&quot;],     email = user_dict[&quot;email&quot;],     full_name = user_dict[&quot;full_name&quot;], )`

##### A Pydantic model from the contents of another

As in the example above we got `user_dict` from `user_in.dict()`, this code:

`user_dict = user_in.dict() UserInDB(**user_dict)`

would be equivalent to:

`UserInDB(**user_in.dict())`

...because `user_in.dict()` is a `dict`, and then we make Python "unwrap" it by passing it to `UserInDB` prepended with `**`.

So, we get a Pydantic model from the data in another Pydantic model.

##### Unwrapping a `dict` and extra keywords

And then adding the extra keyword argument `hashed_password=hashed_password`, like in:

`UserInDB(**user_in.dict(), hashed_password=hashed_password)`

...ends up being like:

`UserInDB(     username = user_dict[&quot;username&quot;],     password = user_dict[&quot;password&quot;],     email = user_dict[&quot;email&quot;],     full_name = user_dict[&quot;full_name&quot;],     hashed_password = hashed_password, )`

Warning

The supporting additional functions are just to demo a possible flow of the data, but they of course are not providing any real security.

### Reduce duplication

Reducing code duplication is one of the core ideas in **FastAPI**.

As code duplication increments the chances of bugs, security issues, code desynchronization issues (when you update in one place but not in the others), etc.

And these models are all sharing a lot of the data and duplicating attribute names and types.

We could do better.

We can declare a `UserBase` model that serves as a base for our other models. And then we can make subclasses of that model that inherit its attributes (type declarations, validation, etc).

All the data conversion, validation, documentation, etc. will still work as normally.

That way, we can declare just the differences between the models (with plaintext `password`, with `hashed_password` and without password):

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserBase(BaseModel):     username: str     email: EmailStr     full_name: str | None = None  class UserIn(UserBase):     password: str  class UserOut(UserBase):     pass  class UserInDB(UserBase):     hashed_password: str  def fake_password_hasher(raw_password: str):     return &quot;supersecret&quot; + raw_password  def fake_save_user(user_in: UserIn):     hashed_password = fake_password_hasher(user_in.password)     user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)     print(&quot;User saved! ..not really&quot;)     return user_in_db  @app.post(&quot;/user/&quot;, response_model=UserOut) async def create_user(user_in: UserIn):     user_saved = fake_save_user(user_in)     return user_saved`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserBase(BaseModel):     username: str     email: EmailStr     full_name: Union[str, None] = None  class UserIn(UserBase):     password: str  class UserOut(UserBase):     pass  class UserInDB(UserBase):     hashed_password: str  def fake_password_hasher(raw_password: str):     return &quot;supersecret&quot; + raw_password  def fake_save_user(user_in: UserIn):     hashed_password = fake_password_hasher(user_in.password)     user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)     print(&quot;User saved! ..not really&quot;)     return user_in_db  @app.post(&quot;/user/&quot;, response_model=UserOut) async def create_user(user_in: UserIn):     user_saved = fake_save_user(user_in)     return user_saved`

### `Union` or `anyOf`

You can declare a response to be the `Union` of two types, that means, that the response would be any of the two.

It will be defined in OpenAPI with `anyOf`.

To do that, use the standard Python type hint `typing.Union`:

Note

When defining a `Union`, include the most specific type first, followed by the less specific type. In the example below, the more specific `PlaneItem` comes before `CarItem` in `Union[PlaneItem, CarItem]`.

Python 3.10+Python 3.6+

`from typing import Union from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class BaseItem(BaseModel):     description: str     type: str  class CarItem(BaseItem):     type: str = &quot;car&quot;  class PlaneItem(BaseItem):     type: str = &quot;plane&quot;    size: int  items = {     &quot;item1&quot;: {&quot;description&quot;: &quot;All my friends drive a low rider&quot;, &quot;type&quot;: &quot;car&quot;},     &quot;item2&quot;: {         &quot;description&quot;: &quot;Music is my aeroplane, it's my aeroplane&quot;,         &quot;type&quot;: &quot;plane&quot;,         &quot;size&quot;: 5,     }, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Union[PlaneItem, CarItem]) async def read_item(item_id: str):     return items[item_id]`

`from typing import Union from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class BaseItem(BaseModel):     description: str     type: str  class CarItem(BaseItem):     type: str = &quot;car&quot;  class PlaneItem(BaseItem):     type: str = &quot;plane&quot;    size: int  items = {     &quot;item1&quot;: {&quot;description&quot;: &quot;All my friends drive a low rider&quot;, &quot;type&quot;: &quot;car&quot;},     &quot;item2&quot;: {         &quot;description&quot;: &quot;Music is my aeroplane, it's my aeroplane&quot;,         &quot;type&quot;: &quot;plane&quot;,         &quot;size&quot;: 5,     }, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Union[PlaneItem, CarItem]) async def read_item(item_id: str):     return items[item_id]`

#### `Union` in Python 3.10

In this example we pass `Union[PlaneItem, CarItem]` as the value of the argument `response_model`.

Because we are passing it as a **value to an argument** instead of putting it in a **type annotation**, we have to use `Union` even in Python 3.10.

If it was in a type annotation we could have used the vertical bar, as:

`some_variable: PlaneItem | CarItem`

But if we put that in `response_model=PlaneItem | CarItem` we would get an error, because Python would try to perform an **invalid operation** between `PlaneItem` and `CarItem` instead of interpreting that as a type annotation.

### List of models

The same way, you can declare responses of lists of objects.

For that, use the standard Python `typing.List` (or just `list` in Python 3.9 and above):

Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str  items = [     {&quot;name&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;There comes my hero&quot;},     {&quot;name&quot;: &quot;Red&quot;, &quot;description&quot;: &quot;It's my aeroplane&quot;}, ]  @app.get(&quot;/items/&quot;, response_model=list[Item]) async def read_items():     return items`

`from typing import List from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str  items = [     {&quot;name&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;There comes my hero&quot;},     {&quot;name&quot;: &quot;Red&quot;, &quot;description&quot;: &quot;It's my aeroplane&quot;}, ]  @app.get(&quot;/items/&quot;, response_model=List[Item]) async def read_items():     return items`

### Response with arbitrary `dict`

You can also declare a response using a plain arbitrary `dict`, declaring just the type of the keys and values, without using a Pydantic model.

This is useful if you don't know the valid field/attribute names (that would be needed for a Pydantic model) beforehand.

In this case, you can use `typing.Dict` (or just `dict` in Python 3.9 and above):

Python 3.9+Python 3.6+

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/keyword-weights/&quot;, response_model=dict[str, float]) async def read_keyword_weights():     return {&quot;foo&quot;: 2.3, &quot;bar&quot;: 3.4}`

`from typing import Dict from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/keyword-weights/&quot;, response_model=Dict[str, float]) async def read_keyword_weights():     return {&quot;foo&quot;: 2.3, &quot;bar&quot;: 3.4}`

### Recap

Use multiple Pydantic models and inherit freely for each case.

You don't need to have a single data model per entity if that entity must be able to have different "states". As the case with the user "entity" with a state including `password`, `password_hash` and no password.




You can declare the type used for the response by annotating the *path operation function* **return type**.

You can use **type annotations** the same way you would for input data in function **parameters**, you can use Pydantic models, lists, dictionaries, scalar values like integers, booleans, etc.

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: list[str] = []  @app.post(&quot;/items/&quot;) async def create_item(item: Item) -&gt; Item:     return item  @app.get(&quot;/items/&quot;) async def read_items() -&gt; list[Item]:     return [         Item(name=&quot;Portal Gun&quot;, price=42.0),         Item(name=&quot;Plumbus&quot;, price=32.0),     ]`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: list[str] = []  @app.post(&quot;/items/&quot;) async def create_item(item: Item) -&gt; Item:     return item  @app.get(&quot;/items/&quot;) async def read_items() -&gt; list[Item]:     return [         Item(name=&quot;Portal Gun&quot;, price=42.0),         Item(name=&quot;Plumbus&quot;, price=32.0),     ]`

`from typing import List, Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: List[str] = []  @app.post(&quot;/items/&quot;) async def create_item(item: Item) -&gt; Item:     return item  @app.get(&quot;/items/&quot;) async def read_items() -&gt; List[Item]:     return [         Item(name=&quot;Portal Gun&quot;, price=42.0),         Item(name=&quot;Plumbus&quot;, price=32.0),     ]`

FastAPI will use this return type to:

- **Validate** the returned data.
  - If the data is invalid (e.g. you are missing a field), it means that *your* app code is broken, not returning what it should, and it will return a server error instead of returning incorrect data. This way you and your clients can be certain that they will receive the data and the data shape expected.
- Add a **JSON Schema** for the response, in the OpenAPI *path operation*.
  - This will be used by the **automatic docs**.
  - It will also be used by automatic client code generation tools.

But most importantly:

- It will **limit and filter** the output data to what is defined in the return type.
  - This is particularly important for **security**, we'll see more of that below.

### `response_model` Parameter

There are some cases where you need or want to return some data that is not exactly what the type declares.

For example, you could want to **return a dictionary** or a database object, but **declare it as a Pydantic model**. This way the Pydantic model would do all the data documentation, validation, etc. for the object that you returned (e.g. a dictionary or database object).

If you added the return type annotation, tools and editors would complain with a (correct) error telling you that your function is returning a type (e.g. a dict) that is different from what you declared (e.g. a Pydantic model).

In those cases, you can use the *path operation decorator* parameter `response_model` instead of the return type.

You can use the `response_model` parameter in any of the *path operations*:

- `@app.get()`
- `@app.post()`
- `@app.put()`
- `@app.delete()`
- etc.

Python 3.10+Python 3.9+Python 3.6+

`from typing import Any  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: list[str] = []  @app.post(&quot;/items/&quot;, response_model=Item) async def create_item(item: Item) -&gt; Any:     return item  @app.get(&quot;/items/&quot;, response_model=list[Item]) async def read_items() -&gt; Any:     return [        {&quot;name&quot;: &quot;Portal Gun&quot;, &quot;price&quot;: 42.0},        {&quot;name&quot;: &quot;Plumbus&quot;, &quot;price&quot;: 32.0},    ]`

`from typing import Any, Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: list[str] = []  @app.post(&quot;/items/&quot;, response_model=Item) async def create_item(item: Item) -&gt; Any:     return item  @app.get(&quot;/items/&quot;, response_model=list[Item]) async def read_items() -&gt; Any:     return [        {&quot;name&quot;: &quot;Portal Gun&quot;, &quot;price&quot;: 42.0},        {&quot;name&quot;: &quot;Plumbus&quot;, &quot;price&quot;: 32.0},    ]`

`from typing import Any, List, Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: List[str] = []  @app.post(&quot;/items/&quot;, response_model=Item) async def create_item(item: Item) -&gt; Any:     return item  @app.get(&quot;/items/&quot;, response_model=List[Item]) async def read_items() -&gt; Any:     return [        {&quot;name&quot;: &quot;Portal Gun&quot;, &quot;price&quot;: 42.0},        {&quot;name&quot;: &quot;Plumbus&quot;, &quot;price&quot;: 32.0},    ]`

Note

Notice that `response_model` is a parameter of the "decorator" method (`get`, `post`, etc). Not of your *path operation function*, like all the parameters and body.

`response_model` receives the same type you would declare for a Pydantic model field, so, it can be a Pydantic model, but it can also be, e.g. a `list` of Pydantic models, like `List[Item]`.

FastAPI will use this `response_model` to do all the data documentation, validation, etc. and also to **convert and filter the output data** to its type declaration.

Tip

If you have strict type checks in your editor, mypy, etc, you can declare the function return type as `Any`.

That way you tell the editor that you are intentionally returning anything. But FastAPI will still do the data documentation, validation, filtering, etc. with the `response_model`.

#### `response_model` Priority

If you declare both a return type and a `response_model`, the `response_model` will take priority and be used by FastAPI.

This way you can add correct type annotations to your functions even when you are returning a type different than the response model, to be used by the editor and tools like mypy. And still you can have FastAPI do the data validation, documentation, etc. using the `response_model`.

You can also use `response_model=None` to disable creating a response model for that *path operation*, you might need to do it if you are adding type annotations for things that are not valid Pydantic fields, you will see an example of that in one of the sections below.

### Return the same input data

Here we are declaring a `UserIn` model, it will contain a plaintext password:

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserIn(BaseModel):     username: str     password: str    email: EmailStr     full_name: str | None = None  # Don't do this in production! @app.post(&quot;/user/&quot;) async def create_user(user: UserIn) -&gt; UserIn:     return user`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserIn(BaseModel):     username: str     password: str    email: EmailStr     full_name: Union[str, None] = None  # Don't do this in production! @app.post(&quot;/user/&quot;) async def create_user(user: UserIn) -&gt; UserIn:     return user`

Info

To use `EmailStr`, first install `email_validator`.

E.g. `pip install email-validator` or `pip install pydantic[email]`.

And we are using this model to declare our input and the same model to declare our output:

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserIn(BaseModel):     username: str     password: str     email: EmailStr     full_name: str | None = None  # Don't do this in production! @app.post(&quot;/user/&quot;) async def create_user(user: UserIn) -&gt; UserIn:     return user`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserIn(BaseModel):     username: str     password: str     email: EmailStr     full_name: Union[str, None] = None  # Don't do this in production! @app.post(&quot;/user/&quot;) async def create_user(user: UserIn) -&gt; UserIn:     return user`

Now, whenever a browser is creating a user with a password, the API will return the same password in the response.

In this case, it might not be a problem, because it's the same user sending the password.

But if we use the same model for another *path operation*, we could be sending our user's passwords to every client.

Danger

Never store the plain password of a user or send it in a response like this, unless you know all the caveats and you know what you are doing.

### Add an output model

We can instead create an input model with the plaintext password and an output model without it:

Python 3.10+Python 3.6+

`from typing import Any  from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserIn(BaseModel):     username: str     password: str    email: EmailStr     full_name: str | None = None  class UserOut(BaseModel):     username: str     email: EmailStr     full_name: str | None = None  @app.post(&quot;/user/&quot;, response_model=UserOut) async def create_user(user: UserIn) -&gt; Any:     return user`

`from typing import Any, Union  from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserIn(BaseModel):     username: str     password: str    email: EmailStr     full_name: Union[str, None] = None  class UserOut(BaseModel):     username: str     email: EmailStr     full_name: Union[str, None] = None  @app.post(&quot;/user/&quot;, response_model=UserOut) async def create_user(user: UserIn) -&gt; Any:     return user`

Here, even though our *path operation function* is returning the same input user that contains the password:

Python 3.10+Python 3.6+

`from typing import Any  from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserIn(BaseModel):     username: str     password: str     email: EmailStr     full_name: str | None = None  class UserOut(BaseModel):     username: str     email: EmailStr     full_name: str | None = None  @app.post(&quot;/user/&quot;, response_model=UserOut) async def create_user(user: UserIn) -&gt; Any:     return user`

`from typing import Any, Union  from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserIn(BaseModel):     username: str     password: str     email: EmailStr     full_name: Union[str, None] = None  class UserOut(BaseModel):     username: str     email: EmailStr     full_name: Union[str, None] = None  @app.post(&quot;/user/&quot;, response_model=UserOut) async def create_user(user: UserIn) -&gt; Any:     return user`

...we declared the `response_model` to be our model `UserOut`, that doesn't include the password:

Python 3.10+Python 3.6+

`from typing import Any  from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserIn(BaseModel):     username: str     password: str     email: EmailStr     full_name: str | None = None  class UserOut(BaseModel):     username: str     email: EmailStr     full_name: str | None = None  @app.post(&quot;/user/&quot;, response_model=UserOut) async def create_user(user: UserIn) -&gt; Any:     return user`

`from typing import Any, Union  from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class UserIn(BaseModel):     username: str     password: str     email: EmailStr     full_name: Union[str, None] = None  class UserOut(BaseModel):     username: str     email: EmailStr     full_name: Union[str, None] = None  @app.post(&quot;/user/&quot;, response_model=UserOut) async def create_user(user: UserIn) -&gt; Any:     return user`

So, **FastAPI** will take care of filtering out all the data that is not declared in the output model (using Pydantic).

#### `response_model` or Return Type

In this case, because the two models are different, if we annotated the function return type as `UserOut`, the editor and tools would complain that we are returning an invalid type, as those are different classes.

That's why in this example we have to declare it in the `response_model` parameter.

...but continue reading below to see how to overcome that.

### Return Type and Data Filtering

Let's continue from the previous example. We wanted to **annotate the function with one type** but return something that includes **more data**.

We want FastAPI to keep **filtering** the data using the response model.

In the previous example, because the classes were different, we had to use the `response_model` parameter. But that also means that we don't get the support from the editor and tools checking the function return type.

But in most of the cases where we need to do something like this, we want the model just to **filter/remove** some of the data as in this example.

And in those cases, we can use classes and inheritance to take advantage of function **type annotations** to get better support in the editor and tools, and still get the FastAPI **data filtering**.

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class BaseUser(BaseModel):     username: str    email: EmailStr    full_name: str | None = None  class UserIn(BaseUser):     password: str  @app.post(&quot;/user/&quot;) async def create_user(user: UserIn) -&gt; BaseUser:     return user`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel, EmailStr  app = FastAPI()  class BaseUser(BaseModel):     username: str    email: EmailStr    full_name: Union[str, None] = None class UserIn(BaseUser):     password: str  @app.post(&quot;/user/&quot;) async def create_user(user: UserIn) -&gt; BaseUser:     return user`

With this, we get tooling support, from editors and mypy as this code is correct in terms of types, but we also get the data filtering from FastAPI.

How does this work? Let's check that out. 🤓

#### Type Annotations and Tooling

First let's see how editors, mypy and other tools would see this.

`BaseUser` has the base fields. Then `UserIn` inherits from `BaseUser` and adds the `password` field, so, it will include all the fields from both models.

We annotate the function return type as `BaseUser`, but we are actually returning a `UserIn` instance.

The editor, mypy, and other tools won't complain about this because, in typing terms, `UserIn` is a subclass of `BaseUser`, which means it's a *valid* type when what is expected is anything that is a `BaseUser`.

#### FastAPI Data Filtering

Now, for FastAPI, it will see the return type and make sure that what you return includes **only** the fields that are declared in the type.

FastAPI does several things internally with Pydantic to make sure that those same rules of class inheritance are not used for the returned data filtering, otherwise you could end up returning much more data than what you expected.

This way, you can get the best of both worlds: type annotations with **tooling support** and **data filtering**.

### See it in the docs

When you see the automatic docs, you can check that the input model and output model will both have their own JSON Schema:

<image @ https://fastapi.tiangolo.com/img/tutorial/response-model/image01.png>

And both models will be used for the interactive API documentation:

<image @ https://fastapi.tiangolo.com/img/tutorial/response-model/image02.png>

### Other Return Type Annotations

There might be cases where you return something that is not a valid Pydantic field and you annotate it in the function, only to get the support provided by tooling (the editor, mypy, etc).

#### Return a Response Directly

The most common case would be returning a Response directly as explained later in the advanced docs.

`from fastapi import FastAPI, Response from fastapi.responses import JSONResponse, RedirectResponse  app = FastAPI()  @app.get(&quot;/portal&quot;) async def get_portal(teleport: bool = False) -&gt; Response:     if teleport:         return RedirectResponse(url=&quot;https://www.youtube.com/watch?v=dQw4w9WgXcQ&quot;)    return JSONResponse(content={&quot;message&quot;: &quot;Here's your interdimensional portal.&quot;})`

This simple case is handled automatically by FastAPI because the return type annotation is the class (or a subclass) of `Response`.

And tools will also be happy because both `RedirectResponse` and `JSONResponse` are subclasses of `Response`, so the type annotation is correct.

#### Annotate a Response Subclass

You can also use a subclass of `Response` in the type annotation:

`from fastapi import FastAPI from fastapi.responses import RedirectResponse  app = FastAPI()  @app.get(&quot;/teleport&quot;) async def get_teleport() -&gt; RedirectResponse:     return RedirectResponse(url=&quot;https://www.youtube.com/watch?v=dQw4w9WgXcQ&quot;)`

This will also work because `RedirectResponse` is a subclass of `Response`, and FastAPI will automatically handle this simple case.

#### Invalid Return Type Annotations

But when you return some other arbitrary object that is not a valid Pydantic type (e.g. a database object) and you annotate it like that in the function, FastAPI will try to create a Pydantic response model from that type annotation, and will fail.

The same would happen if you had something like a union between different types where one or more of them are not valid Pydantic types, for example this would fail 💥:

Python 3.10+Python 3.6+

`from fastapi import FastAPI, Response from fastapi.responses import RedirectResponse  app = FastAPI()  @app.get(&quot;/portal&quot;) async def get_portal(teleport: bool = False) -&gt; Response | dict:     if teleport:         return RedirectResponse(url=&quot;https://www.youtube.com/watch?v=dQw4w9WgXcQ&quot;)     return {&quot;message&quot;: &quot;Here's your interdimensional portal.&quot;}`

`from typing import Union  from fastapi import FastAPI, Response from fastapi.responses import RedirectResponse  app = FastAPI()  @app.get(&quot;/portal&quot;) async def get_portal(teleport: bool = False) -&gt; Union[Response, dict]:     if teleport:         return RedirectResponse(url=&quot;https://www.youtube.com/watch?v=dQw4w9WgXcQ&quot;)     return {&quot;message&quot;: &quot;Here's your interdimensional portal.&quot;}`

...this fails because the type annotation is not a Pydantic type and is not just a single `Response` class or subclass, it's a union (any of the two) between a `Response` and a `dict`.

#### Disable Response Model

Continuing from the example above, you might not want to have the default data validation, documentation, filtering, etc. that is performed by FastAPI.

But you might want to still keep the return type annotation in the function to get the support from tools like editors and type checkers (e.g. mypy).

In this case, you can disable the response model generation by setting `response_model=None`:

Python 3.10+Python 3.6+

`from fastapi import FastAPI, Response from fastapi.responses import RedirectResponse  app = FastAPI()  @app.get(&quot;/portal&quot;, response_model=None) async def get_portal(teleport: bool = False) -&gt; Response | dict:     if teleport:         return RedirectResponse(url=&quot;https://www.youtube.com/watch?v=dQw4w9WgXcQ&quot;)     return {&quot;message&quot;: &quot;Here's your interdimensional portal.&quot;}`

`from typing import Union  from fastapi import FastAPI, Response from fastapi.responses import RedirectResponse  app = FastAPI()  @app.get(&quot;/portal&quot;, response_model=None) async def get_portal(teleport: bool = False) -&gt; Union[Response, dict]:     if teleport:         return RedirectResponse(url=&quot;https://www.youtube.com/watch?v=dQw4w9WgXcQ&quot;)     return {&quot;message&quot;: &quot;Here's your interdimensional portal.&quot;}`

This will make FastAPI skip the response model generation and that way you can have any return type annotations you need without it affecting your FastAPI application. 🤓

### Response Model encoding parameters

Your response model could have default values, like:

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None    price: float     tax: float = 10.5    tags: list[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item, response_model_exclude_unset=True) async def read_item(item_id: str):     return items[item_id]`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None    price: float     tax: float = 10.5    tags: list[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item, response_model_exclude_unset=True) async def read_item(item_id: str):     return items[item_id]`

`from typing import List, Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None    price: float     tax: float = 10.5    tags: List[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item, response_model_exclude_unset=True) async def read_item(item_id: str):     return items[item_id]`

- `description: Union[str, None] = None` (or `str | None = None` in Python 3.10) has a default of `None`.
- `tax: float = 10.5` has a default of `10.5`.
- `tags: List[str] = []` as a default of an empty list: `[]`.

but you might want to omit them from the result if they were not actually stored.

For example, if you have models with many optional attributes in a NoSQL database, but you don't want to send very long JSON responses full of default values.

#### Use the `response_model_exclude_unset` parameter

You can set the *path operation decorator* parameter `response_model_exclude_unset=True`:

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float = 10.5     tags: list[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item, response_model_exclude_unset=True) async def read_item(item_id: str):     return items[item_id]`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: float = 10.5     tags: list[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item, response_model_exclude_unset=True) async def read_item(item_id: str):     return items[item_id]`

`from typing import List, Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: float = 10.5     tags: List[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item, response_model_exclude_unset=True) async def read_item(item_id: str):     return items[item_id]`

and those default values won't be included in the response, only the values actually set.

So, if you send a request to that *path operation* for the item with ID `foo`, the response (not including default values) will be:

`{     &quot;name&quot;: &quot;Foo&quot;,     &quot;price&quot;: 50.2 }`

Info

You can also use:

- `response_model_exclude_defaults=True`
- `response_model_exclude_none=True`

as described in the Pydantic docs for `exclude_defaults` and `exclude_none`.

##### Data with values for fields with defaults

But if your data has values for the model's fields with default values, like the item with ID `bar`:

`{     &quot;name&quot;: &quot;Bar&quot;,     &quot;description&quot;: &quot;The bartenders&quot;,    &quot;price&quot;: 62,     &quot;tax&quot;: 20.2 }`

they will be included in the response.

##### Data with the same values as the defaults

If the data has the same values as the default ones, like the item with ID `baz`:

`{     &quot;name&quot;: &quot;Baz&quot;,     &quot;description&quot;: None,    &quot;price&quot;: 50.2,     &quot;tax&quot;: 10.5,    &quot;tags&quot;: [] }`

FastAPI is smart enough (actually, Pydantic is smart enough) to realize that, even though `description`, `tax`, and `tags` have the same values as the defaults, they were set explicitly (instead of taken from the defaults).

So, they will be included in the JSON response.

Tip

Notice that the default values can be anything, not only `None`.

They can be a list (`[]`), a `float` of `10.5`, etc.

#### `response_model_include` and `response_model_exclude`

You can also use the *path operation decorator* parameters `response_model_include` and `response_model_exclude`.

They take a `set` of `str` with the name of the attributes to include (omitting the rest) or to exclude (including the rest).

This can be used as a quick shortcut if you have only one Pydantic model and want to remove some data from the output.

Tip

But it is still recommended to use the ideas above, using multiple classes, instead of these parameters.

This is because the JSON Schema generated in your app's OpenAPI (and the docs) will still be the one for the complete model, even if you use `response_model_include` or `response_model_exclude` to omit some attributes.

This also applies to `response_model_by_alias` that works similarly.

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float = 10.5  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The Bar fighters&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {         &quot;name&quot;: &quot;Baz&quot;,         &quot;description&quot;: &quot;There goes my baz&quot;,         &quot;price&quot;: 50.2,         &quot;tax&quot;: 10.5,     }, }  @app.get(     &quot;/items/{item_id}/name&quot;,     response_model=Item,     response_model_include={&quot;name&quot;, &quot;description&quot;}, ) async def read_item_name(item_id: str):     return items[item_id]  @app.get(&quot;/items/{item_id}/public&quot;, response_model=Item, response_model_exclude={&quot;tax&quot;}) async def read_item_public_data(item_id: str):     return items[item_id]`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: float = 10.5  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The Bar fighters&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {         &quot;name&quot;: &quot;Baz&quot;,         &quot;description&quot;: &quot;There goes my baz&quot;,         &quot;price&quot;: 50.2,         &quot;tax&quot;: 10.5,     }, }  @app.get(     &quot;/items/{item_id}/name&quot;,     response_model=Item,     response_model_include={&quot;name&quot;, &quot;description&quot;}, ) async def read_item_name(item_id: str):     return items[item_id]  @app.get(&quot;/items/{item_id}/public&quot;, response_model=Item, response_model_exclude={&quot;tax&quot;}) async def read_item_public_data(item_id: str):     return items[item_id]`

Tip

The syntax `{&quot;name&quot;, &quot;description&quot;}` creates a `set` with those two values.

It is equivalent to `set([&quot;name&quot;, &quot;description&quot;])`.

##### Using `list`s instead of `set`s

If you forget to use a `set` and use a `list` or `tuple` instead, FastAPI will still convert it to a `set` and it will work correctly:

Python 3.10+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float = 10.5  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The Bar fighters&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {         &quot;name&quot;: &quot;Baz&quot;,         &quot;description&quot;: &quot;There goes my baz&quot;,         &quot;price&quot;: 50.2,         &quot;tax&quot;: 10.5,     }, }  @app.get(     &quot;/items/{item_id}/name&quot;,     response_model=Item,     response_model_include=[&quot;name&quot;, &quot;description&quot;], ) async def read_item_name(item_id: str):     return items[item_id]  @app.get(&quot;/items/{item_id}/public&quot;, response_model=Item, response_model_exclude=[&quot;tax&quot;]) async def read_item_public_data(item_id: str):     return items[item_id]`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: float = 10.5  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The Bar fighters&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {         &quot;name&quot;: &quot;Baz&quot;,         &quot;description&quot;: &quot;There goes my baz&quot;,         &quot;price&quot;: 50.2,         &quot;tax&quot;: 10.5,     }, }  @app.get(     &quot;/items/{item_id}/name&quot;,     response_model=Item,     response_model_include=[&quot;name&quot;, &quot;description&quot;], ) async def read_item_name(item_id: str):     return items[item_id]  @app.get(&quot;/items/{item_id}/public&quot;, response_model=Item, response_model_exclude=[&quot;tax&quot;]) async def read_item_public_data(item_id: str):     return items[item_id]`

### Recap

Use the *path operation decorator's* parameter `response_model` to define response models and especially to ensure private data is filtered out.

Use `response_model_exclude_unset` to return only the values explicitly set.




When you need to receive form fields instead of JSON, you can use `Form`.

Info

To use forms, first install `python-multipart`.

E.g. `pip install python-multipart`.

### Import `Form`

Import `Form` from `fastapi`:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Form app = FastAPI()  @app.post(&quot;/login/&quot;) async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):     return {&quot;username&quot;: username}`

`from fastapi import FastAPI, Form from typing_extensions import Annotated  app = FastAPI()  @app.post(&quot;/login/&quot;) async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):     return {&quot;username&quot;: username}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Form app = FastAPI()  @app.post(&quot;/login/&quot;) async def login(username: str = Form(), password: str = Form()):     return {&quot;username&quot;: username}`

### Define `Form` parameters

Create form parameters the same way you would for `Body` or `Query`:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Form  app = FastAPI()  @app.post(&quot;/login/&quot;) async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):     return {&quot;username&quot;: username}`

`from fastapi import FastAPI, Form from typing_extensions import Annotated  app = FastAPI()  @app.post(&quot;/login/&quot;) async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):     return {&quot;username&quot;: username}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Form  app = FastAPI()  @app.post(&quot;/login/&quot;) async def login(username: str = Form(), password: str = Form()):     return {&quot;username&quot;: username}`

For example, in one of the ways the OAuth2 specification can be used (called "password flow") it is required to send a `username` and `password` as form fields.

The spec requires the fields to be exactly named `username` and `password`, and to be sent as form fields, not JSON.

With `Form` you can declare the same configurations as with `Body` (and `Query`, `Path`, `Cookie`), including validation, examples, an alias (e.g. `user-name` instead of `username`), etc.

Info

`Form` is a class that inherits directly from `Body`.

Tip

To declare form bodies, you need to use `Form` explicitly, because without it the parameters would be interpreted as query parameters or body (JSON) parameters.

### About "Form Fields"

The way HTML forms (`&lt;form&gt;&lt;/form&gt;`) sends the data to the server normally uses a "special" encoding for that data, it's different from JSON.

**FastAPI** will make sure to read that data from the right place instead of JSON.

Technical Details

Data from forms is normally encoded using the "media type" `application/x-www-form-urlencoded`.

But when the form includes files, it is encoded as `multipart/form-data`. You'll read about handling files in the next chapter.

If you want to read more about these encodings and form fields, head to the MDN web docs for `POST`.

Warning

You can declare multiple `Form` parameters in a *path operation*, but you can't also declare `Body` fields that you expect to receive as JSON, as the request will have the body encoded using `application/x-www-form-urlencoded` instead of `application/json`.

This is not a limitation of **FastAPI**, it's part of the HTTP protocol.

### Recap

Use `Form` to declare form data input parameters.




You can define files to be uploaded by the client using `File`.

Info

To receive uploaded files, first install `python-multipart`.

E.g. `pip install python-multipart`.

This is because uploaded files are sent as "form data".

### Import `File`

Import `File` and `UploadFile` from `fastapi`:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, File, UploadFile app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: Annotated[bytes, File()]):     return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: UploadFile):     return {&quot;filename&quot;: file.filename}`

`from fastapi import FastAPI, File, UploadFile from typing_extensions import Annotated  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: Annotated[bytes, File()]):     return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: UploadFile):     return {&quot;filename&quot;: file.filename}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, File, UploadFile app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: bytes = File()):     return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: UploadFile):     return {&quot;filename&quot;: file.filename}`

### Define `File` Parameters

Create file parameters the same way you would for `Body` or `Form`:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, File, UploadFile  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: Annotated[bytes, File()]):     return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: UploadFile):     return {&quot;filename&quot;: file.filename}`

`from fastapi import FastAPI, File, UploadFile from typing_extensions import Annotated  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: Annotated[bytes, File()]):     return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: UploadFile):     return {&quot;filename&quot;: file.filename}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, File, UploadFile  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: bytes = File()):     return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: UploadFile):     return {&quot;filename&quot;: file.filename}`

Info

`File` is a class that inherits directly from `Form`.

But remember that when you import `Query`, `Path`, `File` and others from `fastapi`, those are actually functions that return special classes.

Tip

To declare File bodies, you need to use `File`, because otherwise the parameters would be interpreted as query parameters or body (JSON) parameters.

The files will be uploaded as "form data".

If you declare the type of your *path operation function* parameter as `bytes`, **FastAPI** will read the file for you and you will receive the contents as `bytes`.

Have in mind that this means that the whole contents will be stored in memory. This will work well for small files.

But there are several cases in which you might benefit from using `UploadFile`.

### File Parameters with `UploadFile`

Define a file parameter with a type of `UploadFile`:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, File, UploadFile  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: Annotated[bytes, File()]):     return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: UploadFile):     return {&quot;filename&quot;: file.filename}`

`from fastapi import FastAPI, File, UploadFile from typing_extensions import Annotated  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: Annotated[bytes, File()]):     return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: UploadFile):     return {&quot;filename&quot;: file.filename}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, File, UploadFile  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: bytes = File()):     return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: UploadFile):     return {&quot;filename&quot;: file.filename}`

Using `UploadFile` has several advantages over `bytes`:

- You don't have to use `File()` in the default value of the parameter.
- It uses a "spooled" file:
  - A file stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk.
- This means that it will work well for large files like images, videos, large binaries, etc. without consuming all the memory.
- You can get metadata from the uploaded file.
- It has a file-like `async` interface.
- It exposes an actual Python `SpooledTemporaryFile` object that you can pass directly to other libraries that expect a file-like object.

#### `UploadFile`

`UploadFile` has the following attributes:

- `filename`: A `str` with the original file name that was uploaded (e.g. `myimage.jpg`).
- `content_type`: A `str` with the content type (MIME type / media type) (e.g. `image/jpeg`).
- `file`: A `SpooledTemporaryFile` (a file-like object). This is the actual Python file that you can pass directly to other functions or libraries that expect a "file-like" object.

`UploadFile` has the following `async` methods. They all call the corresponding file methods underneath (using the internal `SpooledTemporaryFile`).

- `write(data)`: Writes `data` (`str` or `bytes`) to the file.
- `read(size)`: Reads `size` (`int`) bytes/characters of the file.
- `seek(offset)`: Goes to the byte position `offset` (`int`) in the file.
  - E.g., `await myfile.seek(0)` would go to the start of the file.
  - This is especially useful if you run `await myfile.read()` once and then need to read the contents again.
- `close()`: Closes the file.

As all these methods are `async` methods, you need to "await" them.

For example, inside of an `async` *path operation function* you can get the contents with:

`contents = await myfile.read()`

If you are inside of a normal `def` *path operation function*, you can access the `UploadFile.file` directly, for example:

`contents = myfile.file.read()`

`async` Technical Details

When you use the `async` methods, **FastAPI** runs the file methods in a threadpool and awaits for them.

Starlette Technical Details

**FastAPI**'s `UploadFile` inherits directly from **Starlette**'s `UploadFile`, but adds some necessary parts to make it compatible with **Pydantic** and the other parts of FastAPI.

### What is "Form Data"

The way HTML forms (`&lt;form&gt;&lt;/form&gt;`) sends the data to the server normally uses a "special" encoding for that data, it's different from JSON.

**FastAPI** will make sure to read that data from the right place instead of JSON.

Technical Details

Data from forms is normally encoded using the "media type" `application/x-www-form-urlencoded` when it doesn't include files.

But when the form includes files, it is encoded as `multipart/form-data`. If you use `File`, **FastAPI** will know it has to get the files from the correct part of the body.

If you want to read more about these encodings and form fields, head to the MDN web docs for `POST`.

Warning

You can declare multiple `File` and `Form` parameters in a *path operation*, but you can't also declare `Body` fields that you expect to receive as JSON, as the request will have the body encoded using `multipart/form-data` instead of `application/json`.

This is not a limitation of **FastAPI**, it's part of the HTTP protocol.

### Optional File Upload

You can make a file optional by using standard type annotations and setting a default value of `None`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, File, UploadFile  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: Annotated[bytes | None, File()] = None):     if not file:         return {&quot;message&quot;: &quot;No file sent&quot;}     else:         return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: UploadFile | None = None):     if not file:         return {&quot;message&quot;: &quot;No upload file sent&quot;}     else:         return {&quot;filename&quot;: file.filename}`

`from typing import Annotated, Union  from fastapi import FastAPI, File, UploadFile  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: Annotated[Union[bytes, None], File()] = None):     if not file:         return {&quot;message&quot;: &quot;No file sent&quot;}     else:         return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: Union[UploadFile, None] = None):     if not file:         return {&quot;message&quot;: &quot;No upload file sent&quot;}     else:         return {&quot;filename&quot;: file.filename}`

`from typing import Union  from fastapi import FastAPI, File, UploadFile from typing_extensions import Annotated  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: Annotated[Union[bytes, None], File()] = None):     if not file:         return {&quot;message&quot;: &quot;No file sent&quot;}     else:         return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: Union[UploadFile, None] = None):     if not file:         return {&quot;message&quot;: &quot;No upload file sent&quot;}     else:         return {&quot;filename&quot;: file.filename}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, File, UploadFile  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: bytes | None = File(default=None)):     if not file:         return {&quot;message&quot;: &quot;No file sent&quot;}     else:         return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: UploadFile | None = None):     if not file:         return {&quot;message&quot;: &quot;No upload file sent&quot;}     else:         return {&quot;filename&quot;: file.filename}`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, File, UploadFile  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: Union[bytes, None] = File(default=None)):     if not file:         return {&quot;message&quot;: &quot;No file sent&quot;}     else:         return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(file: Union[UploadFile, None] = None):     if not file:         return {&quot;message&quot;: &quot;No upload file sent&quot;}     else:         return {&quot;filename&quot;: file.filename}`

You can also use `File()` with `UploadFile`, for example, to set additional metadata:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, File, UploadFile  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: Annotated[bytes, File(description=&quot;A file read as bytes&quot;)]):     return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(     file: Annotated[UploadFile, File(description=&quot;A file read as UploadFile&quot;)], ):     return {&quot;filename&quot;: file.filename}`

`from fastapi import FastAPI, File, UploadFile from typing_extensions import Annotated  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: Annotated[bytes, File(description=&quot;A file read as bytes&quot;)]):     return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(     file: Annotated[UploadFile, File(description=&quot;A file read as UploadFile&quot;)], ):     return {&quot;filename&quot;: file.filename}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, File, UploadFile  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(file: bytes = File(description=&quot;A file read as bytes&quot;)):     return {&quot;file_size&quot;: len(file)}  @app.post(&quot;/uploadfile/&quot;) async def create_upload_file(     file: UploadFile = File(description=&quot;A file read as UploadFile&quot;), ):     return {&quot;filename&quot;: file.filename}`

### Multiple File Uploads

It's possible to upload several files at the same time.

They would be associated to the same "form field" sent using "form data".

To use that, declare a list of `bytes` or `UploadFile`:

Python 3.9+Python 3.6+Python 3.9+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, File, UploadFile from fastapi.responses import HTMLResponse  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_files(files: Annotated[list[bytes], File()]):     return {&quot;file_sizes&quot;: [len(file) for file in files]}  @app.post(&quot;/uploadfiles/&quot;) async def create_upload_files(files: list[UploadFile]):     return {&quot;filenames&quot;: [file.filename for file in files]}  @app.get(&quot;/&quot;) async def main():     content = &quot;&quot;&quot; &lt;body&gt; &lt;form action=&quot;/files/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;form action=&quot;/uploadfiles/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;     &quot;&quot;&quot;     return HTMLResponse(content=content)`

`from typing import List  from fastapi import FastAPI, File, UploadFile from fastapi.responses import HTMLResponse from typing_extensions import Annotated  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_files(files: Annotated[List[bytes], File()]):     return {&quot;file_sizes&quot;: [len(file) for file in files]}  @app.post(&quot;/uploadfiles/&quot;) async def create_upload_files(files: List[UploadFile]):     return {&quot;filenames&quot;: [file.filename for file in files]}  @app.get(&quot;/&quot;) async def main():     content = &quot;&quot;&quot; &lt;body&gt; &lt;form action=&quot;/files/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;form action=&quot;/uploadfiles/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;     &quot;&quot;&quot;     return HTMLResponse(content=content)`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, File, UploadFile from fastapi.responses import HTMLResponse  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_files(files: list[bytes] = File()):     return {&quot;file_sizes&quot;: [len(file) for file in files]}  @app.post(&quot;/uploadfiles/&quot;) async def create_upload_files(files: list[UploadFile]):     return {&quot;filenames&quot;: [file.filename for file in files]}  @app.get(&quot;/&quot;) async def main():     content = &quot;&quot;&quot; &lt;body&gt; &lt;form action=&quot;/files/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;form action=&quot;/uploadfiles/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;     &quot;&quot;&quot;     return HTMLResponse(content=content)`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import List  from fastapi import FastAPI, File, UploadFile from fastapi.responses import HTMLResponse  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_files(files: List[bytes] = File()):     return {&quot;file_sizes&quot;: [len(file) for file in files]}  @app.post(&quot;/uploadfiles/&quot;) async def create_upload_files(files: List[UploadFile]):     return {&quot;filenames&quot;: [file.filename for file in files]}  @app.get(&quot;/&quot;) async def main():     content = &quot;&quot;&quot; &lt;body&gt; &lt;form action=&quot;/files/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;form action=&quot;/uploadfiles/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;     &quot;&quot;&quot;     return HTMLResponse(content=content)`

You will receive, as declared, a `list` of `bytes` or `UploadFile`s.

Technical Details

You could also use `from starlette.responses import HTMLResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

#### Multiple File Uploads with Additional Metadata

And the same way as before, you can use `File()` to set additional parameters, even for `UploadFile`:

Python 3.9+Python 3.6+Python 3.9+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, File, UploadFile from fastapi.responses import HTMLResponse  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_files(     files: Annotated[list[bytes], File(description=&quot;Multiple files as bytes&quot;)], ):     return {&quot;file_sizes&quot;: [len(file) for file in files]}  @app.post(&quot;/uploadfiles/&quot;) async def create_upload_files(     files: Annotated[        list[UploadFile], File(description=&quot;Multiple files as UploadFile&quot;)    ], ):     return {&quot;filenames&quot;: [file.filename for file in files]}  @app.get(&quot;/&quot;) async def main():     content = &quot;&quot;&quot; &lt;body&gt; &lt;form action=&quot;/files/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;form action=&quot;/uploadfiles/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;     &quot;&quot;&quot;     return HTMLResponse(content=content)`

`from typing import List  from fastapi import FastAPI, File, UploadFile from fastapi.responses import HTMLResponse from typing_extensions import Annotated  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_files(     files: Annotated[List[bytes], File(description=&quot;Multiple files as bytes&quot;)], ):     return {&quot;file_sizes&quot;: [len(file) for file in files]}  @app.post(&quot;/uploadfiles/&quot;) async def create_upload_files(     files: Annotated[        List[UploadFile], File(description=&quot;Multiple files as UploadFile&quot;)    ], ):     return {&quot;filenames&quot;: [file.filename for file in files]}  @app.get(&quot;/&quot;) async def main():     content = &quot;&quot;&quot; &lt;body&gt; &lt;form action=&quot;/files/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;form action=&quot;/uploadfiles/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;     &quot;&quot;&quot;     return HTMLResponse(content=content)`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, File, UploadFile from fastapi.responses import HTMLResponse  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_files(     files: list[bytes] = File(description=&quot;Multiple files as bytes&quot;), ):     return {&quot;file_sizes&quot;: [len(file) for file in files]}  @app.post(&quot;/uploadfiles/&quot;) async def create_upload_files(     files: list[UploadFile] = File(description=&quot;Multiple files as UploadFile&quot;), ):     return {&quot;filenames&quot;: [file.filename for file in files]}  @app.get(&quot;/&quot;) async def main():     content = &quot;&quot;&quot; &lt;body&gt; &lt;form action=&quot;/files/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;form action=&quot;/uploadfiles/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;     &quot;&quot;&quot;     return HTMLResponse(content=content)`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import List  from fastapi import FastAPI, File, UploadFile from fastapi.responses import HTMLResponse  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_files(     files: List[bytes] = File(description=&quot;Multiple files as bytes&quot;), ):     return {&quot;file_sizes&quot;: [len(file) for file in files]}  @app.post(&quot;/uploadfiles/&quot;) async def create_upload_files(     files: List[UploadFile] = File(description=&quot;Multiple files as UploadFile&quot;), ):     return {&quot;filenames&quot;: [file.filename for file in files]}  @app.get(&quot;/&quot;) async def main():     content = &quot;&quot;&quot; &lt;body&gt; &lt;form action=&quot;/files/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;form action=&quot;/uploadfiles/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;     &quot;&quot;&quot;     return HTMLResponse(content=content)`

### Recap

Use `File`, `bytes`, and `UploadFile` to declare files to be uploaded in the request, sent as form data.




You can define files and form fields at the same time using `File` and `Form`.

Info

To receive uploaded files and/or form data, first install `python-multipart`.

E.g. `pip install python-multipart`.

### Import `File` and `Form`

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, File, Form, UploadFile app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(     file: Annotated[bytes, File()],     fileb: Annotated[UploadFile, File()],     token: Annotated[str, Form()], ):     return {         &quot;file_size&quot;: len(file),         &quot;token&quot;: token,         &quot;fileb_content_type&quot;: fileb.content_type,     }`

`from fastapi import FastAPI, File, Form, UploadFile from typing_extensions import Annotated  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(     file: Annotated[bytes, File()],     fileb: Annotated[UploadFile, File()],     token: Annotated[str, Form()], ):     return {         &quot;file_size&quot;: len(file),         &quot;token&quot;: token,         &quot;fileb_content_type&quot;: fileb.content_type,     }`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, File, Form, UploadFile app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(     file: bytes = File(), fileb: UploadFile = File(), token: str = Form() ):     return {         &quot;file_size&quot;: len(file),         &quot;token&quot;: token,         &quot;fileb_content_type&quot;: fileb.content_type,     }`

### Define `File` and `Form` parameters

Create file and form parameters the same way you would for `Body` or `Query`:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, File, Form, UploadFile  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(     file: Annotated[bytes, File()],    fileb: Annotated[UploadFile, File()],    token: Annotated[str, Form()], ):     return {         &quot;file_size&quot;: len(file),         &quot;token&quot;: token,         &quot;fileb_content_type&quot;: fileb.content_type,     }`

`from fastapi import FastAPI, File, Form, UploadFile from typing_extensions import Annotated  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(     file: Annotated[bytes, File()],    fileb: Annotated[UploadFile, File()],    token: Annotated[str, Form()], ):     return {         &quot;file_size&quot;: len(file),         &quot;token&quot;: token,         &quot;fileb_content_type&quot;: fileb.content_type,     }`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, File, Form, UploadFile  app = FastAPI()  @app.post(&quot;/files/&quot;) async def create_file(     file: bytes = File(), fileb: UploadFile = File(), token: str = Form() ):     return {         &quot;file_size&quot;: len(file),         &quot;token&quot;: token,         &quot;fileb_content_type&quot;: fileb.content_type,     }`

The files and form fields will be uploaded as form data and you will receive the files and form fields.

And you can declare some of the files as `bytes` and some as `UploadFile`.

Warning

You can declare multiple `File` and `Form` parameters in a *path operation*, but you can't also declare `Body` fields that you expect to receive as JSON, as the request will have the body encoded using `multipart/form-data` instead of `application/json`.

This is not a limitation of **FastAPI**, it's part of the HTTP protocol.

### Recap

Use `File` and `Form` together when you need to receive data and files in the same request.




There are some cases where you might need to convert a data type (like a Pydantic model) to something compatible with JSON (like a `dict`, `list`, etc).

For example, if you need to store it in a database.

For that, **FastAPI** provides a `jsonable_encoder()` function.

### Using the `jsonable_encoder`

Let's imagine that you have a database `fake_db` that only receives JSON compatible data.

For example, it doesn't receive `datetime` objects, as those are not compatible with JSON.

So, a `datetime` object would have to be converted to a `str` containing the data in ISO format.

The same way, this database wouldn't receive a Pydantic model (an object with attributes), only a `dict`.

You can use `jsonable_encoder` for that.

It receives an object, like a Pydantic model, and returns a JSON compatible version:

Python 3.10+Python 3.6+

`from datetime import datetime  from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  fake_db = {}  class Item(BaseModel):     title: str     timestamp: datetime     description: str | None = None  app = FastAPI()  @app.put(&quot;/items/{id}&quot;) def update_item(id: str, item: Item):     json_compatible_item_data = jsonable_encoder(item)    fake_db[id] = json_compatible_item_data`

`from datetime import datetime from typing import Union  from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  fake_db = {}  class Item(BaseModel):     title: str     timestamp: datetime     description: Union[str, None] = None  app = FastAPI()  @app.put(&quot;/items/{id}&quot;) def update_item(id: str, item: Item):     json_compatible_item_data = jsonable_encoder(item)    fake_db[id] = json_compatible_item_data`

In this example, it would convert the Pydantic model to a `dict`, and the `datetime` to a `str`.

The result of calling it is something that can be encoded with the Python standard `json.dumps()`.

It doesn't return a large `str` containing the data in JSON format (as a string). It returns a Python standard data structure (e.g. a `dict`) with values and sub-values that are all compatible with JSON.

Note

`jsonable_encoder` is actually used by **FastAPI** internally to convert data. But it is useful in many other scenarios.




There are many situations in where you need to notify an error to a client that is using your API.

This client could be a browser with a frontend, a code from someone else, an IoT device, etc.

You could need to tell the client that:

- The client doesn't have enough privileges for that operation.
- The client doesn't have access to that resource.
- The item the client was trying to access doesn't exist.
- etc.

In these cases, you would normally return an **HTTP status code** in the range of **400** (from 400 to 499).

This is similar to the 200 HTTP status codes (from 200 to 299). Those "200" status codes mean that somehow there was a "success" in the request.

The status codes in the 400 range mean that there was an error from the client.

Remember all those **"404 Not Found"** errors (and jokes)?

### Use `HTTPException`

To return HTTP responses with errors to the client you use `HTTPException`.

#### Import `HTTPException`

`from fastapi import FastAPI, HTTPException app = FastAPI()  items = {&quot;foo&quot;: &quot;The Foo Wrestlers&quot;}  @app.get(&quot;/items/{item_id}&quot;) async def read_item(item_id: str):     if item_id not in items:         raise HTTPException(status_code=404, detail=&quot;Item not found&quot;)     return {&quot;item&quot;: items[item_id]}`

#### Raise an `HTTPException` in your code

`HTTPException` is a normal Python exception with additional data relevant for APIs.

Because it's a Python exception, you don't `return` it, you `raise` it.

This also means that if you are inside a utility function that you are calling inside of your *path operation function*, and you raise the `HTTPException` from inside of that utility function, it won't run the rest of the code in the *path operation function*, it will terminate that request right away and send the HTTP error from the `HTTPException` to the client.

The benefit of raising an exception over `return`ing a value will be more evident in the section about Dependencies and Security.

In this example, when the client requests an item by an ID that doesn't exist, raise an exception with a status code of `404`:

`from fastapi import FastAPI, HTTPException  app = FastAPI()  items = {&quot;foo&quot;: &quot;The Foo Wrestlers&quot;}  @app.get(&quot;/items/{item_id}&quot;) async def read_item(item_id: str):     if item_id not in items:         raise HTTPException(status_code=404, detail=&quot;Item not found&quot;)    return {&quot;item&quot;: items[item_id]}`

#### The resulting response

If the client requests `http://example.com/items/foo` (an `item_id` `&quot;foo&quot;`), that client will receive an HTTP status code of 200, and a JSON response of:

`{   &quot;item&quot;: &quot;The Foo Wrestlers&quot; }`

But if the client requests `http://example.com/items/bar` (a non-existent `item_id` `&quot;bar&quot;`), that client will receive an HTTP status code of 404 (the "not found" error), and a JSON response of:

`{   &quot;detail&quot;: &quot;Item not found&quot; }`

Tip

When raising an `HTTPException`, you can pass any value that can be converted to JSON as the parameter `detail`, not only `str`.

You could pass a `dict`, a `list`, etc.

They are handled automatically by **FastAPI** and converted to JSON.

There are some situations in where it's useful to be able to add custom headers to the HTTP error. For example, for some types of security.

You probably won't need to use it directly in your code.

But in case you needed it for an advanced scenario, you can add custom headers:

`from fastapi import FastAPI, HTTPException  app = FastAPI()  items = {&quot;foo&quot;: &quot;The Foo Wrestlers&quot;}  @app.get(&quot;/items-header/{item_id}&quot;) async def read_item_header(item_id: str):     if item_id not in items:         raise HTTPException(             status_code=404,             detail=&quot;Item not found&quot;,             headers={&quot;X-Error&quot;: &quot;There goes my error&quot;},        )     return {&quot;item&quot;: items[item_id]}`

### Install custom exception handlers

You can add custom exception handlers with the same exception utilities from Starlette.

Let's say you have a custom exception `UnicornException` that you (or a library you use) might `raise`.

And you want to handle this exception globally with FastAPI.

You could add a custom exception handler with `@app.exception_handler()`:

`from fastapi import FastAPI, Request from fastapi.responses import JSONResponse  class UnicornException(Exception):     def __init__(self, name: str):        self.name = name  app = FastAPI()  @app.exception_handler(UnicornException) async def unicorn_exception_handler(request: Request, exc: UnicornException):     return JSONResponse(        status_code=418,        content={&quot;message&quot;: f&quot;Oops! {exc.name} did something. There goes a rainbow...&quot;},    )  @app.get(&quot;/unicorns/{name}&quot;) async def read_unicorn(name: str):     if name == &quot;yolo&quot;:         raise UnicornException(name=name)    return {&quot;unicorn_name&quot;: name}`

Here, if you request `/unicorns/yolo`, the *path operation* will `raise` a `UnicornException`.

But it will be handled by the `unicorn_exception_handler`.

So, you will receive a clean error, with an HTTP status code of `418` and a JSON content of:

`{&quot;message&quot;: &quot;Oops! yolo did something. There goes a rainbow...&quot;}`

Technical Details

You could also use `from starlette.requests import Request` and `from starlette.responses import JSONResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with `Request`.

### Override the default exception handlers

**FastAPI** has some default exception handlers.

These handlers are in charge of returning the default JSON responses when you `raise` an `HTTPException` and when the request has invalid data.

You can override these exception handlers with your own.

#### Override request validation exceptions

When a request contains invalid data, **FastAPI** internally raises a `RequestValidationError`.

And it also includes a default exception handler for it.

To override it, import the `RequestValidationError` and use it with `@app.exception_handler(RequestValidationError)` to decorate the exception handler.

The exception handler will receive a `Request` and the exception.

`from fastapi import FastAPI, HTTPException from fastapi.exceptions import RequestValidationError from fastapi.responses import PlainTextResponse from starlette.exceptions import HTTPException as StarletteHTTPException  app = FastAPI()  @app.exception_handler(StarletteHTTPException) async def http_exception_handler(request, exc):     return PlainTextResponse(str(exc.detail), status_code=exc.status_code)  @app.exception_handler(RequestValidationError) async def validation_exception_handler(request, exc):     return PlainTextResponse(str(exc), status_code=400)  @app.get(&quot;/items/{item_id}&quot;) async def read_item(item_id: int):     if item_id == 3:         raise HTTPException(status_code=418, detail=&quot;Nope! I don't like 3.&quot;)     return {&quot;item_id&quot;: item_id}`

Now, if you go to `/items/foo`, instead of getting the default JSON error with:

`{     &quot;detail&quot;: [         {             &quot;loc&quot;: [                 &quot;path&quot;,                 &quot;item_id&quot;             ],             &quot;msg&quot;: &quot;value is not a valid integer&quot;,             &quot;type&quot;: &quot;type_error.integer&quot;         }     ] }`

you will get a text version, with:

`1 validation error path -&gt; item_id   value is not a valid integer (type=type_error.integer)`

##### `RequestValidationError` vs `ValidationError`

Warning

These are technical details that you might skip if it's not important for you now.

`RequestValidationError` is a sub-class of Pydantic's `ValidationError`.

**FastAPI** uses it so that, if you use a Pydantic model in `response_model`, and your data has an error, you will see the error in your log.

But the client/user will not see it. Instead, the client will receive an "Internal Server Error" with a HTTP status code `500`.

It should be this way because if you have a Pydantic `ValidationError` in your *response* or anywhere in your code (not in the client's *request*), it's actually a bug in your code.

And while you fix it, your clients/users shouldn't have access to internal information about the error, as that could expose a security vulnerability.

#### Override the `HTTPException` error handler

The same way, you can override the `HTTPException` handler.

For example, you could want to return a plain text response instead of JSON for these errors:

`from fastapi import FastAPI, HTTPException from fastapi.exceptions import RequestValidationError from fastapi.responses import PlainTextResponse from starlette.exceptions import HTTPException as StarletteHTTPException app = FastAPI()  @app.exception_handler(StarletteHTTPException) async def http_exception_handler(request, exc):     return PlainTextResponse(str(exc.detail), status_code=exc.status_code)  @app.exception_handler(RequestValidationError) async def validation_exception_handler(request, exc):     return PlainTextResponse(str(exc), status_code=400)  @app.get(&quot;/items/{item_id}&quot;) async def read_item(item_id: int):     if item_id == 3:         raise HTTPException(status_code=418, detail=&quot;Nope! I don't like 3.&quot;)    return {&quot;item_id&quot;: item_id}`

Technical Details

You could also use `from starlette.responses import PlainTextResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

#### Use the `RequestValidationError` body

The `RequestValidationError` contains the `body` it received with invalid data.

You could use it while developing your app to log the body and debug it, return it to the user, etc.

`from fastapi import FastAPI, Request, status from fastapi.encoders import jsonable_encoder from fastapi.exceptions import RequestValidationError from fastapi.responses import JSONResponse from pydantic import BaseModel  app = FastAPI()  @app.exception_handler(RequestValidationError) async def validation_exception_handler(request: Request, exc: RequestValidationError):     return JSONResponse(         status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,         content=jsonable_encoder({&quot;detail&quot;: exc.errors(), &quot;body&quot;: exc.body}),    )  class Item(BaseModel):     title: str     size: int  @app.post(&quot;/items/&quot;) async def create_item(item: Item):     return item`

Now try sending an invalid item like:

`{   &quot;title&quot;: &quot;towel&quot;,   &quot;size&quot;: &quot;XL&quot; }`

You will receive a response telling you that the data is invalid containing the received body:

`{   &quot;detail&quot;: [     {       &quot;loc&quot;: [         &quot;body&quot;,         &quot;size&quot;       ],       &quot;msg&quot;: &quot;value is not a valid integer&quot;,       &quot;type&quot;: &quot;type_error.integer&quot;     }   ],   &quot;body&quot;: {    &quot;title&quot;: &quot;towel&quot;,    &quot;size&quot;: &quot;XL&quot;  } }`

##### FastAPI's `HTTPException` vs Starlette's `HTTPException`

**FastAPI** has its own `HTTPException`.

And **FastAPI**'s `HTTPException` error class inherits from Starlette's `HTTPException` error class.

The only difference, is that **FastAPI**'s `HTTPException` allows you to add headers to be included in the response.

This is needed/used internally for OAuth 2.0 and some security utilities.

So, you can keep raising **FastAPI**'s `HTTPException` as normally in your code.

But when you register an exception handler, you should register it for Starlette's `HTTPException`.

This way, if any part of Starlette's internal code, or a Starlette extension or plug-in, raises a Starlette `HTTPException`, your handler will be able to catch and handle it.

In this example, to be able to have both `HTTPException`s in the same code, Starlette's exceptions is renamed to `StarletteHTTPException`:

`from starlette.exceptions import HTTPException as StarletteHTTPException`

#### Re-use **FastAPI**'s exception handlers

If you want to use the exception along with the same default exception handlers from **FastAPI**, You can import and re-use the default exception handlers from `fastapi.exception_handlers`:

`from fastapi import FastAPI, HTTPException from fastapi.exception_handlers import (     http_exception_handler,    request_validation_exception_handler, ) from fastapi.exceptions import RequestValidationError from starlette.exceptions import HTTPException as StarletteHTTPException  app = FastAPI()  @app.exception_handler(StarletteHTTPException) async def custom_http_exception_handler(request, exc):     print(f&quot;OMG! An HTTP error!: {repr(exc)}&quot;)     return await http_exception_handler(request, exc)  @app.exception_handler(RequestValidationError) async def validation_exception_handler(request, exc):     print(f&quot;OMG! The client sent invalid data!: {exc}&quot;)     return await request_validation_exception_handler(request, exc)  @app.get(&quot;/items/{item_id}&quot;) async def read_item(item_id: int):     if item_id == 3:         raise HTTPException(status_code=418, detail=&quot;Nope! I don't like 3.&quot;)     return {&quot;item_id&quot;: item_id}`

In this example you are just `print`ing the error with a very expressive message, but you get the idea. You can use the exception and then just re-use the default exception handlers.




There are several parameters that you can pass to your *path operation decorator* to configure it.

Warning

Notice that these parameters are passed directly to the *path operation decorator*, not to your *path operation function*.

### Response Status Code

You can define the (HTTP) `status_code` to be used in the response of your *path operation*.

You can pass directly the `int` code, like `404`.

But if you don't remember what each number code is for, you can use the shortcut constants in `status`:

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI, status from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: set[str] = set()  @app.post(&quot;/items/&quot;, response_model=Item, status_code=status.HTTP_201_CREATED) async def create_item(item: Item):     return item`

`from typing import Union  from fastapi import FastAPI, status from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: set[str] = set()  @app.post(&quot;/items/&quot;, response_model=Item, status_code=status.HTTP_201_CREATED) async def create_item(item: Item):     return item`

`from typing import Set, Union  from fastapi import FastAPI, status from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: Set[str] = set()  @app.post(&quot;/items/&quot;, response_model=Item, status_code=status.HTTP_201_CREATED) async def create_item(item: Item):     return item`

That status code will be used in the response and will be added to the OpenAPI schema.

Technical Details

You could also use `from starlette import status`.

**FastAPI** provides the same `starlette.status` as `fastapi.status` just as a convenience for you, the developer. But it comes directly from Starlette.

You can add tags to your *path operation*, pass the parameter `tags` with a `list` of `str` (commonly just one `str`):

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: set[str] = set()  @app.post(&quot;/items/&quot;, response_model=Item, tags=[&quot;items&quot;]) async def create_item(item: Item):     return item  @app.get(&quot;/items/&quot;, tags=[&quot;items&quot;]) async def read_items():     return [{&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 42}]  @app.get(&quot;/users/&quot;, tags=[&quot;users&quot;]) async def read_users():     return [{&quot;username&quot;: &quot;johndoe&quot;}]`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: set[str] = set()  @app.post(&quot;/items/&quot;, response_model=Item, tags=[&quot;items&quot;]) async def create_item(item: Item):     return item  @app.get(&quot;/items/&quot;, tags=[&quot;items&quot;]) async def read_items():     return [{&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 42}]  @app.get(&quot;/users/&quot;, tags=[&quot;users&quot;]) async def read_users():     return [{&quot;username&quot;: &quot;johndoe&quot;}]`

`from typing import Set, Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: Set[str] = set()  @app.post(&quot;/items/&quot;, response_model=Item, tags=[&quot;items&quot;]) async def create_item(item: Item):     return item  @app.get(&quot;/items/&quot;, tags=[&quot;items&quot;]) async def read_items():     return [{&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 42}]  @app.get(&quot;/users/&quot;, tags=[&quot;users&quot;]) async def read_users():     return [{&quot;username&quot;: &quot;johndoe&quot;}]`

They will be added to the OpenAPI schema and used by the automatic documentation interfaces:

<image @ https://fastapi.tiangolo.com/img/tutorial/path-operation-configuration/image01.png>

#### Tags with Enums

If you have a big application, you might end up accumulating **several tags**, and you would want to make sure you always use the **same tag** for related *path operations*.

In these cases, it could make sense to store the tags in an `Enum`.

**FastAPI** supports that the same way as with plain strings:

`from enum import Enum from fastapi import FastAPI  app = FastAPI()  class Tags(Enum):     items = &quot;items&quot;    users = &quot;users&quot;  @app.get(&quot;/items/&quot;, tags=[Tags.items]) async def get_items():     return [&quot;Portal gun&quot;, &quot;Plumbus&quot;]  @app.get(&quot;/users/&quot;, tags=[Tags.users]) async def read_users():     return [&quot;Rick&quot;, &quot;Morty&quot;]`

### Summary and description

You can add a `summary` and `description`:

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: set[str] = set()  @app.post(     &quot;/items/&quot;,     response_model=Item,     summary=&quot;Create an item&quot;,    description=&quot;Create an item with all the information, name, description, price, tax and a set of unique tags&quot;, ) async def create_item(item: Item):     return item`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: set[str] = set()  @app.post(     &quot;/items/&quot;,     response_model=Item,     summary=&quot;Create an item&quot;,    description=&quot;Create an item with all the information, name, description, price, tax and a set of unique tags&quot;, ) async def create_item(item: Item):     return item`

`from typing import Set, Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: Set[str] = set()  @app.post(     &quot;/items/&quot;,     response_model=Item,     summary=&quot;Create an item&quot;,    description=&quot;Create an item with all the information, name, description, price, tax and a set of unique tags&quot;, ) async def create_item(item: Item):     return item`

### Description from docstring

As descriptions tend to be long and cover multiple lines, you can declare the *path operation* description in the function docstring and **FastAPI** will read it from there.

You can write Markdown in the docstring, it will be interpreted and displayed correctly (taking into account docstring indentation).

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: set[str] = set()  @app.post(&quot;/items/&quot;, response_model=Item, summary=&quot;Create an item&quot;) async def create_item(item: Item):     &quot;&quot;&quot;    Create an item with all the information:     - **name**: each item must have a name    - **description**: a long description    - **price**: required    - **tax**: if the item doesn't have tax, you can omit this    - **tags**: a set of unique tag strings for this item    &quot;&quot;&quot;    return item`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: set[str] = set()  @app.post(&quot;/items/&quot;, response_model=Item, summary=&quot;Create an item&quot;) async def create_item(item: Item):     &quot;&quot;&quot;    Create an item with all the information:     - **name**: each item must have a name    - **description**: a long description    - **price**: required    - **tax**: if the item doesn't have tax, you can omit this    - **tags**: a set of unique tag strings for this item    &quot;&quot;&quot;    return item`

`from typing import Set, Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: Set[str] = set()  @app.post(&quot;/items/&quot;, response_model=Item, summary=&quot;Create an item&quot;) async def create_item(item: Item):     &quot;&quot;&quot;    Create an item with all the information:     - **name**: each item must have a name    - **description**: a long description    - **price**: required    - **tax**: if the item doesn't have tax, you can omit this    - **tags**: a set of unique tag strings for this item    &quot;&quot;&quot;    return item`

It will be used in the interactive docs:

<image @ https://fastapi.tiangolo.com/img/tutorial/path-operation-configuration/image02.png>

### Response description

You can specify the response description with the parameter `response_description`:

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None     tags: set[str] = set()  @app.post(     &quot;/items/&quot;,     response_model=Item,     summary=&quot;Create an item&quot;,     response_description=&quot;The created item&quot;, ) async def create_item(item: Item):     &quot;&quot;&quot;     Create an item with all the information:      - **name**: each item must have a name     - **description**: a long description     - **price**: required     - **tax**: if the item doesn't have tax, you can omit this     - **tags**: a set of unique tag strings for this item     &quot;&quot;&quot;     return item`

`from typing import Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: set[str] = set()  @app.post(     &quot;/items/&quot;,     response_model=Item,     summary=&quot;Create an item&quot;,     response_description=&quot;The created item&quot;, ) async def create_item(item: Item):     &quot;&quot;&quot;     Create an item with all the information:      - **name**: each item must have a name     - **description**: a long description     - **price**: required     - **tax**: if the item doesn't have tax, you can omit this     - **tags**: a set of unique tag strings for this item     &quot;&quot;&quot;     return item`

`from typing import Set, Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: Set[str] = set()  @app.post(     &quot;/items/&quot;,     response_model=Item,     summary=&quot;Create an item&quot;,     response_description=&quot;The created item&quot;, ) async def create_item(item: Item):     &quot;&quot;&quot;     Create an item with all the information:      - **name**: each item must have a name     - **description**: a long description     - **price**: required     - **tax**: if the item doesn't have tax, you can omit this     - **tags**: a set of unique tag strings for this item     &quot;&quot;&quot;     return item`

Info

Notice that `response_description` refers specifically to the response, the `description` refers to the *path operation* in general.

Check

OpenAPI specifies that each *path operation* requires a response description.

So, if you don't provide one, **FastAPI** will automatically generate one of "Successful response".

<image @ https://fastapi.tiangolo.com/img/tutorial/path-operation-configuration/image03.png>

### Deprecate a *path operation*

If you need to mark a *path operation* as deprecated, but without removing it, pass the parameter `deprecated`:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/&quot;, tags=[&quot;items&quot;]) async def read_items():     return [{&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 42}]  @app.get(&quot;/users/&quot;, tags=[&quot;users&quot;]) async def read_users():     return [{&quot;username&quot;: &quot;johndoe&quot;}]  @app.get(&quot;/elements/&quot;, tags=[&quot;items&quot;], deprecated=True) async def read_elements():     return [{&quot;item_id&quot;: &quot;Foo&quot;}]`

It will be clearly marked as deprecated in the interactive docs:

<image @ https://fastapi.tiangolo.com/img/tutorial/path-operation-configuration/image04.png>

Check how deprecated and non-deprecated *path operations* look like:

<image @ https://fastapi.tiangolo.com/img/tutorial/path-operation-configuration/image05.png>

### Recap

You can configure and add metadata for your *path operations* easily by passing parameters to the *path operation decorators*.




**FastAPI** has a very powerful but intuitive **Dependency Injection** system.

It is designed to be very simple to use, and to make it very easy for any developer to integrate other components with **FastAPI**.

### What is "Dependency Injection"

**"Dependency Injection"** means, in programming, that there is a way for your code (in this case, your *path operation functions*) to declare things that it requires to work and use: "dependencies".

And then, that system (in this case **FastAPI**) will take care of doing whatever is needed to provide your code with those needed dependencies ("inject" the dependencies).

This is very useful when you need to:

- Have shared logic (the same code logic again and again).
- Share database connections.
- Enforce security, authentication, role requirements, etc.
- And many other things...

All these, while minimizing code repetition.

### First Steps

Let's see a very simple example. It will be so simple that it is not very useful, for now.

But this way we can focus on how the **Dependency Injection** system works.

#### Create a dependency, or "dependable"

Let's first focus on the dependency.

It is just a function that can take all the same parameters that a *path operation function* can take:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

`from typing import Union  from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: dict = Depends(common_parameters)):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: dict = Depends(common_parameters)):     return commons`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: dict = Depends(common_parameters)):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: dict = Depends(common_parameters)):     return commons`

That's it.

**2 lines**.

And it has the same shape and structure that all your *path operation functions* have.

You can think of it as a *path operation function* without the "decorator" (without the `@app.get(&quot;/some-path&quot;)`).

And it can return anything you want.

In this case, this dependency expects:

- An optional query parameter `q` that is a `str`.
- An optional query parameter `skip` that is an `int`, and by default is `0`.
- An optional query parameter `limit` that is an `int`, and by default is `100`.

And then it just returns a `dict` containing those values.

Info

FastAPI added support for `Annotated` (and started recommending it) in version 0.95.0.

If you have an older version, you would get errors when trying to use `Annotated`.

Make sure you Upgrade the FastAPI version to at least 0.95.1 before using `Annotated`.

#### Import `Depends`

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI app = FastAPI()  async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

`from typing import Union  from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI app = FastAPI()  async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: dict = Depends(common_parameters)):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: dict = Depends(common_parameters)):     return commons`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: dict = Depends(common_parameters)):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: dict = Depends(common_parameters)):     return commons`

#### Declare the dependency, in the "dependant"

The same way you use `Body`, `Query`, etc. with your *path operation function* parameters, use `Depends` with a new parameter:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

`from typing import Union  from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: dict = Depends(common_parameters)):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: dict = Depends(common_parameters)):     return commons`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: dict = Depends(common_parameters)):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: dict = Depends(common_parameters)):     return commons`

Although you use `Depends` in the parameters of your function the same way you use `Body`, `Query`, etc, `Depends` works a bit differently.

You only give `Depends` a single parameter.

This parameter must be something like a function.

You **don't call it** directly (don't add the parenthesis at the end), you just pass it as a parameter to `Depends()`.

And that function takes parameters in the same way that *path operation functions* do.

Tip

You'll see what other "things", apart from functions, can be used as dependencies in the next chapter.

Whenever a new request arrives, **FastAPI** will take care of:

- Calling your dependency ("dependable") function with the correct parameters.
- Get the result from your function.
- Assign that result to the parameter in your *path operation function*.

```
graph TB

common_parameters(["common_parameters"])
read_items["/items/"]
read_users["/users/"]

common_parameters --> read_items
common_parameters --> read_users
```

This way you write shared code once and **FastAPI** takes care of calling it for your *path operations*.

Check

Notice that you don't have to create a special class and pass it somewhere to **FastAPI** to "register" it or anything similar.

You just pass it to `Depends` and **FastAPI** knows how to do the rest.

In the examples above, you see that there's a tiny bit of **code duplication**.

When you need to use the `common_parameters()` dependency, you have to write the whole parameter with the type annotation and `Depends()`:

`commons: Annotated[dict, Depends(common_parameters)]`

But because we are using `Annotated`, we can store that `Annotated` value in a variable and use it in multiple places:

Python 3.10+Python 3.9+Python 3.6+

`from typing import Annotated  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  CommonsDep = Annotated[dict, Depends(common_parameters)]  @app.get(&quot;/items/&quot;) async def read_items(commons: CommonsDep):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: CommonsDep):     return commons`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  CommonsDep = Annotated[dict, Depends(common_parameters)]  @app.get(&quot;/items/&quot;) async def read_items(commons: CommonsDep):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: CommonsDep):     return commons`

`from typing import Union  from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  CommonsDep = Annotated[dict, Depends(common_parameters)]  @app.get(&quot;/items/&quot;) async def read_items(commons: CommonsDep):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: CommonsDep):     return commons`

Tip

This is just standard Python, it's called a "type alias", it's actually not specific to **FastAPI**.

But because **FastAPI** is based on the Python standards, including `Annotated`, you can use this trick in your code. 😎

The dependencies will keep working as expected, and the **best part** is that the **type information will be preserved**, which means that your editor will be able to keep providing you with **autocompletion**, **inline errors**, etc. The same for other tools like `mypy`.

This will be especially useful when you use it in a **large code base** where you use **the same dependencies** over and over again in **many *path operations***.

### To `async` or not to `async`

As dependencies will also be called by **FastAPI** (the same as your *path operation functions*), the same rules apply while defining your functions.

You can use `async def` or normal `def`.

And you can declare dependencies with `async def` inside of normal `def` *path operation functions*, or `def` dependencies inside of `async def` *path operation functions*, etc.

It doesn't matter. **FastAPI** will know what to do.

### Integrated with OpenAPI

All the request declarations, validations and requirements of your dependencies (and sub-dependencies) will be integrated in the same OpenAPI schema.

So, the interactive docs will have all the information from these dependencies too:

<image @ https://fastapi.tiangolo.com/img/tutorial/dependencies/image01.png>

### Simple usage

If you look at it, *path operation functions* are declared to be used whenever a *path* and *operation* matches, and then **FastAPI** takes care of calling the function with the correct parameters, extracting the data from the request.

Actually, all (or most) of the web frameworks work in this same way.

You never call those functions directly. They are called by your framework (in this case, **FastAPI**).

With the Dependency Injection system, you can also tell **FastAPI** that your *path operation function* also "depends" on something else that should be executed before your *path operation function*, and **FastAPI** will take care of executing it and "injecting" the results.

Other common terms for this same idea of "dependency injection" are:

- resources
- providers
- services
- injectables
- components

### **FastAPI** plug-ins

Integrations and "plug-in"s can be built using the **Dependency Injection** system. But in fact, there is actually **no need to create "plug-ins"**, as by using dependencies it's possible to declare an infinite number of integrations and interactions that become available to your *path operation functions*.

And dependencies can be created in a very simple and intuitive way that allow you to just import the Python packages you need, and integrate them with your API functions in a couple of lines of code, *literally*.

You will see examples of this in the next chapters, about relational and NoSQL databases, security, etc.

### **FastAPI** compatibility

The simplicity of the dependency injection system makes **FastAPI** compatible with:

- all the relational databases
- NoSQL databases
- external packages
- external APIs
- authentication and authorization systems
- API usage monitoring systems
- response data injection systems
- etc.

### Simple and Powerful

Although the hierarchical dependency injection system is very simple to define and use, it's still very powerful.

You can define dependencies that in turn can define dependencies themselves.

In the end, a hierarchical tree of dependencies is built, and the **Dependency Injection** system takes care of solving all these dependencies for you (and their sub-dependencies) and providing (injecting) the results at each step.

For example, let's say you have 4 API endpoints (*path operations*):

- `/items/public/`
- `/items/private/`
- `/users/{user_id}/activate`
- `/items/pro/`

then you could add different permission requirements for each of them just with dependencies and sub-dependencies:

```
graph TB

current_user(["current_user"])
active_user(["active_user"])
admin_user(["admin_user"])
paying_user(["paying_user"])

public["/items/public/"]
private["/items/private/"]
activate_user["/users/{user_id}/activate"]
pro_items["/items/pro/"]

current_user --> active_user
active_user --> admin_user
active_user --> paying_user

current_user --> public
active_user --> private
admin_user --> activate_user
paying_user --> pro_items
```

### Integrated with **OpenAPI**

All these dependencies, while declaring their requirements, also add parameters, validations, etc. to your *path operations*.

**FastAPI** will take care of adding it all to the OpenAPI schema, so that it is shown in the interactive documentation systems.




### Update replacing with `PUT`

To update an item you can use the HTTP `PUT` operation.

You can use the `jsonable_encoder` to convert the input data to data that can be stored as JSON (e.g. with a NoSQL database). For example, converting `datetime` to `str`.

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str | None = None     description: str | None = None     price: float | None = None     tax: float = 10.5     tags: list[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_item(item_id: str):     return items[item_id]  @app.put(&quot;/items/{item_id}&quot;, response_model=Item) async def update_item(item_id: str, item: Item):     update_item_encoded = jsonable_encoder(item)    items[item_id] = update_item_encoded    return update_item_encoded`

`from typing import Union  from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: Union[str, None] = None     description: Union[str, None] = None     price: Union[float, None] = None     tax: float = 10.5     tags: list[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_item(item_id: str):     return items[item_id]  @app.put(&quot;/items/{item_id}&quot;, response_model=Item) async def update_item(item_id: str, item: Item):     update_item_encoded = jsonable_encoder(item)    items[item_id] = update_item_encoded    return update_item_encoded`

`from typing import List, Union  from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: Union[str, None] = None     description: Union[str, None] = None     price: Union[float, None] = None     tax: float = 10.5     tags: List[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_item(item_id: str):     return items[item_id]  @app.put(&quot;/items/{item_id}&quot;, response_model=Item) async def update_item(item_id: str, item: Item):     update_item_encoded = jsonable_encoder(item)    items[item_id] = update_item_encoded    return update_item_encoded`

`PUT` is used to receive data that should replace the existing data.

#### Warning about replacing

That means that if you want to update the item `bar` using `PUT` with a body containing:

`{     &quot;name&quot;: &quot;Barz&quot;,     &quot;price&quot;: 3,     &quot;description&quot;: None, }`

because it doesn't include the already stored attribute `&quot;tax&quot;: 20.2`, the input model would take the default value of `&quot;tax&quot;: 10.5`.

And the data would be saved with that "new" `tax` of `10.5`.

### Partial updates with `PATCH`

You can also use the HTTP `PATCH` operation to *partially* update data.

This means that you can send only the data that you want to update, leaving the rest intact.

Note

`PATCH` is less commonly used and known than `PUT`.

And many teams use only `PUT`, even for partial updates.

You are **free** to use them however you want, **FastAPI** doesn't impose any restrictions.

But this guide shows you, more or less, how they are intended to be used.

#### Using Pydantic's `exclude_unset` parameter

If you want to receive partial updates, it's very useful to use the parameter `exclude_unset` in Pydantic's model's `.dict()`.

Like `item.dict(exclude_unset=True)`.

That would generate a `dict` with only the data that was set when creating the `item` model, excluding default values.

Then you can use this to generate a `dict` with only the data that was set (sent in the request), omitting default values:

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str | None = None     description: str | None = None     price: float | None = None     tax: float = 10.5     tags: list[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_item(item_id: str):     return items[item_id]  @app.patch(&quot;/items/{item_id}&quot;, response_model=Item) async def update_item(item_id: str, item: Item):     stored_item_data = items[item_id]     stored_item_model = Item(**stored_item_data)     update_data = item.dict(exclude_unset=True)    updated_item = stored_item_model.copy(update=update_data)     items[item_id] = jsonable_encoder(updated_item)     return updated_item`

`from typing import Union  from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: Union[str, None] = None     description: Union[str, None] = None     price: Union[float, None] = None     tax: float = 10.5     tags: list[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_item(item_id: str):     return items[item_id]  @app.patch(&quot;/items/{item_id}&quot;, response_model=Item) async def update_item(item_id: str, item: Item):     stored_item_data = items[item_id]     stored_item_model = Item(**stored_item_data)     update_data = item.dict(exclude_unset=True)    updated_item = stored_item_model.copy(update=update_data)     items[item_id] = jsonable_encoder(updated_item)     return updated_item`

`from typing import List, Union  from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: Union[str, None] = None     description: Union[str, None] = None     price: Union[float, None] = None     tax: float = 10.5     tags: List[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_item(item_id: str):     return items[item_id]  @app.patch(&quot;/items/{item_id}&quot;, response_model=Item) async def update_item(item_id: str, item: Item):     stored_item_data = items[item_id]     stored_item_model = Item(**stored_item_data)     update_data = item.dict(exclude_unset=True)    updated_item = stored_item_model.copy(update=update_data)     items[item_id] = jsonable_encoder(updated_item)     return updated_item`

#### Using Pydantic's `update` parameter

Now, you can create a copy of the existing model using `.copy()`, and pass the `update` parameter with a `dict` containing the data to update.

Like `stored_item_model.copy(update=update_data)`:

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str | None = None     description: str | None = None     price: float | None = None     tax: float = 10.5     tags: list[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_item(item_id: str):     return items[item_id]  @app.patch(&quot;/items/{item_id}&quot;, response_model=Item) async def update_item(item_id: str, item: Item):     stored_item_data = items[item_id]     stored_item_model = Item(**stored_item_data)     update_data = item.dict(exclude_unset=True)     updated_item = stored_item_model.copy(update=update_data)    items[item_id] = jsonable_encoder(updated_item)     return updated_item`

`from typing import Union  from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: Union[str, None] = None     description: Union[str, None] = None     price: Union[float, None] = None     tax: float = 10.5     tags: list[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_item(item_id: str):     return items[item_id]  @app.patch(&quot;/items/{item_id}&quot;, response_model=Item) async def update_item(item_id: str, item: Item):     stored_item_data = items[item_id]     stored_item_model = Item(**stored_item_data)     update_data = item.dict(exclude_unset=True)     updated_item = stored_item_model.copy(update=update_data)    items[item_id] = jsonable_encoder(updated_item)     return updated_item`

`from typing import List, Union  from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: Union[str, None] = None     description: Union[str, None] = None     price: Union[float, None] = None     tax: float = 10.5     tags: List[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_item(item_id: str):     return items[item_id]  @app.patch(&quot;/items/{item_id}&quot;, response_model=Item) async def update_item(item_id: str, item: Item):     stored_item_data = items[item_id]     stored_item_model = Item(**stored_item_data)     update_data = item.dict(exclude_unset=True)     updated_item = stored_item_model.copy(update=update_data)    items[item_id] = jsonable_encoder(updated_item)     return updated_item`

#### Partial updates recap

In summary, to apply partial updates you would:

- (Optionally) use `PATCH` instead of `PUT`.
- Retrieve the stored data.
- Put that data in a Pydantic model.
- Generate a `dict` without default values from the input model (using `exclude_unset`).
  - This way you can update only the values actually set by the user, instead of overriding values already stored with default values in your model.
- Create a copy of the stored model, updating it's attributes with the received partial updates (using the `update` parameter).
- Convert the copied model to something that can be stored in your DB (for example, using the `jsonable_encoder`).
  - This is comparable to using the model's `.dict()` method again, but it makes sure (and converts) the values to data types that can be converted to JSON, for example, `datetime` to `str`.
- Save the data to your DB.
- Return the updated model.

Python 3.10+Python 3.9+Python 3.6+

`from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str | None = None     description: str | None = None     price: float | None = None     tax: float = 10.5     tags: list[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_item(item_id: str):     return items[item_id]  @app.patch(&quot;/items/{item_id}&quot;, response_model=Item) async def update_item(item_id: str, item: Item):     stored_item_data = items[item_id]    stored_item_model = Item(**stored_item_data)    update_data = item.dict(exclude_unset=True)    updated_item = stored_item_model.copy(update=update_data)    items[item_id] = jsonable_encoder(updated_item)    return updated_item`

`from typing import Union  from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: Union[str, None] = None     description: Union[str, None] = None     price: Union[float, None] = None     tax: float = 10.5     tags: list[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_item(item_id: str):     return items[item_id]  @app.patch(&quot;/items/{item_id}&quot;, response_model=Item) async def update_item(item_id: str, item: Item):     stored_item_data = items[item_id]    stored_item_model = Item(**stored_item_data)    update_data = item.dict(exclude_unset=True)    updated_item = stored_item_model.copy(update=update_data)    items[item_id] = jsonable_encoder(updated_item)    return updated_item`

`from typing import List, Union  from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: Union[str, None] = None     description: Union[str, None] = None     price: Union[float, None] = None     tax: float = 10.5     tags: List[str] = []  items = {     &quot;foo&quot;: {&quot;name&quot;: &quot;Foo&quot;, &quot;price&quot;: 50.2},     &quot;bar&quot;: {&quot;name&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;, &quot;price&quot;: 62, &quot;tax&quot;: 20.2},     &quot;baz&quot;: {&quot;name&quot;: &quot;Baz&quot;, &quot;description&quot;: None, &quot;price&quot;: 50.2, &quot;tax&quot;: 10.5, &quot;tags&quot;: []}, }  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_item(item_id: str):     return items[item_id]  @app.patch(&quot;/items/{item_id}&quot;, response_model=Item) async def update_item(item_id: str, item: Item):     stored_item_data = items[item_id]    stored_item_model = Item(**stored_item_data)    update_data = item.dict(exclude_unset=True)    updated_item = stored_item_model.copy(update=update_data)    items[item_id] = jsonable_encoder(updated_item)    return updated_item`

Tip

You can actually use this same technique with an HTTP `PUT` operation.

But the example here uses `PATCH` because it was created for these use cases.

Note

Notice that the input model is still validated.

So, if you want to receive partial updates that can omit all the attributes, you need to have a model with all the attributes marked as optional (with default values or `None`).

To distinguish from the models with all optional values for **updates** and models with required values for **creation**, you can use the ideas described in Extra Models.




There are many ways to handle security, authentication and authorization.

And it normally is a complex and "difficult" topic.

In many frameworks and systems just handling security and authentication takes a big amount of effort and code (in many cases it can be 50% or more of all the code written).

**FastAPI** provides several tools to help you deal with **Security** easily, rapidly, in a standard way, without having to study and learn all the security specifications.

But first, let's check some small concepts.

### In a hurry?

If you don't care about any of these terms and you just need to add security with authentication based on username and password *right now*, skip to the next chapters.

### OAuth2

OAuth2 is a specification that defines several ways to handle authentication and authorization.

It is quite an extensive specification and covers several complex use cases.

It includes ways to authenticate using a "third party".

That's what all the systems with "login with Facebook, Google, Twitter, GitHub" use underneath.

#### OAuth 1

There was an OAuth 1, which is very different from OAuth2, and more complex, as it included direct specifications on how to encrypt the communication.

It is not very popular or used nowadays.

OAuth2 doesn't specify how to encrypt the communication, it expects you to have your application served with HTTPS.

Tip

In the section about **deployment** you will see how to set up HTTPS for free, using Traefik and Let's Encrypt.

### OpenID Connect

OpenID Connect is another specification, based on **OAuth2**.

It just extends OAuth2 specifying some things that are relatively ambiguous in OAuth2, to try to make it more interoperable.

For example, Google login uses OpenID Connect (which underneath uses OAuth2).

But Facebook login doesn't support OpenID Connect. It has its own flavor of OAuth2.

#### OpenID (not "OpenID Connect")

There was also an "OpenID" specification. That tried to solve the same thing as **OpenID Connect**, but was not based on OAuth2.

So, it was a complete additional system.

It is not very popular or used nowadays.

### OpenAPI

OpenAPI (previously known as Swagger) is the open specification for building APIs (now part of the Linux Foundation).

**FastAPI** is based on **OpenAPI**.

That's what makes it possible to have multiple automatic interactive documentation interfaces, code generation, etc.

OpenAPI has a way to define multiple security "schemes".

By using them, you can take advantage of all these standard-based tools, including these interactive documentation systems.

OpenAPI defines the following security schemes:

- `apiKey`: an application specific key that can come from:
  - A query parameter.
  - A header.
  - A cookie.
- `http`: standard HTTP authentication systems, including:
  - `bearer`: a header `Authorization` with a value of `Bearer` plus a token. This is inherited from OAuth2.
  - HTTP Basic authentication.
  - HTTP Digest, etc.
- `oauth2`: all the OAuth2 ways to handle security (called "flows").
  - Several of these flows are appropriate for building an OAuth 2.0 authentication provider (like Google, Facebook, Twitter, GitHub, etc):
    - `implicit`
    - `clientCredentials`
    - `authorizationCode`
  - But there is one specific "flow" that can be perfectly used for handling authentication in the same application directly:
    - `password`: some next chapters will cover examples of this.
- `openIdConnect`: has a way to define how to discover OAuth2 authentication data automatically.
  - This automatic discovery is what is defined in the OpenID Connect specification.

Tip

Integrating other authentication/authorization providers like Google, Facebook, Twitter, GitHub, etc. is also possible and relatively easy.

The most complex problem is building an authentication/authorization provider like those, but **FastAPI** gives you the tools to do it easily, while doing the heavy lifting for you.

### **FastAPI** utilities

FastAPI provides several tools for each of these security schemes in the `fastapi.security` module that simplify using these security mechanisms.

In the next chapters you will see how to add security to your API using those tools provided by **FastAPI**.

And you will also see how it gets automatically integrated into the interactive documentation system.




CORS or "Cross-Origin Resource Sharing" refers to the situations when a frontend running in a browser has JavaScript code that communicates with a backend, and the backend is in a different "origin" than the frontend.

### Origin

An origin is the combination of protocol (`http`, `https`), domain (`myapp.com`, `localhost`, `localhost.tiangolo.com`), and port (`80`, `443`, `8080`).

So, all these are different origins:

- `http://localhost`
- `https://localhost`
- `http://localhost:8080`

Even if they are all in `localhost`, they use different protocols or ports, so, they are different "origins".

### Steps

So, let's say you have a frontend running in your browser at `http://localhost:8080`, and its JavaScript is trying to communicate with a backend running at `http://localhost` (because we don't specify a port, the browser will assume the default port `80`).

Then, the browser will send an HTTP `OPTIONS` request to the backend, and if the backend sends the appropriate headers authorizing the communication from this different origin (`http://localhost:8080`) then the browser will let the JavaScript in the frontend send its request to the backend.

To achieve this, the backend must have a list of "allowed origins".

In this case, it would have to include `http://localhost:8080` for the frontend to work correctly.

### Wildcards

It's also possible to declare the list as `&quot;*&quot;` (a "wildcard") to say that all are allowed.

But that will only allow certain types of communication, excluding everything that involves credentials: Cookies, Authorization headers like those used with Bearer Tokens, etc.

So, for everything to work correctly, it's better to specify explicitly the allowed origins.

### Use `CORSMiddleware`

You can configure it in your **FastAPI** application using the `CORSMiddleware`.

- Import `CORSMiddleware`.
- Create a list of allowed origins (as strings).
- Add it as a "middleware" to your **FastAPI** application.

You can also specify if your backend allows:

- Credentials (Authorization headers, Cookies, etc).
- Specific HTTP methods (`POST`, `PUT`) or all of them with the wildcard `&quot;*&quot;`.
- Specific HTTP headers or all of them with the wildcard `&quot;*&quot;`.

`from fastapi import FastAPI from fastapi.middleware.cors import CORSMiddleware app = FastAPI()  origins = [     &quot;http://localhost.tiangolo.com&quot;,    &quot;https://localhost.tiangolo.com&quot;,    &quot;http://localhost&quot;,    &quot;http://localhost:8080&quot;, ] app.add_middleware(     CORSMiddleware,    allow_origins=origins,    allow_credentials=True,    allow_methods=[&quot;*&quot;],    allow_headers=[&quot;*&quot;], )  @app.get(&quot;/&quot;) async def main():     return {&quot;message&quot;: &quot;Hello World&quot;}`

The default parameters used by the `CORSMiddleware` implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context.

The following arguments are supported:

- `allow_origins` - A list of origins that should be permitted to make cross-origin requests. E.g. `['https://example.org', 'https://www.example.org']`. You can use `['*']` to allow any origin.
- `allow_origin_regex` - A regex string to match against origins that should be permitted to make cross-origin requests. e.g. `'https://.*\.example\.org'`.
- `allow_methods` - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to `['GET']`. You can use `['*']` to allow all standard methods.
- `allow_headers` - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to `[]`. You can use `['*']` to allow all headers. The `Accept`, `Accept-Language`, `Content-Language` and `Content-Type` headers are always allowed for simple CORS requests.
- `allow_credentials` - Indicate that cookies should be supported for cross-origin requests. Defaults to `False`. Also, `allow_origins` cannot be set to `['*']` for credentials to be allowed, origins must be specified.
- `expose_headers` - Indicate any response headers that should be made accessible to the browser. Defaults to `[]`.
- `max_age` - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to `600`.

The middleware responds to two particular types of HTTP request...

#### CORS preflight requests

These are any `OPTIONS` request with `Origin` and `Access-Control-Request-Method` headers.

In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a `200` or `400` response for informational purposes.

#### Simple requests

Any request with an `Origin` header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response.

### More info

For more info about CORS, check the Mozilla CORS documentation.

Technical Details

You could also use `from starlette.middleware.cors import CORSMiddleware`.

**FastAPI** provides several middlewares in `fastapi.middleware` just as a convenience for you, the developer. But most of the available middlewares come directly from Starlette.




You can add middleware to **FastAPI** applications.

A "middleware" is a function that works with every **request** before it is processed by any specific *path operation*. And also with every **response** before returning it.

- It takes each **request** that comes to your application.
- It can then do something to that **request** or run any needed code.
- Then it passes the **request** to be processed by the rest of the application (by some *path operation*).
- It then takes the **response** generated by the application (by some *path operation*).
- It can do something to that **response** or run any needed code.
- Then it returns the **response**.

Technical Details

If you have dependencies with `yield`, the exit code will run *after* the middleware.

If there were any background tasks (documented later), they will run *after* all the middleware.

### Create a middleware

To create a middleware you use the decorator `@app.middleware(&quot;http&quot;)` on top of a function.

The middleware function receives:

- The `request`.
- A function `call_next` that will receive the `request` as a parameter.
  - This function will pass the `request` to the corresponding *path operation*.
  - Then it returns the `response` generated by the corresponding *path operation*.
- You can then modify further the `response` before returning it.

`import time  from fastapi import FastAPI, Request  app = FastAPI()  @app.middleware(&quot;http&quot;) async def add_process_time_header(request: Request, call_next):     start_time = time.time()     response = await call_next(request)    process_time = time.time() - start_time     response.headers[&quot;X-Process-Time&quot;] = str(process_time)     return response`

Technical Details

You could also use `from starlette.requests import Request`.

**FastAPI** provides it as a convenience for you, the developer. But it comes directly from Starlette.

#### Before and after the `response`

You can add code to be run with the `request`, before any *path operation* receives it.

And also after the `response` is generated, before returning it.

For example, you could add a custom header `X-Process-Time` containing the time in seconds that it took to process the request and generate a response:

`import time  from fastapi import FastAPI, Request  app = FastAPI()  @app.middleware(&quot;http&quot;) async def add_process_time_header(request: Request, call_next):     start_time = time.time()    response = await call_next(request)     process_time = time.time() - start_time    response.headers[&quot;X-Process-Time&quot;] = str(process_time)    return response`

### Other middlewares

You can later read more about other middlewares in the Advanced User Guide: Advanced Middleware.

You will read about how to handle CORS with a middleware in the next section.




If you are building an application or a web API, it's rarely the case that you can put everything on a single file.

**FastAPI** provides a convenience tool to structure your application while keeping all the flexibility.

Info

If you come from Flask, this would be the equivalent of Flask's Blueprints.

### An example file structure

Let's say you have a file structure like this:

`. ├── app │   ├── __init__.py │   ├── main.py │   ├── dependencies.py │   └── routers │   │   ├── __init__.py │   │   ├── items.py │   │   └── users.py │   └── internal │       ├── __init__.py │       └── admin.py`

Tip

There are several `__init__.py` files: one in each directory or subdirectory.

This is what allows importing code from one file into another.

For example, in `app/main.py` you could have a line like:

`from app.routers import items`

- The `app` directory contains everything. And it has an empty file `app/__init__.py`, so it is a "Python package" (a collection of "Python modules"): `app`.
- It contains an `app/main.py` file. As it is inside a Python package (a directory with a file `__init__.py`), it is a "module" of that package: `app.main`.
- There's also an `app/dependencies.py` file, just like `app/main.py`, it is a "module": `app.dependencies`.
- There's a subdirectory `app/routers/` with another file `__init__.py`, so it's a "Python subpackage": `app.routers`.
- The file `app/routers/items.py` is inside a package, `app/routers/`, so, it's a submodule: `app.routers.items`.
- The same with `app/routers/users.py`, it's another submodule: `app.routers.users`.
- There's also a subdirectory `app/internal/` with another file `__init__.py`, so it's another "Python subpackage": `app.internal`.
- And the file `app/internal/admin.py` is another submodule: `app.internal.admin`.

<image @ https://fastapi.tiangolo.com/img/tutorial/bigger-applications/package.svg>

The same file structure with comments:

`. ├── app                  # &quot;app&quot; is a Python package │   ├── __init__.py      # this file makes &quot;app&quot; a &quot;Python package&quot; │   ├── main.py          # &quot;main&quot; module, e.g. import app.main │   ├── dependencies.py  # &quot;dependencies&quot; module, e.g. import app.dependencies │   └── routers          # &quot;routers&quot; is a &quot;Python subpackage&quot; │   │   ├── __init__.py  # makes &quot;routers&quot; a &quot;Python subpackage&quot; │   │   ├── items.py     # &quot;items&quot; submodule, e.g. import app.routers.items │   │   └── users.py     # &quot;users&quot; submodule, e.g. import app.routers.users │   └── internal         # &quot;internal&quot; is a &quot;Python subpackage&quot; │       ├── __init__.py  # makes &quot;internal&quot; a &quot;Python subpackage&quot; │       └── admin.py     # &quot;admin&quot; submodule, e.g. import app.internal.admin`

### `APIRouter`

Let's say the file dedicated to handling just users is the submodule at `/app/routers/users.py`.

You want to have the *path operations* related to your users separated from the rest of the code, to keep it organized.

But it's still part of the same **FastAPI** application/web API (it's part of the same "Python Package").

You can create the *path operations* for that module using `APIRouter`.

#### Import `APIRouter`

You import it and create an "instance" the same way you would with the class `FastAPI`:

`from fastapi import APIRouter router = APIRouter()  @router.get(&quot;/users/&quot;, tags=[&quot;users&quot;]) async def read_users():     return [{&quot;username&quot;: &quot;Rick&quot;}, {&quot;username&quot;: &quot;Morty&quot;}]  @router.get(&quot;/users/me&quot;, tags=[&quot;users&quot;]) async def read_user_me():     return {&quot;username&quot;: &quot;fakecurrentuser&quot;}  @router.get(&quot;/users/{username}&quot;, tags=[&quot;users&quot;]) async def read_user(username: str):     return {&quot;username&quot;: username}`

#### *Path operations* with `APIRouter`

And then you use it to declare your *path operations*.

Use it the same way you would use the `FastAPI` class:

`from fastapi import APIRouter  router = APIRouter()  @router.get(&quot;/users/&quot;, tags=[&quot;users&quot;]) async def read_users():     return [{&quot;username&quot;: &quot;Rick&quot;}, {&quot;username&quot;: &quot;Morty&quot;}]  @router.get(&quot;/users/me&quot;, tags=[&quot;users&quot;]) async def read_user_me():     return {&quot;username&quot;: &quot;fakecurrentuser&quot;}  @router.get(&quot;/users/{username}&quot;, tags=[&quot;users&quot;]) async def read_user(username: str):     return {&quot;username&quot;: username}`

You can think of `APIRouter` as a "mini `FastAPI`" class.

All the same options are supported.

All the same `parameters`, `responses`, `dependencies`, `tags`, etc.

Tip

In this example, the variable is called `router`, but you can name it however you want.

We are going to include this `APIRouter` in the main `FastAPI` app, but first, let's check the dependencies and another `APIRouter`.

### Dependencies

We see that we are going to need some dependencies used in several places of the application.

So we put them in their own `dependencies` module (`app/dependencies.py`).

We will now use a simple dependency to read a custom `X-Token` header:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Header, HTTPException  async def get_token_header(x_token: Annotated[str, Header()]):     if x_token != &quot;fake-super-secret-token&quot;:        raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def get_query_token(token: str):     if token != &quot;jessica&quot;:         raise HTTPException(status_code=400, detail=&quot;No Jessica token provided&quot;)`

`from fastapi import Header, HTTPException from typing_extensions import Annotated  async def get_token_header(x_token: Annotated[str, Header()]):     if x_token != &quot;fake-super-secret-token&quot;:        raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def get_query_token(token: str):     if token != &quot;jessica&quot;:         raise HTTPException(status_code=400, detail=&quot;No Jessica token provided&quot;)`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Header, HTTPException  async def get_token_header(x_token: str = Header()):     if x_token != &quot;fake-super-secret-token&quot;:        raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def get_query_token(token: str):     if token != &quot;jessica&quot;:         raise HTTPException(status_code=400, detail=&quot;No Jessica token provided&quot;)`

Tip

We are using an invented header to simplify this example.

But in real cases you will get better results using the integrated Security utilities.

### Another module with `APIRouter`

Let's say you also have the endpoints dedicated to handling "items" from your application in the module at `app/routers/items.py`.

You have *path operations* for:

- `/items/`
- `/items/{item_id}`

It's all the same structure as with `app/routers/users.py`.

But we want to be smarter and simplify the code a bit.

We know all the *path operations* in this module have the same:

- Path `prefix`: `/items`.
- `tags`: (just one tag: `items`).
- Extra `responses`.
- `dependencies`: they all need that `X-Token` dependency we created.

So, instead of adding all that to each *path operation*, we can add it to the `APIRouter`.

`from fastapi import APIRouter, Depends, HTTPException  from ..dependencies import get_token_header  router = APIRouter(     prefix=&quot;/items&quot;,    tags=[&quot;items&quot;],    dependencies=[Depends(get_token_header)],    responses={404: {&quot;description&quot;: &quot;Not found&quot;}}, )  fake_items_db = {&quot;plumbus&quot;: {&quot;name&quot;: &quot;Plumbus&quot;}, &quot;gun&quot;: {&quot;name&quot;: &quot;Portal Gun&quot;}}  @router.get(&quot;/&quot;) async def read_items():     return fake_items_db  @router.get(&quot;/{item_id}&quot;) async def read_item(item_id: str):     if item_id not in fake_items_db:         raise HTTPException(status_code=404, detail=&quot;Item not found&quot;)     return {&quot;name&quot;: fake_items_db[item_id][&quot;name&quot;], &quot;item_id&quot;: item_id}  @router.put(     &quot;/{item_id}&quot;,     tags=[&quot;custom&quot;],     responses={403: {&quot;description&quot;: &quot;Operation forbidden&quot;}}, ) async def update_item(item_id: str):     if item_id != &quot;plumbus&quot;:         raise HTTPException(             status_code=403, detail=&quot;You can only update the item: plumbus&quot;         )     return {&quot;item_id&quot;: item_id, &quot;name&quot;: &quot;The great Plumbus&quot;}`

As the path of each *path operation* has to start with `/`, like in:

`@router.get(&quot;/{item_id}&quot;) async def read_item(item_id: str):     ...`

...the prefix must not include a final `/`.

So, the prefix in this case is `/items`.

We can also add a list of `tags` and extra `responses` that will be applied to all the *path operations* included in this router.

And we can add a list of `dependencies` that will be added to all the *path operations* in the router and will be executed/solved for each request made to them.

The end result is that the item paths are now:

- `/items/`
- `/items/{item_id}`

...as we intended.

- They will be marked with a list of tags that contain a single string `&quot;items&quot;`.
  - These "tags" are especially useful for the automatic interactive documentation systems (using OpenAPI).
- All of them will include the predefined `responses`.
- All these *path operations* will have the list of `dependencies` evaluated/executed before them.
  - If you also declare dependencies in a specific *path operation*, **they will be executed too**.
  - The router dependencies are executed first, then the `dependencies` in the decorator, and then the normal parameter dependencies.
  - You can also add `Security` dependencies with `scopes`.

Tip

Having `dependencies` in the `APIRouter` can be used, for example, to require authentication for a whole group of *path operations*. Even if the dependencies are not added individually to each one of them.

Check

The `prefix`, `tags`, `responses`, and `dependencies` parameters are (as in many other cases) just a feature from **FastAPI** to help you avoid code duplication.

#### Import the dependencies

This code lives in the module `app.routers.items`, the file `app/routers/items.py`.

And we need to get the dependency function from the module `app.dependencies`, the file `app/dependencies.py`.

So we use a relative import with `..` for the dependencies:

`from fastapi import APIRouter, Depends, HTTPException  from ..dependencies import get_token_header router = APIRouter(     prefix=&quot;/items&quot;,     tags=[&quot;items&quot;],     dependencies=[Depends(get_token_header)],     responses={404: {&quot;description&quot;: &quot;Not found&quot;}}, )  fake_items_db = {&quot;plumbus&quot;: {&quot;name&quot;: &quot;Plumbus&quot;}, &quot;gun&quot;: {&quot;name&quot;: &quot;Portal Gun&quot;}}  @router.get(&quot;/&quot;) async def read_items():     return fake_items_db  @router.get(&quot;/{item_id}&quot;) async def read_item(item_id: str):     if item_id not in fake_items_db:         raise HTTPException(status_code=404, detail=&quot;Item not found&quot;)     return {&quot;name&quot;: fake_items_db[item_id][&quot;name&quot;], &quot;item_id&quot;: item_id}  @router.put(     &quot;/{item_id}&quot;,     tags=[&quot;custom&quot;],     responses={403: {&quot;description&quot;: &quot;Operation forbidden&quot;}}, ) async def update_item(item_id: str):     if item_id != &quot;plumbus&quot;:         raise HTTPException(             status_code=403, detail=&quot;You can only update the item: plumbus&quot;         )     return {&quot;item_id&quot;: item_id, &quot;name&quot;: &quot;The great Plumbus&quot;}`

##### How relative imports work

Tip

If you know perfectly how imports work, continue to the next section below.

A single dot `.`, like in:

`from .dependencies import get_token_header`

would mean:

- Starting in the same package that this module (the file `app/routers/items.py`) lives in (the directory `app/routers/`)...
- find the module `dependencies` (an imaginary file at `app/routers/dependencies.py`)...
- and from it, import the function `get_token_header`.

But that file doesn't exist, our dependencies are in a file at `app/dependencies.py`.

Remember how our app/file structure looks like:

<image @ https://fastapi.tiangolo.com/img/tutorial/bigger-applications/package.svg>

***

The two dots `..`, like in:

`from ..dependencies import get_token_header`

mean:

- Starting in the same package that this module (the file `app/routers/items.py`) lives in (the directory `app/routers/`)...
- go to the parent package (the directory `app/`)...
- and in there, find the module `dependencies` (the file at `app/dependencies.py`)...
- and from it, import the function `get_token_header`.

That works correctly! 🎉

***

The same way, if we had used three dots `...`, like in:

`from ...dependencies import get_token_header`

that would mean:

- Starting in the same package that this module (the file `app/routers/items.py`) lives in (the directory `app/routers/`)...
- go to the parent package (the directory `app/`)...
- then go to the parent of that package (there's no parent package, `app` is the top level 😱)...
- and in there, find the module `dependencies` (the file at `app/dependencies.py`)...
- and from it, import the function `get_token_header`.

That would refer to some package above `app/`, with its own file `__init__.py`, etc. But we don't have that. So, that would throw an error in our example. 🚨

But now you know how it works, so you can use relative imports in your own apps no matter how complex they are. 🤓

#### Add some custom `tags`, `responses`, and `dependencies`

We are not adding the prefix `/items` nor the `tags=[&quot;items&quot;]` to each *path operation* because we added them to the `APIRouter`.

But we can still add *more* `tags` that will be applied to a specific *path operation*, and also some extra `responses` specific to that *path operation*:

`from fastapi import APIRouter, Depends, HTTPException  from ..dependencies import get_token_header  router = APIRouter(     prefix=&quot;/items&quot;,     tags=[&quot;items&quot;],     dependencies=[Depends(get_token_header)],     responses={404: {&quot;description&quot;: &quot;Not found&quot;}}, )  fake_items_db = {&quot;plumbus&quot;: {&quot;name&quot;: &quot;Plumbus&quot;}, &quot;gun&quot;: {&quot;name&quot;: &quot;Portal Gun&quot;}}  @router.get(&quot;/&quot;) async def read_items():     return fake_items_db  @router.get(&quot;/{item_id}&quot;) async def read_item(item_id: str):     if item_id not in fake_items_db:         raise HTTPException(status_code=404, detail=&quot;Item not found&quot;)     return {&quot;name&quot;: fake_items_db[item_id][&quot;name&quot;], &quot;item_id&quot;: item_id}  @router.put(     &quot;/{item_id}&quot;,     tags=[&quot;custom&quot;],    responses={403: {&quot;description&quot;: &quot;Operation forbidden&quot;}}, ) async def update_item(item_id: str):     if item_id != &quot;plumbus&quot;:         raise HTTPException(             status_code=403, detail=&quot;You can only update the item: plumbus&quot;         )     return {&quot;item_id&quot;: item_id, &quot;name&quot;: &quot;The great Plumbus&quot;}`

Tip

This last path operation will have the combination of tags: `[&quot;items&quot;, &quot;custom&quot;]`.

And it will also have both responses in the documentation, one for `404` and one for `403`.

### The main `FastAPI`

Now, let's see the module at `app/main.py`.

Here's where you import and use the class `FastAPI`.

This will be the main file in your application that ties everything together.

And as most of your logic will now live in its own specific module, the main file will be quite simple.

#### Import `FastAPI`

You import and create a `FastAPI` class as normally.

And we can even declare global dependencies that will be combined with the dependencies for each `APIRouter`:

`from fastapi import Depends, FastAPI from .dependencies import get_query_token, get_token_header from .internal import admin from .routers import items, users  app = FastAPI(dependencies=[Depends(get_query_token)])  app.include_router(users.router) app.include_router(items.router) app.include_router(     admin.router,     prefix=&quot;/admin&quot;,     tags=[&quot;admin&quot;],     dependencies=[Depends(get_token_header)],     responses={418: {&quot;description&quot;: &quot;I'm a teapot&quot;}}, )  @app.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Hello Bigger Applications!&quot;}`

#### Import the `APIRouter`

Now we import the other submodules that have `APIRouter`s:

`from fastapi import Depends, FastAPI  from .dependencies import get_query_token, get_token_header from .internal import admin from .routers import items, users app = FastAPI(dependencies=[Depends(get_query_token)])  app.include_router(users.router) app.include_router(items.router) app.include_router(     admin.router,     prefix=&quot;/admin&quot;,     tags=[&quot;admin&quot;],     dependencies=[Depends(get_token_header)],     responses={418: {&quot;description&quot;: &quot;I'm a teapot&quot;}}, )  @app.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Hello Bigger Applications!&quot;}`

As the files `app/routers/users.py` and `app/routers/items.py` are submodules that are part of the same Python package `app`, we can use a single dot `.` to import them using "relative imports".

#### How the importing works

The section:

`from .routers import items, users`

Means:

- Starting in the same package that this module (the file `app/main.py`) lives in (the directory `app/`)...
- look for the subpackage `routers` (the directory at `app/routers/`)...
- and from it, import the submodule `items` (the file at `app/routers/items.py`) and `users` (the file at `app/routers/users.py`)...

The module `items` will have a variable `router` (`items.router`). This is the same one we created in the file `app/routers/items.py`, it's an `APIRouter` object.

And then we do the same for the module `users`.

We could also import them like:

`from app.routers import items, users`

Info

The first version is a "relative import":

`from .routers import items, users`

The second version is an "absolute import":

`from app.routers import items, users`

To learn more about Python Packages and Modules, read the official Python documentation about Modules.

#### Avoid name collisions

We are importing the submodule `items` directly, instead of importing just its variable `router`.

This is because we also have another variable named `router` in the submodule `users`.

If we had imported one after the other, like:

`from .routers.items import router from .routers.users import router`

The `router` from `users` would overwrite the one from `items` and we wouldn't be able to use them at the same time.

So, to be able to use both of them in the same file, we import the submodules directly:

`from fastapi import Depends, FastAPI  from .dependencies import get_query_token, get_token_header from .internal import admin from .routers import items, users app = FastAPI(dependencies=[Depends(get_query_token)])  app.include_router(users.router) app.include_router(items.router) app.include_router(     admin.router,     prefix=&quot;/admin&quot;,     tags=[&quot;admin&quot;],     dependencies=[Depends(get_token_header)],     responses={418: {&quot;description&quot;: &quot;I'm a teapot&quot;}}, )  @app.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Hello Bigger Applications!&quot;}`

#### Include the `APIRouter`s for `users` and `items`

Now, let's include the `router`s from the submodules `users` and `items`:

`from fastapi import Depends, FastAPI  from .dependencies import get_query_token, get_token_header from .internal import admin from .routers import items, users  app = FastAPI(dependencies=[Depends(get_query_token)])  app.include_router(users.router) app.include_router(items.router) app.include_router(     admin.router,     prefix=&quot;/admin&quot;,     tags=[&quot;admin&quot;],     dependencies=[Depends(get_token_header)],     responses={418: {&quot;description&quot;: &quot;I'm a teapot&quot;}}, )  @app.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Hello Bigger Applications!&quot;}`

Info

`users.router` contains the `APIRouter` inside of the file `app/routers/users.py`.

And `items.router` contains the `APIRouter` inside of the file `app/routers/items.py`.

With `app.include_router()` we can add each `APIRouter` to the main `FastAPI` application.

It will include all the routes from that router as part of it.

Technical Details

It will actually internally create a *path operation* for each *path operation* that was declared in the `APIRouter`.

So, behind the scenes, it will actually work as if everything was the same single app.

Check

You don't have to worry about performance when including routers.

This will take microseconds and will only happen at startup.

So it won't affect performance. ⚡

#### Include an `APIRouter` with a custom `prefix`, `tags`, `responses`, and `dependencies`

Now, let's imagine your organization gave you the `app/internal/admin.py` file.

It contains an `APIRouter` with some admin *path operations* that your organization shares between several projects.

For this example it will be super simple. But let's say that because it is shared with other projects in the organization, we cannot modify it and add a `prefix`, `dependencies`, `tags`, etc. directly to the `APIRouter`:

`from fastapi import APIRouter  router = APIRouter()  @router.post(&quot;/&quot;) async def update_admin():     return {&quot;message&quot;: &quot;Admin getting schwifty&quot;}`

But we still want to set a custom `prefix` when including the `APIRouter` so that all its *path operations* start with `/admin`, we want to secure it with the `dependencies` we already have for this project, and we want to include `tags` and `responses`.

We can declare all that without having to modify the original `APIRouter` by passing those parameters to `app.include_router()`:

`from fastapi import Depends, FastAPI  from .dependencies import get_query_token, get_token_header from .internal import admin from .routers import items, users  app = FastAPI(dependencies=[Depends(get_query_token)])  app.include_router(users.router) app.include_router(items.router) app.include_router(     admin.router,     prefix=&quot;/admin&quot;,    tags=[&quot;admin&quot;],    dependencies=[Depends(get_token_header)],    responses={418: {&quot;description&quot;: &quot;I'm a teapot&quot;}}, )  @app.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Hello Bigger Applications!&quot;}`

That way, the original `APIRouter` will keep unmodified, so we can still share that same `app/internal/admin.py` file with other projects in the organization.

The result is that in our app, each of the *path operations* from the `admin` module will have:

- The prefix `/admin`.
- The tag `admin`.
- The dependency `get_token_header`.
- The response `418`. 🍵

But that will only affect that `APIRouter` in our app, not in any other code that uses it.

So, for example, other projects could use the same `APIRouter` with a different authentication method.

#### Include a *path operation*

We can also add *path operations* directly to the `FastAPI` app.

Here we do it... just to show that we can 🤷:

`from fastapi import Depends, FastAPI  from .dependencies import get_query_token, get_token_header from .internal import admin from .routers import items, users  app = FastAPI(dependencies=[Depends(get_query_token)])  app.include_router(users.router) app.include_router(items.router) app.include_router(     admin.router,     prefix=&quot;/admin&quot;,     tags=[&quot;admin&quot;],     dependencies=[Depends(get_token_header)],     responses={418: {&quot;description&quot;: &quot;I'm a teapot&quot;}}, )  @app.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Hello Bigger Applications!&quot;}`

and it will work correctly, together with all the other *path operations* added with `app.include_router()`.

Very Technical Details

**Note**: this is a very technical detail that you probably can **just skip**.

***

The `APIRouter`s are not "mounted", they are not isolated from the rest of the application.

This is because we want to include their *path operations* in the OpenAPI schema and the user interfaces.

As we cannot just isolate them and "mount" them independently of the rest, the *path operations* are "cloned" (re-created), not included directly.

### Check the automatic API docs

Now, run `uvicorn`, using the module `app.main` and the variable `app`:

`$ uvicorn app.main:app --reload  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

And open the docs at http://127.0.0.1:8000/docs.

You will see the automatic API docs, including the paths from all the submodules, using the correct paths (and prefixes) and the correct tags:

<image @ https://fastapi.tiangolo.com/img/tutorial/bigger-applications/image01.png>

### Include the same router multiple times with different `prefix`

You can also use `.include_router()` multiple times with the *same* router using different prefixes.

This could be useful, for example, to expose the same API under different prefixes, e.g. `/api/v1` and `/api/latest`.

This is an advanced usage that you might not really need, but it's there in case you do.

### Include an `APIRouter` in another

The same way you can include an `APIRouter` in a `FastAPI` application, you can include an `APIRouter` in another `APIRouter` using:

`router.include_router(other_router)`

Make sure you do it before including `router` in the `FastAPI` app, so that the *path operations* from `other_router` are also included.




You can define background tasks to be run *after* returning a response.

This is useful for operations that need to happen after a request, but that the client doesn't really have to be waiting for the operation to complete before receiving the response.

This includes, for example:

- Email notifications sent after performing an action:
  - As connecting to an email server and sending an email tends to be "slow" (several seconds), you can return the response right away and send the email notification in the background.
- Processing data:
  - For example, let's say you receive a file that must go through a slow process, you can return a response of "Accepted" (HTTP 202) and process it in the background.

### Using `BackgroundTasks`

First, import `BackgroundTasks` and define a parameter in your *path operation function* with a type declaration of `BackgroundTasks`:

`from fastapi import BackgroundTasks, FastAPI app = FastAPI()  def write_notification(email: str, message=&quot;&quot;):     with open(&quot;log.txt&quot;, mode=&quot;w&quot;) as email_file:         content = f&quot;notification for {email}: {message}&quot;         email_file.write(content)  @app.post(&quot;/send-notification/{email}&quot;) async def send_notification(email: str, background_tasks: BackgroundTasks):     background_tasks.add_task(write_notification, email, message=&quot;some notification&quot;)     return {&quot;message&quot;: &quot;Notification sent in the background&quot;}`

**FastAPI** will create the object of type `BackgroundTasks` for you and pass it as that parameter.

### Create a task function

Create a function to be run as the background task.

It is just a standard function that can receive parameters.

It can be an `async def` or normal `def` function, **FastAPI** will know how to handle it correctly.

In this case, the task function will write to a file (simulating sending an email).

And as the write operation doesn't use `async` and `await`, we define the function with normal `def`:

`from fastapi import BackgroundTasks, FastAPI  app = FastAPI()  def write_notification(email: str, message=&quot;&quot;):     with open(&quot;log.txt&quot;, mode=&quot;w&quot;) as email_file:        content = f&quot;notification for {email}: {message}&quot;        email_file.write(content)  @app.post(&quot;/send-notification/{email}&quot;) async def send_notification(email: str, background_tasks: BackgroundTasks):     background_tasks.add_task(write_notification, email, message=&quot;some notification&quot;)     return {&quot;message&quot;: &quot;Notification sent in the background&quot;}`

### Add the background task

Inside of your *path operation function*, pass your task function to the *background tasks* object with the method `.add_task()`:

`from fastapi import BackgroundTasks, FastAPI  app = FastAPI()  def write_notification(email: str, message=&quot;&quot;):     with open(&quot;log.txt&quot;, mode=&quot;w&quot;) as email_file:         content = f&quot;notification for {email}: {message}&quot;         email_file.write(content)  @app.post(&quot;/send-notification/{email}&quot;) async def send_notification(email: str, background_tasks: BackgroundTasks):     background_tasks.add_task(write_notification, email, message=&quot;some notification&quot;)    return {&quot;message&quot;: &quot;Notification sent in the background&quot;}`

`.add_task()` receives as arguments:

- A task function to be run in the background (`write_notification`).
- Any sequence of arguments that should be passed to the task function in order (`email`).
- Any keyword arguments that should be passed to the task function (`message=&quot;some notification&quot;`).

### Dependency Injection

Using `BackgroundTasks` also works with the dependency injection system, you can declare a parameter of type `BackgroundTasks` at multiple levels: in a *path operation function*, in a dependency (dependable), in a sub-dependency, etc.

**FastAPI** knows what to do in each case and how to re-use the same object, so that all the background tasks are merged together and are run in the background afterwards:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import BackgroundTasks, Depends, FastAPI  app = FastAPI()  def write_log(message: str):     with open(&quot;log.txt&quot;, mode=&quot;a&quot;) as log:         log.write(message)  def get_query(background_tasks: BackgroundTasks, q: str | None = None):     if q:         message = f&quot;found query: {q}\n&quot;        background_tasks.add_task(write_log, message)     return q  @app.post(&quot;/send-notification/{email}&quot;) async def send_notification(     email: str, background_tasks: BackgroundTasks, q: Annotated[str, Depends(get_query)] ):     message = f&quot;message to {email}\n&quot;     background_tasks.add_task(write_log, message)    return {&quot;message&quot;: &quot;Message sent&quot;}`

`from typing import Annotated, Union  from fastapi import BackgroundTasks, Depends, FastAPI  app = FastAPI()  def write_log(message: str):     with open(&quot;log.txt&quot;, mode=&quot;a&quot;) as log:         log.write(message)  def get_query(background_tasks: BackgroundTasks, q: Union[str, None] = None):     if q:         message = f&quot;found query: {q}\n&quot;        background_tasks.add_task(write_log, message)     return q  @app.post(&quot;/send-notification/{email}&quot;) async def send_notification(     email: str, background_tasks: BackgroundTasks, q: Annotated[str, Depends(get_query)] ):     message = f&quot;message to {email}\n&quot;     background_tasks.add_task(write_log, message)    return {&quot;message&quot;: &quot;Message sent&quot;}`

`from typing import Union  from fastapi import BackgroundTasks, Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  def write_log(message: str):     with open(&quot;log.txt&quot;, mode=&quot;a&quot;) as log:         log.write(message)  def get_query(background_tasks: BackgroundTasks, q: Union[str, None] = None):     if q:         message = f&quot;found query: {q}\n&quot;        background_tasks.add_task(write_log, message)     return q  @app.post(&quot;/send-notification/{email}&quot;) async def send_notification(     email: str, background_tasks: BackgroundTasks, q: Annotated[str, Depends(get_query)] ):     message = f&quot;message to {email}\n&quot;     background_tasks.add_task(write_log, message)    return {&quot;message&quot;: &quot;Message sent&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import BackgroundTasks, Depends, FastAPI  app = FastAPI()  def write_log(message: str):     with open(&quot;log.txt&quot;, mode=&quot;a&quot;) as log:         log.write(message)  def get_query(background_tasks: BackgroundTasks, q: str | None = None):     if q:         message = f&quot;found query: {q}\n&quot;        background_tasks.add_task(write_log, message)     return q  @app.post(&quot;/send-notification/{email}&quot;) async def send_notification(     email: str, background_tasks: BackgroundTasks, q: str = Depends(get_query) ):     message = f&quot;message to {email}\n&quot;     background_tasks.add_task(write_log, message)    return {&quot;message&quot;: &quot;Message sent&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import BackgroundTasks, Depends, FastAPI  app = FastAPI()  def write_log(message: str):     with open(&quot;log.txt&quot;, mode=&quot;a&quot;) as log:         log.write(message)  def get_query(background_tasks: BackgroundTasks, q: Union[str, None] = None):     if q:         message = f&quot;found query: {q}\n&quot;        background_tasks.add_task(write_log, message)     return q  @app.post(&quot;/send-notification/{email}&quot;) async def send_notification(     email: str, background_tasks: BackgroundTasks, q: str = Depends(get_query) ):     message = f&quot;message to {email}\n&quot;     background_tasks.add_task(write_log, message)    return {&quot;message&quot;: &quot;Message sent&quot;}`

In this example, the messages will be written to the `log.txt` file *after* the response is sent.

If there was a query in the request, it will be written to the log in a background task.

And then another background task generated at the *path operation function* will write a message using the `email` path parameter.

### Technical Details

The class `BackgroundTasks` comes directly from `starlette.background`.

It is imported/included directly into FastAPI so that you can import it from `fastapi` and avoid accidentally importing the alternative `BackgroundTask` (without the `s` at the end) from `starlette.background`.

By only using `BackgroundTasks` (and not `BackgroundTask`), it's then possible to use it as a *path operation function* parameter and have **FastAPI** handle the rest for you, just like when using the `Request` object directly.

It's still possible to use `BackgroundTask` alone in FastAPI, but you have to create the object in your code and return a Starlette `Response` including it.

You can see more details in Starlette's official docs for Background Tasks.

### Caveat

If you need to perform heavy background computation and you don't necessarily need it to be run by the same process (for example, you don't need to share memory, variables, etc), you might benefit from using other bigger tools like Celery.

They tend to require more complex configurations, a message/job queue manager, like RabbitMQ or Redis, but they allow you to run background tasks in multiple processes, and especially, in multiple servers.

To see an example, check the Project Generators, they all include Celery already configured.

But if you need to access variables and objects from the same **FastAPI** app, or you need to perform small background tasks (like sending an email notification), you can simply just use `BackgroundTasks`.

### Recap

Import and use `BackgroundTasks` with parameters in *path operation functions* and dependencies to add background tasks.




Info

These docs are about to be updated. 🎉

The current version assumes Pydantic v1, and SQLAlchemy versions less than 2.0.

The new docs will include Pydantic v2 and will use SQLModel (which is also based on SQLAlchemy) once it is updated to use Pydantic v2 as well.

**FastAPI** doesn't require you to use a SQL (relational) database.

But you can use any relational database that you want.

Here we'll see an example using SQLAlchemy.

You can easily adapt it to any database supported by SQLAlchemy, like:

- PostgreSQL
- MySQL
- SQLite
- Oracle
- Microsoft SQL Server, etc.

In this example, we'll use **SQLite**, because it uses a single file and Python has integrated support. So, you can copy this example and run it as is.

Later, for your production application, you might want to use a database server like **PostgreSQL**.

Note

Notice that most of the code is the standard `SQLAlchemy` code you would use with any framework.

The **FastAPI** specific code is as small as always.

### ORMs

**FastAPI** works with any database and any style of library to talk to the database.

A common pattern is to use an "ORM": an "object-relational mapping" library.

An ORM has tools to convert ("*map*") between *objects* in code and database tables ("*relations*").

With an ORM, you normally create a class that represents a table in a SQL database, each attribute of the class represents a column, with a name and a type.

For example a class `Pet` could represent a SQL table `pets`.

And each *instance* object of that class represents a row in the database.

For example an object `orion_cat` (an instance of `Pet`) could have an attribute `orion_cat.type`, for the column `type`. And the value of that attribute could be, e.g. `&quot;cat&quot;`.

These ORMs also have tools to make the connections or relations between tables or entities.

This way, you could also have an attribute `orion_cat.owner` and the owner would contain the data for this pet's owner, taken from the table *owners*.

So, `orion_cat.owner.name` could be the name (from the `name` column in the `owners` table) of this pet's owner.

It could have a value like `&quot;Arquilian&quot;`.

And the ORM will do all the work to get the information from the corresponding table *owners* when you try to access it from your pet object.

Common ORMs are for example: Django-ORM (part of the Django framework), SQLAlchemy ORM (part of SQLAlchemy, independent of framework) and Peewee (independent of framework), among others.

Here we will see how to work with **SQLAlchemy ORM**.

In a similar way you could use any other ORM.

Tip

There's an equivalent article using Peewee here in the docs.

### File structure

For these examples, let's say you have a directory named `my_super_project` that contains a sub-directory called `sql_app` with a structure like this:

`. └── sql_app     ├── __init__.py     ├── crud.py     ├── database.py     ├── main.py     ├── models.py     └── schemas.py`

The file `__init__.py` is just an empty file, but it tells Python that `sql_app` with all its modules (Python files) is a package.

Now let's see what each file/module does.

### Install `SQLAlchemy`

First you need to install `SQLAlchemy`:

`$ pip install sqlalchemy  ---&gt; 100%`

### Create the SQLAlchemy parts

Let's refer to the file `sql_app/database.py`.

#### Import the SQLAlchemy parts

`from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = &quot;sqlite:///./sql_app.db&quot; # SQLALCHEMY_DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;  engine = create_engine(     SQLALCHEMY_DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)  Base = declarative_base()`

#### Create a database URL for SQLAlchemy

`from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker  SQLALCHEMY_DATABASE_URL = &quot;sqlite:///./sql_app.db&quot; # SQLALCHEMY_DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot; engine = create_engine(     SQLALCHEMY_DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)  Base = declarative_base()`

In this example, we are "connecting" to a SQLite database (opening a file with the SQLite database).

The file will be located at the same directory in the file `sql_app.db`.

That's why the last part is `./sql_app.db`.

If you were using a **PostgreSQL** database instead, you would just have to uncomment the line:

`SQLALCHEMY_DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;`

...and adapt it with your database data and credentials (equivalently for MySQL, MariaDB or any other).

Tip

This is the main line that you would have to modify if you wanted to use a different database.

#### Create the SQLAlchemy `engine`

The first step is to create a SQLAlchemy "engine".

We will later use this `engine` in other places.

`from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker  SQLALCHEMY_DATABASE_URL = &quot;sqlite:///./sql_app.db&quot; # SQLALCHEMY_DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;  engine = create_engine(     SQLALCHEMY_DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)  Base = declarative_base()`

##### Note

The argument:

`connect_args={&quot;check_same_thread&quot;: False}`

...is needed only for `SQLite`. It's not needed for other databases.

Technical Details

By default SQLite will only allow one thread to communicate with it, assuming that each thread would handle an independent request.

This is to prevent accidentally sharing the same connection for different things (for different requests).

But in FastAPI, using normal functions (`def`) more than one thread could interact with the database for the same request, so we need to make SQLite know that it should allow that with `connect_args={&quot;check_same_thread&quot;: False}`.

Also, we will make sure each request gets its own database connection session in a dependency, so there's no need for that default mechanism.

#### Create a `SessionLocal` class

Each instance of the `SessionLocal` class will be a database session. The class itself is not a database session yet.

But once we create an instance of the `SessionLocal` class, this instance will be the actual database session.

We name it `SessionLocal` to distinguish it from the `Session` we are importing from SQLAlchemy.

We will use `Session` (the one imported from SQLAlchemy) later.

To create the `SessionLocal` class, use the function `sessionmaker`:

`from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker  SQLALCHEMY_DATABASE_URL = &quot;sqlite:///./sql_app.db&quot; # SQLALCHEMY_DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;  engine = create_engine(     SQLALCHEMY_DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base = declarative_base()`

#### Create a `Base` class

Now we will use the function `declarative_base()` that returns a class.

Later we will inherit from this class to create each of the database models or classes (the ORM models):

`from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker  SQLALCHEMY_DATABASE_URL = &quot;sqlite:///./sql_app.db&quot; # SQLALCHEMY_DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;  engine = create_engine(     SQLALCHEMY_DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)  Base = declarative_base()`

### Create the database models

Let's now see the file `sql_app/models.py`.

#### Create SQLAlchemy models from the `Base` class

We will use this `Base` class we created before to create the SQLAlchemy models.

Tip

SQLAlchemy uses the term "**model**" to refer to these classes and instances that interact with the database.

But Pydantic also uses the term "**model**" to refer to something different, the data validation, conversion, and documentation classes and instances.

Import `Base` from `database` (the file `database.py` from above).

Create classes that inherit from it.

These classes are the SQLAlchemy models.

`from sqlalchemy import Boolean, Column, ForeignKey, Integer, String from sqlalchemy.orm import relationship  from .database import Base  class User(Base):     __tablename__ = &quot;users&quot;     id = Column(Integer, primary_key=True, index=True)     email = Column(String, unique=True, index=True)     hashed_password = Column(String)     is_active = Column(Boolean, default=True)      items = relationship(&quot;Item&quot;, back_populates=&quot;owner&quot;)  class Item(Base):     __tablename__ = &quot;items&quot;     id = Column(Integer, primary_key=True, index=True)     title = Column(String, index=True)     description = Column(String, index=True)     owner_id = Column(Integer, ForeignKey(&quot;users.id&quot;))      owner = relationship(&quot;User&quot;, back_populates=&quot;items&quot;)`

The `__tablename__` attribute tells SQLAlchemy the name of the table to use in the database for each of these models.

#### Create model attributes/columns

Now create all the model (class) attributes.

Each of these attributes represents a column in its corresponding database table.

We use `Column` from SQLAlchemy as the default value.

And we pass a SQLAlchemy class "type", as `Integer`, `String`, and `Boolean`, that defines the type in the database, as an argument.

`from sqlalchemy import Boolean, Column, ForeignKey, Integer, String from sqlalchemy.orm import relationship  from .database import Base  class User(Base):     __tablename__ = &quot;users&quot;      id = Column(Integer, primary_key=True, index=True)    email = Column(String, unique=True, index=True)    hashed_password = Column(String)    is_active = Column(Boolean, default=True)     items = relationship(&quot;Item&quot;, back_populates=&quot;owner&quot;)  class Item(Base):     __tablename__ = &quot;items&quot;      id = Column(Integer, primary_key=True, index=True)    title = Column(String, index=True)    description = Column(String, index=True)    owner_id = Column(Integer, ForeignKey(&quot;users.id&quot;))     owner = relationship(&quot;User&quot;, back_populates=&quot;items&quot;)`

#### Create the relationships

Now create the relationships.

For this, we use `relationship` provided by SQLAlchemy ORM.

This will become, more or less, a "magic" attribute that will contain the values from other tables related to this one.

`from sqlalchemy import Boolean, Column, ForeignKey, Integer, String from sqlalchemy.orm import relationship from .database import Base  class User(Base):     __tablename__ = &quot;users&quot;      id = Column(Integer, primary_key=True, index=True)     email = Column(String, unique=True, index=True)     hashed_password = Column(String)     is_active = Column(Boolean, default=True)      items = relationship(&quot;Item&quot;, back_populates=&quot;owner&quot;)  class Item(Base):     __tablename__ = &quot;items&quot;      id = Column(Integer, primary_key=True, index=True)     title = Column(String, index=True)     description = Column(String, index=True)     owner_id = Column(Integer, ForeignKey(&quot;users.id&quot;))      owner = relationship(&quot;User&quot;, back_populates=&quot;items&quot;)`

When accessing the attribute `items` in a `User`, as in `my_user.items`, it will have a list of `Item` SQLAlchemy models (from the `items` table) that have a foreign key pointing to this record in the `users` table.

When you access `my_user.items`, SQLAlchemy will actually go and fetch the items from the database in the `items` table and populate them here.

And when accessing the attribute `owner` in an `Item`, it will contain a `User` SQLAlchemy model from the `users` table. It will use the `owner_id` attribute/column with its foreign key to know which record to get from the `users` table.

### Create the Pydantic models

Now let's check the file `sql_app/schemas.py`.

Tip

To avoid confusion between the SQLAlchemy *models* and the Pydantic *models*, we will have the file `models.py` with the SQLAlchemy models, and the file `schemas.py` with the Pydantic models.

These Pydantic models define more or less a "schema" (a valid data shape).

So this will help us avoiding confusion while using both.

#### Create initial Pydantic *models* / schemas

Create an `ItemBase` and `UserBase` Pydantic *models* (or let's say "schemas") to have common attributes while creating or reading data.

And create an `ItemCreate` and `UserCreate` that inherit from them (so they will have the same attributes), plus any additional data (attributes) needed for creation.

So, the user will also have a `password` when creating it.

But for security, the `password` won't be in other Pydantic *models*, for example, it won't be sent from the API when reading a user.

Python 3.10+Python 3.9+Python 3.6+

`from pydantic import BaseModel  class ItemBase(BaseModel):     title: str    description: str | None = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int     owner_id: int      class Config:         orm_mode = True  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int     is_active: bool     items: list[Item] = []      class Config:         orm_mode = True`

`from typing import Union  from pydantic import BaseModel  class ItemBase(BaseModel):     title: str    description: Union[str, None] = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int     owner_id: int      class Config:         orm_mode = True  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int     is_active: bool     items: list[Item] = []      class Config:         orm_mode = True`

`from typing import List, Union  from pydantic import BaseModel  class ItemBase(BaseModel):     title: str    description: Union[str, None] = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int     owner_id: int      class Config:         orm_mode = True  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int     is_active: bool     items: List[Item] = []      class Config:         orm_mode = True`

##### SQLAlchemy style and Pydantic style

Notice that SQLAlchemy *models* define attributes using `=`, and pass the type as a parameter to `Column`, like in:

while Pydantic *models* declare the types using `:`, the new type annotation syntax/type hints:

Have it in mind, so you don't get confused when using `=` and `:` with them.

#### Create Pydantic *models* / schemas for reading / returning

Now create Pydantic *models* (schemas) that will be used when reading data, when returning it from the API.

For example, before creating an item, we don't know what will be the ID assigned to it, but when reading it (when returning it from the API) we will already know its ID.

The same way, when reading a user, we can now declare that `items` will contain the items that belong to this user.

Not only the IDs of those items, but all the data that we defined in the Pydantic *model* for reading items: `Item`.

Python 3.10+Python 3.9+Python 3.6+

`from pydantic import BaseModel  class ItemBase(BaseModel):     title: str     description: str | None = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int    owner_id: int     class Config:         orm_mode = True  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int    is_active: bool    items: list[Item] = []     class Config:         orm_mode = True`

`from typing import Union  from pydantic import BaseModel  class ItemBase(BaseModel):     title: str     description: Union[str, None] = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int    owner_id: int     class Config:         orm_mode = True  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int    is_active: bool    items: list[Item] = []     class Config:         orm_mode = True`

`from typing import List, Union  from pydantic import BaseModel  class ItemBase(BaseModel):     title: str     description: Union[str, None] = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int    owner_id: int     class Config:         orm_mode = True  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int    is_active: bool    items: List[Item] = []     class Config:         orm_mode = True`

Tip

Notice that the `User`, the Pydantic *model* that will be used when reading a user (returning it from the API) doesn't include the `password`.

#### Use Pydantic's `orm_mode`

Now, in the Pydantic *models* for reading, `Item` and `User`, add an internal `Config` class.

This `Config` class is used to provide configurations to Pydantic.

In the `Config` class, set the attribute `orm_mode = True`.

Python 3.10+Python 3.9+Python 3.6+

`from pydantic import BaseModel  class ItemBase(BaseModel):     title: str     description: str | None = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int     owner_id: int      class Config:        orm_mode = True  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int     is_active: bool     items: list[Item] = []      class Config:        orm_mode = True`

`from typing import Union  from pydantic import BaseModel  class ItemBase(BaseModel):     title: str     description: Union[str, None] = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int     owner_id: int      class Config:        orm_mode = True  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int     is_active: bool     items: list[Item] = []      class Config:        orm_mode = True`

`from typing import List, Union  from pydantic import BaseModel  class ItemBase(BaseModel):     title: str     description: Union[str, None] = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int     owner_id: int      class Config:        orm_mode = True  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int     is_active: bool     items: List[Item] = []      class Config:        orm_mode = True`

Tip

Notice it's assigning a value with `=`, like:

`orm_mode = True`

It doesn't use `:` as for the type declarations before.

This is setting a config value, not declaring a type.

Pydantic's `orm_mode` will tell the Pydantic *model* to read the data even if it is not a `dict`, but an ORM model (or any other arbitrary object with attributes).

This way, instead of only trying to get the `id` value from a `dict`, as in:

it will also try to get it from an attribute, as in:

And with this, the Pydantic *model* is compatible with ORMs, and you can just declare it in the `response_model` argument in your *path operations*.

You will be able to return a database model and it will read the data from it.

##### Technical Details about ORM mode

SQLAlchemy and many others are by default "lazy loading".

That means, for example, that they don't fetch the data for relationships from the database unless you try to access the attribute that would contain that data.

For example, accessing the attribute `items`:

would make SQLAlchemy go to the `items` table and get the items for this user, but not before.

Without `orm_mode`, if you returned a SQLAlchemy model from your *path operation*, it wouldn't include the relationship data.

Even if you declared those relationships in your Pydantic models.

But with ORM mode, as Pydantic itself will try to access the data it needs from attributes (instead of assuming a `dict`), you can declare the specific data you want to return and it will be able to go and get it, even from ORMs.

### CRUD utils

Now let's see the file `sql_app/crud.py`.

In this file we will have reusable functions to interact with the data in the database.

**CRUD** comes from: **C**reate, **R**ead, **U**pdate, and **D**elete.

...although in this example we are only creating and reading.

#### Read data

Import `Session` from `sqlalchemy.orm`, this will allow you to declare the type of the `db` parameters and have better type checks and completion in your functions.

Import `models` (the SQLAlchemy models) and `schemas` (the Pydantic *models* / schemas).

Create utility functions to:

- Read a single user by ID and by email.
- Read multiple users.
- Read multiple items.

`from sqlalchemy.orm import Session from . import models, schemas  def get_user(db: Session, user_id: int):     return db.query(models.User).filter(models.User.id == user_id).first()  def get_user_by_email(db: Session, email: str):     return db.query(models.User).filter(models.User.email == email).first()  def get_users(db: Session, skip: int = 0, limit: int = 100):     return db.query(models.User).offset(skip).limit(limit).all()  def create_user(db: Session, user: schemas.UserCreate):     fake_hashed_password = user.password + &quot;notreallyhashed&quot;     db_user = models.User(email=user.email, hashed_password=fake_hashed_password)     db.add(db_user)     db.commit()     db.refresh(db_user)     return db_user  def get_items(db: Session, skip: int = 0, limit: int = 100):     return db.query(models.Item).offset(skip).limit(limit).all()  def create_user_item(db: Session, item: schemas.ItemCreate, user_id: int):     db_item = models.Item(**item.dict(), owner_id=user_id)     db.add(db_item)     db.commit()     db.refresh(db_item)     return db_item`

Tip

By creating functions that are only dedicated to interacting with the database (get a user or an item) independent of your *path operation function*, you can more easily reuse them in multiple parts and also add unit tests for them.

#### Create data

Now create utility functions to create data.

The steps are:

- Create a SQLAlchemy model *instance* with your data.
- `add` that instance object to your database session.
- `commit` the changes to the database (so that they are saved).
- `refresh` your instance (so that it contains any new data from the database, like the generated ID).

`from sqlalchemy.orm import Session  from . import models, schemas  def get_user(db: Session, user_id: int):     return db.query(models.User).filter(models.User.id == user_id).first()  def get_user_by_email(db: Session, email: str):     return db.query(models.User).filter(models.User.email == email).first()  def get_users(db: Session, skip: int = 0, limit: int = 100):     return db.query(models.User).offset(skip).limit(limit).all()  def create_user(db: Session, user: schemas.UserCreate):     fake_hashed_password = user.password + &quot;notreallyhashed&quot;    db_user = models.User(email=user.email, hashed_password=fake_hashed_password)    db.add(db_user)    db.commit()    db.refresh(db_user)    return db_user  def get_items(db: Session, skip: int = 0, limit: int = 100):     return db.query(models.Item).offset(skip).limit(limit).all()  def create_user_item(db: Session, item: schemas.ItemCreate, user_id: int):     db_item = models.Item(**item.dict(), owner_id=user_id)    db.add(db_item)    db.commit()    db.refresh(db_item)    return db_item`

Tip

The SQLAlchemy model for `User` contains a `hashed_password` that should contain a secure hashed version of the password.

But as what the API client provides is the original password, you need to extract it and generate the hashed password in your application.

And then pass the `hashed_password` argument with the value to save.

Warning

This example is not secure, the password is not hashed.

In a real life application you would need to hash the password and never save them in plaintext.

For more details, go back to the Security section in the tutorial.

Here we are focusing only on the tools and mechanics of databases.

Tip

Instead of passing each of the keyword arguments to `Item` and reading each one of them from the Pydantic *model*, we are generating a `dict` with the Pydantic *model*'s data with:

`item.dict()`

and then we are passing the `dict`'s key-value pairs as the keyword arguments to the SQLAlchemy `Item`, with:

`Item(**item.dict())`

And then we pass the extra keyword argument `owner_id` that is not provided by the Pydantic *model*, with:

`Item(**item.dict(), owner_id=user_id)`

### Main **FastAPI** app

And now in the file `sql_app/main.py` let's integrate and use all the other parts we created before.

#### Create the database tables

In a very simplistic way create the database tables:

Python 3.9+Python 3.6+

`from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session  from . import crud, models, schemas from .database import SessionLocal, engine  models.Base.metadata.create_all(bind=engine) app = FastAPI()  # Dependency def get_db():     db = SessionLocal()     try:         yield db     finally:         db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):     db_user = crud.get_user_by_email(db, email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(db=db, user=user)  @app.get(&quot;/users/&quot;, response_model=list[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     users = crud.get_users(db, skip=skip, limit=limit)     return users  @app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)):     db_user = crud.get_user(db, user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item) def create_item_for_user(     user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ):     return crud.create_user_item(db=db, item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=list[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     items = crud.get_items(db, skip=skip, limit=limit)     return items`

`from typing import List  from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session  from . import crud, models, schemas from .database import SessionLocal, engine  models.Base.metadata.create_all(bind=engine) app = FastAPI()  # Dependency def get_db():     db = SessionLocal()     try:         yield db     finally:         db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):     db_user = crud.get_user_by_email(db, email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(db=db, user=user)  @app.get(&quot;/users/&quot;, response_model=List[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     users = crud.get_users(db, skip=skip, limit=limit)     return users  @app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)):     db_user = crud.get_user(db, user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item) def create_item_for_user(     user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ):     return crud.create_user_item(db=db, item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=List[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     items = crud.get_items(db, skip=skip, limit=limit)     return items`

##### Alembic Note

Normally you would probably initialize your database (create tables, etc) with Alembic.

And you would also use Alembic for "migrations" (that's its main job).

A "migration" is the set of steps needed whenever you change the structure of your SQLAlchemy models, add a new attribute, etc. to replicate those changes in the database, add a new column, a new table, etc.

You can find an example of Alembic in a FastAPI project in the templates from Project Generation - Template. Specifically in the `alembic` directory in the source code.

#### Create a dependency

Now use the `SessionLocal` class we created in the `sql_app/database.py` file to create a dependency.

We need to have an independent database session/connection (`SessionLocal`) per request, use the same session through all the request and then close it after the request is finished.

And then a new session will be created for the next request.

For that, we will create a new dependency with `yield`, as explained before in the section about Dependencies with `yield`.

Our dependency will create a new SQLAlchemy `SessionLocal` that will be used in a single request, and then close it once the request is finished.

Python 3.9+Python 3.6+

`from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session  from . import crud, models, schemas from .database import SessionLocal, engine  models.Base.metadata.create_all(bind=engine)  app = FastAPI()  # Dependency def get_db():     db = SessionLocal()    try:        yield db    finally:        db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):     db_user = crud.get_user_by_email(db, email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(db=db, user=user)  @app.get(&quot;/users/&quot;, response_model=list[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     users = crud.get_users(db, skip=skip, limit=limit)     return users  @app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)):     db_user = crud.get_user(db, user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item) def create_item_for_user(     user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ):     return crud.create_user_item(db=db, item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=list[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     items = crud.get_items(db, skip=skip, limit=limit)     return items`

`from typing import List  from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session  from . import crud, models, schemas from .database import SessionLocal, engine  models.Base.metadata.create_all(bind=engine)  app = FastAPI()  # Dependency def get_db():     db = SessionLocal()    try:        yield db    finally:        db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):     db_user = crud.get_user_by_email(db, email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(db=db, user=user)  @app.get(&quot;/users/&quot;, response_model=List[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     users = crud.get_users(db, skip=skip, limit=limit)     return users  @app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)):     db_user = crud.get_user(db, user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item) def create_item_for_user(     user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ):     return crud.create_user_item(db=db, item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=List[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     items = crud.get_items(db, skip=skip, limit=limit)     return items`

Info

We put the creation of the `SessionLocal()` and handling of the requests in a `try` block.

And then we close it in the `finally` block.

This way we make sure the database session is always closed after the request. Even if there was an exception while processing the request.

But you can't raise another exception from the exit code (after `yield`). See more in Dependencies with `yield` and `HTTPException`

And then, when using the dependency in a *path operation function*, we declare it with the type `Session` we imported directly from SQLAlchemy.

This will then give us better editor support inside the *path operation function*, because the editor will know that the `db` parameter is of type `Session`:

Python 3.9+Python 3.6+

`from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session  from . import crud, models, schemas from .database import SessionLocal, engine  models.Base.metadata.create_all(bind=engine)  app = FastAPI()  # Dependency def get_db():     db = SessionLocal()     try:         yield db     finally:         db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):     db_user = crud.get_user_by_email(db, email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(db=db, user=user)  @app.get(&quot;/users/&quot;, response_model=list[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     users = crud.get_users(db, skip=skip, limit=limit)     return users  @app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)):     db_user = crud.get_user(db, user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item) def create_item_for_user(     user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ):     return crud.create_user_item(db=db, item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=list[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     items = crud.get_items(db, skip=skip, limit=limit)     return items`

`from typing import List  from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session  from . import crud, models, schemas from .database import SessionLocal, engine  models.Base.metadata.create_all(bind=engine)  app = FastAPI()  # Dependency def get_db():     db = SessionLocal()     try:         yield db     finally:         db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):     db_user = crud.get_user_by_email(db, email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(db=db, user=user)  @app.get(&quot;/users/&quot;, response_model=List[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     users = crud.get_users(db, skip=skip, limit=limit)     return users  @app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)):     db_user = crud.get_user(db, user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item) def create_item_for_user(     user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ):     return crud.create_user_item(db=db, item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=List[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     items = crud.get_items(db, skip=skip, limit=limit)     return items`

Technical Details

The parameter `db` is actually of type `SessionLocal`, but this class (created with `sessionmaker()`) is a "proxy" of a SQLAlchemy `Session`, so, the editor doesn't really know what methods are provided.

But by declaring the type as `Session`, the editor now can know the available methods (`.add()`, `.query()`, `.commit()`, etc) and can provide better support (like completion). The type declaration doesn't affect the actual object.

#### Create your **FastAPI** *path operations*

Now, finally, here's the standard **FastAPI** *path operations* code.

Python 3.9+Python 3.6+

`from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session  from . import crud, models, schemas from .database import SessionLocal, engine  models.Base.metadata.create_all(bind=engine)  app = FastAPI()  # Dependency def get_db():     db = SessionLocal()     try:         yield db     finally:         db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):     db_user = crud.get_user_by_email(db, email=user.email)    if db_user:        raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)    return crud.create_user(db=db, user=user)  @app.get(&quot;/users/&quot;, response_model=list[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     users = crud.get_users(db, skip=skip, limit=limit)    return users  @app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)):     db_user = crud.get_user(db, user_id=user_id)    if db_user is None:        raise HTTPException(status_code=404, detail=&quot;User not found&quot;)    return db_user  @app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item) def create_item_for_user(     user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ):     return crud.create_user_item(db=db, item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=list[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     items = crud.get_items(db, skip=skip, limit=limit)    return items`

`from typing import List  from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session  from . import crud, models, schemas from .database import SessionLocal, engine  models.Base.metadata.create_all(bind=engine)  app = FastAPI()  # Dependency def get_db():     db = SessionLocal()     try:         yield db     finally:         db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):     db_user = crud.get_user_by_email(db, email=user.email)    if db_user:        raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)    return crud.create_user(db=db, user=user)  @app.get(&quot;/users/&quot;, response_model=List[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     users = crud.get_users(db, skip=skip, limit=limit)    return users  @app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)):     db_user = crud.get_user(db, user_id=user_id)    if db_user is None:        raise HTTPException(status_code=404, detail=&quot;User not found&quot;)    return db_user  @app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item) def create_item_for_user(     user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ):     return crud.create_user_item(db=db, item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=List[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     items = crud.get_items(db, skip=skip, limit=limit)    return items`

We are creating the database session before each request in the dependency with `yield`, and then closing it afterwards.

And then we can create the required dependency in the *path operation function*, to get that session directly.

With that, we can just call `crud.get_user` directly from inside of the *path operation function* and use that session.

Tip

Notice that the values you return are SQLAlchemy models, or lists of SQLAlchemy models.

But as all the *path operations* have a `response_model` with Pydantic *models* / schemas using `orm_mode`, the data declared in your Pydantic models will be extracted from them and returned to the client, with all the normal filtering and validation.

Tip

Also notice that there are `response_models` that have standard Python types like `List[schemas.Item]`.

But as the content/parameter of that `List` is a Pydantic *model* with `orm_mode`, the data will be retrieved and returned to the client as normally, without problems.

#### About `def` vs `async def`

Here we are using SQLAlchemy code inside of the *path operation function* and in the dependency, and, in turn, it will go and communicate with an external database.

That could potentially require some "waiting".

But as SQLAlchemy doesn't have compatibility for using `await` directly, as would be with something like:

`user = await db.query(User).first()`

...and instead we are using:

`user = db.query(User).first()`

Then we should declare the *path operation functions* and the dependency without `async def`, just with a normal `def`, as:

`@app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)):     db_user = crud.get_user(db, user_id=user_id)     ...`

Very Technical Details

If you are curious and have a deep technical knowledge, you can check the very technical details of how this `async def` vs `def` is handled in the Async docs.

### Migrations

Because we are using SQLAlchemy directly and we don't require any kind of plug-in for it to work with **FastAPI**, we could integrate database migrations with Alembic directly.

And as the code related to SQLAlchemy and the SQLAlchemy models lives in separate independent files, you would even be able to perform the migrations with Alembic without having to install FastAPI, Pydantic, or anything else.

The same way, you would be able to use the same SQLAlchemy models and utilities in other parts of your code that are not related to **FastAPI**.

For example, in a background task worker with Celery, RQ, or ARQ.

### Review all the files

Remember you should have a directory named `my_super_project` that contains a sub-directory called `sql_app`.

`sql_app` should have the following files:

- `sql_app/__init__.py`: is an empty file.

- `sql_app/database.py`:

`from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker  SQLALCHEMY_DATABASE_URL = &quot;sqlite:///./sql_app.db&quot; # SQLALCHEMY_DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;  engine = create_engine(     SQLALCHEMY_DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)  Base = declarative_base()`

- `sql_app/models.py`:

`from sqlalchemy import Boolean, Column, ForeignKey, Integer, String from sqlalchemy.orm import relationship  from .database import Base  class User(Base):     __tablename__ = &quot;users&quot;      id = Column(Integer, primary_key=True, index=True)     email = Column(String, unique=True, index=True)     hashed_password = Column(String)     is_active = Column(Boolean, default=True)      items = relationship(&quot;Item&quot;, back_populates=&quot;owner&quot;)  class Item(Base):     __tablename__ = &quot;items&quot;      id = Column(Integer, primary_key=True, index=True)     title = Column(String, index=True)     description = Column(String, index=True)     owner_id = Column(Integer, ForeignKey(&quot;users.id&quot;))      owner = relationship(&quot;User&quot;, back_populates=&quot;items&quot;)`

- `sql_app/schemas.py`:

Python 3.10+Python 3.9+Python 3.6+

`from pydantic import BaseModel  class ItemBase(BaseModel):     title: str     description: str | None = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int     owner_id: int      class Config:         orm_mode = True  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int     is_active: bool     items: list[Item] = []      class Config:         orm_mode = True`

`from typing import Union  from pydantic import BaseModel  class ItemBase(BaseModel):     title: str     description: Union[str, None] = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int     owner_id: int      class Config:         orm_mode = True  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int     is_active: bool     items: list[Item] = []      class Config:         orm_mode = True`

`from typing import List, Union  from pydantic import BaseModel  class ItemBase(BaseModel):     title: str     description: Union[str, None] = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int     owner_id: int      class Config:         orm_mode = True  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int     is_active: bool     items: List[Item] = []      class Config:         orm_mode = True`

- `sql_app/crud.py`:

`from sqlalchemy.orm import Session  from . import models, schemas  def get_user(db: Session, user_id: int):     return db.query(models.User).filter(models.User.id == user_id).first()  def get_user_by_email(db: Session, email: str):     return db.query(models.User).filter(models.User.email == email).first()  def get_users(db: Session, skip: int = 0, limit: int = 100):     return db.query(models.User).offset(skip).limit(limit).all()  def create_user(db: Session, user: schemas.UserCreate):     fake_hashed_password = user.password + &quot;notreallyhashed&quot;     db_user = models.User(email=user.email, hashed_password=fake_hashed_password)     db.add(db_user)     db.commit()     db.refresh(db_user)     return db_user  def get_items(db: Session, skip: int = 0, limit: int = 100):     return db.query(models.Item).offset(skip).limit(limit).all()  def create_user_item(db: Session, item: schemas.ItemCreate, user_id: int):     db_item = models.Item(**item.dict(), owner_id=user_id)     db.add(db_item)     db.commit()     db.refresh(db_item)     return db_item`

- `sql_app/main.py`:

Python 3.9+Python 3.6+

`from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session  from . import crud, models, schemas from .database import SessionLocal, engine  models.Base.metadata.create_all(bind=engine)  app = FastAPI()  # Dependency def get_db():     db = SessionLocal()     try:         yield db     finally:         db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):     db_user = crud.get_user_by_email(db, email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(db=db, user=user)  @app.get(&quot;/users/&quot;, response_model=list[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     users = crud.get_users(db, skip=skip, limit=limit)     return users  @app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)):     db_user = crud.get_user(db, user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item) def create_item_for_user(     user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ):     return crud.create_user_item(db=db, item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=list[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     items = crud.get_items(db, skip=skip, limit=limit)     return items`

`from typing import List  from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session  from . import crud, models, schemas from .database import SessionLocal, engine  models.Base.metadata.create_all(bind=engine)  app = FastAPI()  # Dependency def get_db():     db = SessionLocal()     try:         yield db     finally:         db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):     db_user = crud.get_user_by_email(db, email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(db=db, user=user)  @app.get(&quot;/users/&quot;, response_model=List[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     users = crud.get_users(db, skip=skip, limit=limit)     return users  @app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)):     db_user = crud.get_user(db, user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item) def create_item_for_user(     user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ):     return crud.create_user_item(db=db, item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=List[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     items = crud.get_items(db, skip=skip, limit=limit)     return items`

### Check it

You can copy this code and use it as is.

Info

In fact, the code shown here is part of the tests. As most of the code in these docs.

Then you can run it with Uvicorn:

`$ uvicorn sql_app.main:app --reload  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

And then, you can open your browser at http://127.0.0.1:8000/docs.

And you will be able to interact with your **FastAPI** application, reading data from a real database:

<image @ https://fastapi.tiangolo.com/img/tutorial/sql-databases/image01.png>

### Interact with the database directly

If you want to explore the SQLite database (file) directly, independently of FastAPI, to debug its contents, add tables, columns, records, modify data, etc. you can use DB Browser for SQLite.

It will look like this:

<image @ https://fastapi.tiangolo.com/img/tutorial/sql-databases/image02.png>

You can also use an online SQLite browser like SQLite Viewer or ExtendsClass.

### Alternative DB session with middleware

If you can't use dependencies with `yield` -- for example, if you are not using **Python 3.7** and can't install the "backports" mentioned above for **Python 3.6** -- you can set up the session in a "middleware" in a similar way.

A "middleware" is basically a function that is always executed for each request, with some code executed before, and some code executed after the endpoint function.

#### Create a middleware

The middleware we'll add (just a function) will create a new SQLAlchemy `SessionLocal` for each request, add it to the request and then close it once the request is finished.

Python 3.9+Python 3.6+

`from fastapi import Depends, FastAPI, HTTPException, Request, Response from sqlalchemy.orm import Session  from . import crud, models, schemas from .database import SessionLocal, engine  models.Base.metadata.create_all(bind=engine)  app = FastAPI()  @app.middleware(&quot;http&quot;) async def db_session_middleware(request: Request, call_next):     response = Response(&quot;Internal server error&quot;, status_code=500)    try:        request.state.db = SessionLocal()        response = await call_next(request)    finally:        request.state.db.close()    return response  # Dependency def get_db(request: Request):     return request.state.db  @app.post(&quot;/users/&quot;, response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):     db_user = crud.get_user_by_email(db, email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(db=db, user=user)  @app.get(&quot;/users/&quot;, response_model=list[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     users = crud.get_users(db, skip=skip, limit=limit)     return users  @app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)):     db_user = crud.get_user(db, user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item) def create_item_for_user(     user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ):     return crud.create_user_item(db=db, item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=list[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     items = crud.get_items(db, skip=skip, limit=limit)     return items`

`from typing import List  from fastapi import Depends, FastAPI, HTTPException, Request, Response from sqlalchemy.orm import Session  from . import crud, models, schemas from .database import SessionLocal, engine  models.Base.metadata.create_all(bind=engine)  app = FastAPI()  @app.middleware(&quot;http&quot;) async def db_session_middleware(request: Request, call_next):     response = Response(&quot;Internal server error&quot;, status_code=500)    try:        request.state.db = SessionLocal()        response = await call_next(request)    finally:        request.state.db.close()    return response  # Dependency def get_db(request: Request):     return request.state.db  @app.post(&quot;/users/&quot;, response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):     db_user = crud.get_user_by_email(db, email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(db=db, user=user)  @app.get(&quot;/users/&quot;, response_model=List[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     users = crud.get_users(db, skip=skip, limit=limit)     return users  @app.get(&quot;/users/{user_id}&quot;, response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)):     db_user = crud.get_user(db, user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(&quot;/users/{user_id}/items/&quot;, response_model=schemas.Item) def create_item_for_user(     user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ):     return crud.create_user_item(db=db, item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=List[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):     items = crud.get_items(db, skip=skip, limit=limit)     return items`

Info

We put the creation of the `SessionLocal()` and handling of the requests in a `try` block.

And then we close it in the `finally` block.

This way we make sure the database session is always closed after the request. Even if there was an exception while processing the request.

#### About `request.state`

`request.state` is a property of each `Request` object. It is there to store arbitrary objects attached to the request itself, like the database session in this case. You can read more about it in Starlette's docs about `Request` state.

For us in this case, it helps us ensure a single database session is used through all the request, and then closed afterwards (in the middleware).

#### Dependencies with `yield` or middleware

Adding a **middleware** here is similar to what a dependency with `yield` does, with some differences:

- It requires more code and is a bit more complex.
- The middleware has to be an `async` function.
  - If there is code in it that has to "wait" for the network, it could "block" your application there and degrade performance a bit.
  - Although it's probably not very problematic here with the way `SQLAlchemy` works.
  - But if you added more code to the middleware that had a lot of I/O waiting, it could then be problematic.
- A middleware is run for *every* request.
  - So, a connection will be created for every request.
  - Even when the *path operation* that handles that request didn't need the DB.

Tip

It's probably better to use dependencies with `yield` when they are enough for the use case.

Info

Dependencies with `yield` were added recently to **FastAPI**.

A previous version of this tutorial only had the examples with a middleware and there are probably several applications using the middleware for database session management.




You can connect the debugger in your editor, for example with Visual Studio Code or PyCharm.

### Call `uvicorn`

In your FastAPI application, import and run `uvicorn` directly:

`import uvicorn from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/&quot;) def root():     a = &quot;a&quot;     b = &quot;b&quot; + a     return {&quot;hello world&quot;: b}  if __name__ == &quot;__main__&quot;:     uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=8000)`

#### About `__name__ == &quot;__main__&quot;`

The main purpose of the `__name__ == &quot;__main__&quot;` is to have some code that is executed when your file is called with:

but is not called when another file imports it, like in:

##### More details

Let's say your file is named `myapp.py`.

If you run it with:

then the internal variable `__name__` in your file, created automatically by Python, will have as value the string `&quot;__main__&quot;`.

So, the section:

~~~
`uvicorn.run(app, host="0.0.0.0", port=8000)`
~~~

will run.

***

This won't happen if you import that module (file).

So, if you have another file `importer.py` with:

`from myapp import app  # Some more code`

in that case, the automatically created variable inside of `myapp.py` will not have the variable `__name__` with a value of `&quot;__main__&quot;`.

So, the line:

~~~
`uvicorn.run(app, host="0.0.0.0", port=8000)`
~~~

will not be executed.

### Run your code with your debugger

Because you are running the Uvicorn server directly from your code, you can call your Python program (your FastAPI application) directly from the debugger.

***

For example, in Visual Studio Code, you can:

- Go to the "Debug" panel.
- "Add configuration...".
- Select "Python"
- Run the debugger with the option "`Python: Current File (Integrated Terminal)`".

It will then start the server with your **FastAPI** code, stop at your breakpoints, etc.

Here's how it might look:

<image @ https://fastapi.tiangolo.com/img/tutorial/debugging/image01.png>

***

If you use Pycharm, you can:

- Open the "Run" menu.
- Select the option "Debug...".
- Then a context menu shows up.
- Select the file to debug (in this case, `main.py`).

It will then start the server with your **FastAPI** code, stop at your breakpoints, etc.

Here's how it might look:

<image @ https://fastapi.tiangolo.com/img/tutorial/debugging/image02.png>




You can serve static files automatically from a directory using `StaticFiles`.

### Use `StaticFiles`

- Import `StaticFiles`.
- "Mount" a `StaticFiles()` instance in a specific path.

`from fastapi import FastAPI from fastapi.staticfiles import StaticFiles app = FastAPI()  app.mount(&quot;/static&quot;, StaticFiles(directory=&quot;static&quot;), name=&quot;static&quot;)`

Technical Details

You could also use `from starlette.staticfiles import StaticFiles`.

**FastAPI** provides the same `starlette.staticfiles` as `fastapi.staticfiles` just as a convenience for you, the developer. But it actually comes directly from Starlette.

#### What is "Mounting"

"Mounting" means adding a complete "independent" application in a specific path, that then takes care of handling all the sub-paths.

This is different from using an `APIRouter` as a mounted application is completely independent. The OpenAPI and docs from your main application won't include anything from the mounted application, etc.

You can read more about this in the **Advanced User Guide**.

### Details

The first `&quot;/static&quot;` refers to the sub-path this "sub-application" will be "mounted" on. So, any path that starts with `&quot;/static&quot;` will be handled by it.

The `directory=&quot;static&quot;` refers to the name of the directory that contains your static files.

The `name=&quot;static&quot;` gives it a name that can be used internally by **FastAPI**.

All these parameters can be different than "`static`", adjust them with the needs and specific details of your own application.

### More info

For more details and options check Starlette's docs about Static Files.




You can customize several metadata configurations in your **FastAPI** application.

You can set the following fields that are used in the OpenAPI specification and the automatic API docs UIs:

Parameter

Type

Description

`title`

`str`

The title of the API.

`summary`

`str`

A short summary of the API. Available since OpenAPI 3.1.0, FastAPI 0.99.0.

`description`

`str`

A short description of the API. It can use Markdown.

`version`

`string`

The version of the API. This is the version of your own application, not of OpenAPI. For example `2.5.0`.

`terms_of_service`

`str`

A URL to the Terms of Service for the API. If provided, this has to be a URL.

`contact`

`dict`

The contact information for the exposed API. It can contain several fields. `contact` fields

Parameter

Type

Description

`name`

`str`

The identifying name of the contact person/organization.

`url`

`str`

The URL pointing to the contact information. MUST be in the format of a URL.

`email`

`str`

The email address of the contact person/organization. MUST be in the format of an email address.

`license_info`

`dict`

The license information for the exposed API. It can contain several fields. `license_info` fields

Parameter

Type

Description

`name`

`str`

**REQUIRED** (if a `license_info` is set). The license name used for the API.

`identifier`

`str`

An SPDX license expression for the API. The `identifier` field is mutually exclusive of the `url` field. Available since OpenAPI 3.1.0, FastAPI 0.99.0.

`url`

`str`

A URL to the license used for the API. MUST be in the format of a URL.

You can set them as follows:

`from fastapi import FastAPI  description = &quot;&quot;&quot; ChimichangApp API helps you do awesome stuff. 🚀 ## Items You can **read items**. ## Users You will be able to: * **Create users** (_not implemented_). * **Read users** (_not implemented_). &quot;&quot;&quot; app = FastAPI(     title=&quot;ChimichangApp&quot;,    description=description,    summary=&quot;Deadpool's favorite app. Nuff said.&quot;,    version=&quot;0.0.1&quot;,    terms_of_service=&quot;http://example.com/terms/&quot;,    contact={        &quot;name&quot;: &quot;Deadpoolio the Amazing&quot;,        &quot;url&quot;: &quot;http://x-force.example.com/contact/&quot;,        &quot;email&quot;: &quot;dp@x-force.example.com&quot;,    },    license_info={        &quot;name&quot;: &quot;Apache 2.0&quot;,        &quot;url&quot;: &quot;https://www.apache.org/licenses/LICENSE-2.0.html&quot;,    }, )  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;name&quot;: &quot;Katana&quot;}]`

Tip

You can write Markdown in the `description` field and it will be rendered in the output.

With this configuration, the automatic API docs would look like:

<image @ https://fastapi.tiangolo.com/img/tutorial/metadata/image01.png>

### License identifier

Since OpenAPI 3.1.0 and FastAPI 0.99.0, you can also set the `license_info` with an `identifier` instead of a `url`.

For example:

`from fastapi import FastAPI  description = &quot;&quot;&quot; ChimichangApp API helps you do awesome stuff. 🚀  ## Items  You can **read items**.  ## Users  You will be able to:  * **Create users** (_not implemented_). * **Read users** (_not implemented_). &quot;&quot;&quot;  app = FastAPI(     title=&quot;ChimichangApp&quot;,     description=description,     summary=&quot;Deadpool's favorite app. Nuff said.&quot;,     version=&quot;0.0.1&quot;,     terms_of_service=&quot;http://example.com/terms/&quot;,     contact={         &quot;name&quot;: &quot;Deadpoolio the Amazing&quot;,         &quot;url&quot;: &quot;http://x-force.example.com/contact/&quot;,         &quot;email&quot;: &quot;dp@x-force.example.com&quot;,     },     license_info={         &quot;name&quot;: &quot;Apache 2.0&quot;,         &quot;identifier&quot;: &quot;MIT&quot;,    }, )  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;name&quot;: &quot;Katana&quot;}]`

You can also add additional metadata for the different tags used to group your path operations with the parameter `openapi_tags`.

It takes a list containing one dictionary for each tag.

Each dictionary can contain:

- `name` (**required**): a `str` with the same tag name you use in the `tags` parameter in your *path operations* and `APIRouter`s.
- `description`: a `str` with a short description for the tag. It can have Markdown and will be shown in the docs UI.
- `externalDocs`: a `dict` describing external documentation with:
  - `description`: a `str` with a short description for the external docs.
  - `url` (**required**): a `str` with the URL for the external documentation.

#### Create metadata for tags

Let's try that in an example with tags for `users` and `items`.

Create metadata for your tags and pass it to the `openapi_tags` parameter:

`from fastapi import FastAPI  tags_metadata = [     {        &quot;name&quot;: &quot;users&quot;,        &quot;description&quot;: &quot;Operations with users. The **login** logic is also here.&quot;,    },    {        &quot;name&quot;: &quot;items&quot;,        &quot;description&quot;: &quot;Manage items. So _fancy_ they have their own docs.&quot;,        &quot;externalDocs&quot;: {            &quot;description&quot;: &quot;Items external docs&quot;,            &quot;url&quot;: &quot;https://fastapi.tiangolo.com/&quot;,        },    }, ] app = FastAPI(openapi_tags=tags_metadata)  @app.get(&quot;/users/&quot;, tags=[&quot;users&quot;]) async def get_users():     return [{&quot;name&quot;: &quot;Harry&quot;}, {&quot;name&quot;: &quot;Ron&quot;}]  @app.get(&quot;/items/&quot;, tags=[&quot;items&quot;]) async def get_items():     return [{&quot;name&quot;: &quot;wand&quot;}, {&quot;name&quot;: &quot;flying broom&quot;}]`

Notice that you can use Markdown inside of the descriptions, for example "login" will be shown in bold (**login**) and "fancy" will be shown in italics (*fancy*).

Tip

You don't have to add metadata for all the tags that you use.

#### Use your tags

Use the `tags` parameter with your *path operations* (and `APIRouter`s) to assign them to different tags:

`from fastapi import FastAPI  tags_metadata = [     {         &quot;name&quot;: &quot;users&quot;,         &quot;description&quot;: &quot;Operations with users. The **login** logic is also here.&quot;,     },     {         &quot;name&quot;: &quot;items&quot;,         &quot;description&quot;: &quot;Manage items. So _fancy_ they have their own docs.&quot;,         &quot;externalDocs&quot;: {             &quot;description&quot;: &quot;Items external docs&quot;,             &quot;url&quot;: &quot;https://fastapi.tiangolo.com/&quot;,         },     }, ]  app = FastAPI(openapi_tags=tags_metadata)  @app.get(&quot;/users/&quot;, tags=[&quot;users&quot;]) async def get_users():     return [{&quot;name&quot;: &quot;Harry&quot;}, {&quot;name&quot;: &quot;Ron&quot;}]  @app.get(&quot;/items/&quot;, tags=[&quot;items&quot;]) async def get_items():     return [{&quot;name&quot;: &quot;wand&quot;}, {&quot;name&quot;: &quot;flying broom&quot;}]`

#### Check the docs

Now, if you check the docs, they will show all the additional metadata:

<image @ https://fastapi.tiangolo.com/img/tutorial/metadata/image02.png>

#### Order of tags

The order of each tag metadata dictionary also defines the order shown in the docs UI.

For example, even though `users` would go after `items` in alphabetical order, it is shown before them, because we added their metadata as the first dictionary in the list.

### OpenAPI URL

By default, the OpenAPI schema is served at `/openapi.json`.

But you can configure it with the parameter `openapi_url`.

For example, to set it to be served at `/api/v1/openapi.json`:

`from fastapi import FastAPI  app = FastAPI(openapi_url=&quot;/api/v1/openapi.json&quot;)  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;name&quot;: &quot;Foo&quot;}]`

If you want to disable the OpenAPI schema completely you can set `openapi_url=None`, that will also disable the documentation user interfaces that use it.

### Docs URLs

You can configure the two documentation user interfaces included:

- **Swagger UI**: served at `/docs`.
  - You can set its URL with the parameter `docs_url`.
  - You can disable it by setting `docs_url=None`.
- **ReDoc**: served at `/redoc`.
  - You can set its URL with the parameter `redoc_url`.
  - You can disable it by setting `redoc_url=None`.

For example, to set Swagger UI to be served at `/documentation` and disable ReDoc:

`from fastapi import FastAPI  app = FastAPI(docs_url=&quot;/documentation&quot;, redoc_url=None)  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;name&quot;: &quot;Foo&quot;}]`




### OpenAPI operationId

Warning

If you are not an "expert" in OpenAPI, you probably don't need this.

You can set the OpenAPI `operationId` to be used in your *path operation* with the parameter `operation_id`.

You would have to make sure that it is unique for each operation.

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/&quot;, operation_id=&quot;some_specific_id_you_define&quot;) async def read_items():     return [{&quot;item_id&quot;: &quot;Foo&quot;}]`

#### Using the *path operation function* name as the operationId

If you want to use your APIs' function names as `operationId`s, you can iterate over all of them and override each *path operation's* `operation_id` using their `APIRoute.name`.

You should do it after adding all your *path operations*.

`from fastapi import FastAPI from fastapi.routing import APIRoute app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;item_id&quot;: &quot;Foo&quot;}]  def use_route_names_as_operation_ids(app: FastAPI) -&gt; None:     &quot;&quot;&quot;    Simplify operation IDs so that generated API clients have simpler function    names.     Should be called only after all routes have been added.    &quot;&quot;&quot;    for route in app.routes:        if isinstance(route, APIRoute):            route.operation_id = route.name  # in this case, 'read_items'  use_route_names_as_operation_ids(app)`

Tip

If you manually call `app.openapi()`, you should update the `operationId`s before that.

Warning

If you do this, you have to make sure each one of your *path operation functions* has a unique name.

Even if they are in different modules (Python files).

### Exclude from OpenAPI

To exclude a *path operation* from the generated OpenAPI schema (and thus, from the automatic documentation systems), use the parameter `include_in_schema` and set it to `False`:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/&quot;, include_in_schema=False) async def read_items():     return [{&quot;item_id&quot;: &quot;Foo&quot;}]`

### Advanced description from docstring

You can limit the lines used from the docstring of a *path operation function* for OpenAPI.

Adding an `\f` (an escaped "form feed" character) causes **FastAPI** to truncate the output used for OpenAPI at this point.

It won't show up in the documentation, but other tools (such as Sphinx) will be able to use the rest.

`from typing import Set, Union  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     description: Union[str, None] = None     price: float     tax: Union[float, None] = None     tags: Set[str] = set()  @app.post(&quot;/items/&quot;, response_model=Item, summary=&quot;Create an item&quot;) async def create_item(item: Item):     &quot;&quot;&quot;    Create an item with all the information:     - **name**: each item must have a name    - **description**: a long description    - **price**: required    - **tax**: if the item doesn't have tax, you can omit this    - **tags**: a set of unique tag strings for this item    \f    :param item: User input.    &quot;&quot;&quot;    return item`

### Additional Responses

You probably have seen how to declare the `response_model` and `status_code` for a *path operation*.

That defines the metadata about the main response of a *path operation*.

You can also declare additional responses with their models, status codes, etc.

There's a whole chapter here in the documentation about it, you can read it at Additional Responses in OpenAPI.

When you declare a *path operation* in your application, **FastAPI** automatically generates the relevant metadata about that *path operation* to be included in the OpenAPI schema.

Technical details

In the OpenAPI specification it is called the Operation Object.

It has all the information about the *path operation* and is used to generate the automatic documentation.

It includes the `tags`, `parameters`, `requestBody`, `responses`, etc.

This *path operation*-specific OpenAPI schema is normally generated automatically by **FastAPI**, but you can also extend it.

Tip

This is a low level extension point.

If you only need to declare additional responses, a more convenient way to do it is with Additional Responses in OpenAPI.

You can extend the OpenAPI schema for a *path operation* using the parameter `openapi_extra`.

#### OpenAPI Extensions

This `openapi_extra` can be helpful, for example, to declare OpenAPI Extensions:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/items/&quot;, openapi_extra={&quot;x-aperture-labs-portal&quot;: &quot;blue&quot;}) async def read_items():     return [{&quot;item_id&quot;: &quot;portal-gun&quot;}]`

If you open the automatic API docs, your extension will show up at the bottom of the specific *path operation*.

<image @ https://fastapi.tiangolo.com/img/tutorial/path-operation-advanced-configuration/image01.png>

And if you see the resulting OpenAPI (at `/openapi.json` in your API), you will see your extension as part of the specific *path operation* too:

`{     &quot;openapi&quot;: &quot;3.1.0&quot;,     &quot;info&quot;: {         &quot;title&quot;: &quot;FastAPI&quot;,         &quot;version&quot;: &quot;0.1.0&quot;     },     &quot;paths&quot;: {         &quot;/items/&quot;: {             &quot;get&quot;: {                 &quot;summary&quot;: &quot;Read Items&quot;,                 &quot;operationId&quot;: &quot;read_items_items__get&quot;,                 &quot;responses&quot;: {                     &quot;200&quot;: {                         &quot;description&quot;: &quot;Successful Response&quot;,                         &quot;content&quot;: {                             &quot;application/json&quot;: {                                 &quot;schema&quot;: {}                             }                         }                     }                 },                 &quot;x-aperture-labs-portal&quot;: &quot;blue&quot;            }         }     } }`

#### Custom OpenAPI *path operation* schema

The dictionary in `openapi_extra` will be deeply merged with the automatically generated OpenAPI schema for the *path operation*.

So, you could add additional data to the automatically generated schema.

For example, you could decide to read and validate the request with your own code, without using the automatic features of FastAPI with Pydantic, but you could still want to define the request in the OpenAPI schema.

You could do that with `openapi_extra`:

`from fastapi import FastAPI, Request  app = FastAPI()  def magic_data_reader(raw_body: bytes):     return {         &quot;size&quot;: len(raw_body),         &quot;content&quot;: {             &quot;name&quot;: &quot;Maaaagic&quot;,             &quot;price&quot;: 42,             &quot;description&quot;: &quot;Just kiddin', no magic here. ✨&quot;,         },     }  @app.post(     &quot;/items/&quot;,     openapi_extra={         &quot;requestBody&quot;: {            &quot;content&quot;: {                &quot;application/json&quot;: {                    &quot;schema&quot;: {                        &quot;required&quot;: [&quot;name&quot;, &quot;price&quot;],                        &quot;type&quot;: &quot;object&quot;,                        &quot;properties&quot;: {                            &quot;name&quot;: {&quot;type&quot;: &quot;string&quot;},                            &quot;price&quot;: {&quot;type&quot;: &quot;number&quot;},                            &quot;description&quot;: {&quot;type&quot;: &quot;string&quot;},                        },                    }                }            },            &quot;required&quot;: True,        },    }, ) async def create_item(request: Request):     raw_body = await request.body()    data = magic_data_reader(raw_body)    return data`

In this example, we didn't declare any Pydantic model. In fact, the request body is not even parsed as JSON, it is read directly as `bytes`, and the function `magic_data_reader()` would be in charge of parsing it in some way.

Nevertheless, we can declare the expected schema for the request body.

#### Custom OpenAPI content type

Using this same trick, you could use a Pydantic model to define the JSON Schema that is then included in the custom OpenAPI schema section for the *path operation*.

And you could do this even if the data type in the request is not JSON.

For example, in this application we don't use FastAPI's integrated functionality to extract the JSON Schema from Pydantic models nor the automatic validation for JSON. In fact, we are declaring the request content type as YAML, not JSON:

Pydantic v2Pydantic v1

`from typing import List  import yaml from fastapi import FastAPI, HTTPException, Request from pydantic import BaseModel, ValidationError  app = FastAPI()  class Item(BaseModel):     name: str     tags: List[str]  @app.post(     &quot;/items/&quot;,     openapi_extra={        &quot;requestBody&quot;: {            &quot;content&quot;: {&quot;application/x-yaml&quot;: {&quot;schema&quot;: Item.model_json_schema()}},            &quot;required&quot;: True,        },    }, ) async def create_item(request: Request):     raw_body = await request.body()     try:         data = yaml.safe_load(raw_body)     except yaml.YAMLError:         raise HTTPException(status_code=422, detail=&quot;Invalid YAML&quot;)     try:         item = Item.model_validate(data)     except ValidationError as e:         raise HTTPException(status_code=422, detail=e.errors())     return item`

`from typing import List  import yaml from fastapi import FastAPI, HTTPException, Request from pydantic import BaseModel, ValidationError  app = FastAPI()  class Item(BaseModel):     name: str     tags: List[str]  @app.post(     &quot;/items/&quot;,     openapi_extra={        &quot;requestBody&quot;: {            &quot;content&quot;: {&quot;application/x-yaml&quot;: {&quot;schema&quot;: Item.schema()}},            &quot;required&quot;: True,        },    }, ) async def create_item(request: Request):     raw_body = await request.body()     try:         data = yaml.safe_load(raw_body)     except yaml.YAMLError:         raise HTTPException(status_code=422, detail=&quot;Invalid YAML&quot;)     try:         item = Item.parse_obj(data)     except ValidationError as e:         raise HTTPException(status_code=422, detail=e.errors())     return item`

Info

In Pydantic version 1 the method to get the JSON Schema for a model was called `Item.schema()`, in Pydantic version 2, the method is called `Item.model_schema_json()`.

Nevertheless, although we are not using the default integrated functionality, we are still using a Pydantic model to manually generate the JSON Schema for the data that we want to receive in YAML.

Then we use the request directly, and extract the body as `bytes`. This means that FastAPI won't even try to parse the request payload as JSON.

And then in our code, we parse that YAML content directly, and then we are again using the same Pydantic model to validate the YAML content:

Pydantic v2Pydantic v1

`from typing import List  import yaml from fastapi import FastAPI, HTTPException, Request from pydantic import BaseModel, ValidationError  app = FastAPI()  class Item(BaseModel):     name: str     tags: List[str]  @app.post(     &quot;/items/&quot;,     openapi_extra={         &quot;requestBody&quot;: {             &quot;content&quot;: {&quot;application/x-yaml&quot;: {&quot;schema&quot;: Item.model_json_schema()}},             &quot;required&quot;: True,         },     }, ) async def create_item(request: Request):     raw_body = await request.body()     try:        data = yaml.safe_load(raw_body)    except yaml.YAMLError:        raise HTTPException(status_code=422, detail=&quot;Invalid YAML&quot;)    try:        item = Item.model_validate(data)    except ValidationError as e:        raise HTTPException(status_code=422, detail=e.errors())    return item`

`from typing import List  import yaml from fastapi import FastAPI, HTTPException, Request from pydantic import BaseModel, ValidationError  app = FastAPI()  class Item(BaseModel):     name: str     tags: List[str]  @app.post(     &quot;/items/&quot;,     openapi_extra={         &quot;requestBody&quot;: {             &quot;content&quot;: {&quot;application/x-yaml&quot;: {&quot;schema&quot;: Item.schema()}},             &quot;required&quot;: True,         },     }, ) async def create_item(request: Request):     raw_body = await request.body()     try:        data = yaml.safe_load(raw_body)    except yaml.YAMLError:        raise HTTPException(status_code=422, detail=&quot;Invalid YAML&quot;)    try:        item = Item.parse_obj(data)    except ValidationError as e:        raise HTTPException(status_code=422, detail=e.errors())    return item`

Info

In Pydantic version 1 the method to parse and validate an object was `Item.parse_obj()`, in Pydantic version 2, the method is called `Item.model_validate()`.

Tip

Here we re-use the same Pydantic model.

But the same way, we could have validated it in some other way.




By default, **FastAPI** will return the responses using a `JSONResponse`, putting the content you return from your *path operation* inside of that `JSONResponse`.

It will use the default status code or the one you set in your *path operation*.

### Additional status codes

If you want to return additional status codes apart from the main one, you can do that by returning a `Response` directly, like a `JSONResponse`, and set the additional status code directly.

For example, let's say that you want to have a *path operation* that allows to update items, and returns HTTP status codes of 200 "OK" when successful.

But you also want it to accept new items. And when the items didn't exist before, it creates them, and returns an HTTP status code of 201 "Created".

To achieve that, import `JSONResponse`, and return your content there directly, setting the `status_code` that you want:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Body, FastAPI, status from fastapi.responses import JSONResponse app = FastAPI()  items = {&quot;foo&quot;: {&quot;name&quot;: &quot;Fighters&quot;, &quot;size&quot;: 6}, &quot;bar&quot;: {&quot;name&quot;: &quot;Tenders&quot;, &quot;size&quot;: 3}}  @app.put(&quot;/items/{item_id}&quot;) async def upsert_item(     item_id: str,     name: Annotated[str | None, Body()] = None,     size: Annotated[int | None, Body()] = None, ):     if item_id in items:         item = items[item_id]         item[&quot;name&quot;] = name         item[&quot;size&quot;] = size         return item     else:         item = {&quot;name&quot;: name, &quot;size&quot;: size}         items[item_id] = item         return JSONResponse(status_code=status.HTTP_201_CREATED, content=item)`

`from typing import Annotated, Union  from fastapi import Body, FastAPI, status from fastapi.responses import JSONResponse app = FastAPI()  items = {&quot;foo&quot;: {&quot;name&quot;: &quot;Fighters&quot;, &quot;size&quot;: 6}, &quot;bar&quot;: {&quot;name&quot;: &quot;Tenders&quot;, &quot;size&quot;: 3}}  @app.put(&quot;/items/{item_id}&quot;) async def upsert_item(     item_id: str,     name: Annotated[Union[str, None], Body()] = None,     size: Annotated[Union[int, None], Body()] = None, ):     if item_id in items:         item = items[item_id]         item[&quot;name&quot;] = name         item[&quot;size&quot;] = size         return item     else:         item = {&quot;name&quot;: name, &quot;size&quot;: size}         items[item_id] = item         return JSONResponse(status_code=status.HTTP_201_CREATED, content=item)`

`from typing import Union  from fastapi import Body, FastAPI, status from fastapi.responses import JSONResponse from typing_extensions import Annotated  app = FastAPI()  items = {&quot;foo&quot;: {&quot;name&quot;: &quot;Fighters&quot;, &quot;size&quot;: 6}, &quot;bar&quot;: {&quot;name&quot;: &quot;Tenders&quot;, &quot;size&quot;: 3}}  @app.put(&quot;/items/{item_id}&quot;) async def upsert_item(     item_id: str,     name: Annotated[Union[str, None], Body()] = None,     size: Annotated[Union[int, None], Body()] = None, ):     if item_id in items:         item = items[item_id]         item[&quot;name&quot;] = name         item[&quot;size&quot;] = size         return item     else:         item = {&quot;name&quot;: name, &quot;size&quot;: size}         items[item_id] = item         return JSONResponse(status_code=status.HTTP_201_CREATED, content=item)`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Body, FastAPI, status from fastapi.responses import JSONResponse app = FastAPI()  items = {&quot;foo&quot;: {&quot;name&quot;: &quot;Fighters&quot;, &quot;size&quot;: 6}, &quot;bar&quot;: {&quot;name&quot;: &quot;Tenders&quot;, &quot;size&quot;: 3}}  @app.put(&quot;/items/{item_id}&quot;) async def upsert_item(     item_id: str,     name: str | None = Body(default=None),     size: int | None = Body(default=None), ):     if item_id in items:         item = items[item_id]         item[&quot;name&quot;] = name         item[&quot;size&quot;] = size         return item     else:         item = {&quot;name&quot;: name, &quot;size&quot;: size}         items[item_id] = item         return JSONResponse(status_code=status.HTTP_201_CREATED, content=item)`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Body, FastAPI, status from fastapi.responses import JSONResponse app = FastAPI()  items = {&quot;foo&quot;: {&quot;name&quot;: &quot;Fighters&quot;, &quot;size&quot;: 6}, &quot;bar&quot;: {&quot;name&quot;: &quot;Tenders&quot;, &quot;size&quot;: 3}}  @app.put(&quot;/items/{item_id}&quot;) async def upsert_item(     item_id: str,     name: Union[str, None] = Body(default=None),     size: Union[int, None] = Body(default=None), ):     if item_id in items:         item = items[item_id]         item[&quot;name&quot;] = name         item[&quot;size&quot;] = size         return item     else:         item = {&quot;name&quot;: name, &quot;size&quot;: size}         items[item_id] = item         return JSONResponse(status_code=status.HTTP_201_CREATED, content=item)`

Warning

When you return a `Response` directly, like in the example above, it will be returned directly.

It won't be serialized with a model, etc.

Make sure it has the data you want it to have, and that the values are valid JSON (if you are using `JSONResponse`).

Technical Details

You could also use `from starlette.responses import JSONResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with `status`.

### OpenAPI and API docs

If you return additional status codes and responses directly, they won't be included in the OpenAPI schema (the API docs), because FastAPI doesn't have a way to know beforehand what you are going to return.

But you can document that in your code, using: Additional Responses.




Thanks to Starlette, testing **FastAPI** applications is easy and enjoyable.

It is based on HTTPX, which in turn is designed based on Requests, so it's very familiar and intuitive.

With it, you can use pytest directly with **FastAPI**.

### Using `TestClient`

Info

To use `TestClient`, first install `httpx`.

E.g. `pip install httpx`.

Import `TestClient`.

Create a `TestClient` by passing your **FastAPI** application to it.

Create functions with a name that starts with `test_` (this is standard `pytest` conventions).

Use the `TestClient` object the same way as you do with `httpx`.

Write simple `assert` statements with the standard Python expressions that you need to check (again, standard `pytest`).

`from fastapi import FastAPI from fastapi.testclient import TestClient app = FastAPI()  @app.get(&quot;/&quot;) async def read_main():     return {&quot;msg&quot;: &quot;Hello World&quot;}  client = TestClient(app)  def test_read_main():     response = client.get(&quot;/&quot;)    assert response.status_code == 200    assert response.json() == {&quot;msg&quot;: &quot;Hello World&quot;}`

Tip

Notice that the testing functions are normal `def`, not `async def`.

And the calls to the client are also normal calls, not using `await`.

This allows you to use `pytest` directly without complications.

Technical Details

You could also use `from starlette.testclient import TestClient`.

**FastAPI** provides the same `starlette.testclient` as `fastapi.testclient` just as a convenience for you, the developer. But it comes directly from Starlette.

Tip

If you want to call `async` functions in your tests apart from sending requests to your FastAPI application (e.g. asynchronous database functions), have a look at the Async Tests in the advanced tutorial.

### Separating tests

In a real application, you probably would have your tests in a different file.

And your **FastAPI** application might also be composed of several files/modules, etc.

#### **FastAPI** app file

Let's say you have a file structure as described in Bigger Applications:

`. ├── app │   ├── __init__.py │   └── main.py`

In the file `main.py` you have your **FastAPI** app:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/&quot;) async def read_main():     return {&quot;msg&quot;: &quot;Hello World&quot;}`

#### Testing file

Then you could have a file `test_main.py` with your tests. It could live on the same Python package (the same directory with a `__init__.py` file):

`. ├── app │   ├── __init__.py │   ├── main.py │   └── test_main.py`

Because this file is in the same package, you can use relative imports to import the object `app` from the `main` module (`main.py`):

`from fastapi.testclient import TestClient  from .main import app client = TestClient(app)  def test_read_main():     response = client.get(&quot;/&quot;)     assert response.status_code == 200     assert response.json() == {&quot;msg&quot;: &quot;Hello World&quot;}`

...and have the code for the tests just like before.

### Testing: extended example

Now let's extend this example and add more details to see how to test different parts.

#### Extended **FastAPI** app file

Let's continue with the same file structure as before:

`. ├── app │   ├── __init__.py │   ├── main.py │   └── test_main.py`

Let's say that now the file `main.py` with your **FastAPI** app has some other **path operations**.

It has a `GET` operation that could return an error.

It has a `POST` operation that could return several errors.

Both *path operations* require an `X-Token` header.

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import FastAPI, Header, HTTPException from pydantic import BaseModel  fake_secret_token = &quot;coneofsilence&quot;  fake_db = {     &quot;foo&quot;: {&quot;id&quot;: &quot;foo&quot;, &quot;title&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;There goes my hero&quot;},     &quot;bar&quot;: {&quot;id&quot;: &quot;bar&quot;, &quot;title&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;}, }  app = FastAPI()  class Item(BaseModel):     id: str     title: str     description: str | None = None  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_main(item_id: str, x_token: Annotated[str, Header()]):     if x_token != fake_secret_token:         raise HTTPException(status_code=400, detail=&quot;Invalid X-Token header&quot;)     if item_id not in fake_db:         raise HTTPException(status_code=404, detail=&quot;Item not found&quot;)     return fake_db[item_id]  @app.post(&quot;/items/&quot;, response_model=Item) async def create_item(item: Item, x_token: Annotated[str, Header()]):     if x_token != fake_secret_token:         raise HTTPException(status_code=400, detail=&quot;Invalid X-Token header&quot;)     if item.id in fake_db:         raise HTTPException(status_code=400, detail=&quot;Item already exists&quot;)     fake_db[item.id] = item     return item`

`from typing import Annotated, Union  from fastapi import FastAPI, Header, HTTPException from pydantic import BaseModel  fake_secret_token = &quot;coneofsilence&quot;  fake_db = {     &quot;foo&quot;: {&quot;id&quot;: &quot;foo&quot;, &quot;title&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;There goes my hero&quot;},     &quot;bar&quot;: {&quot;id&quot;: &quot;bar&quot;, &quot;title&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;}, }  app = FastAPI()  class Item(BaseModel):     id: str     title: str     description: Union[str, None] = None  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_main(item_id: str, x_token: Annotated[str, Header()]):     if x_token != fake_secret_token:         raise HTTPException(status_code=400, detail=&quot;Invalid X-Token header&quot;)     if item_id not in fake_db:         raise HTTPException(status_code=404, detail=&quot;Item not found&quot;)     return fake_db[item_id]  @app.post(&quot;/items/&quot;, response_model=Item) async def create_item(item: Item, x_token: Annotated[str, Header()]):     if x_token != fake_secret_token:         raise HTTPException(status_code=400, detail=&quot;Invalid X-Token header&quot;)     if item.id in fake_db:         raise HTTPException(status_code=400, detail=&quot;Item already exists&quot;)     fake_db[item.id] = item     return item`

`from typing import Union  from fastapi import FastAPI, Header, HTTPException from pydantic import BaseModel from typing_extensions import Annotated  fake_secret_token = &quot;coneofsilence&quot;  fake_db = {     &quot;foo&quot;: {&quot;id&quot;: &quot;foo&quot;, &quot;title&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;There goes my hero&quot;},     &quot;bar&quot;: {&quot;id&quot;: &quot;bar&quot;, &quot;title&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;}, }  app = FastAPI()  class Item(BaseModel):     id: str     title: str     description: Union[str, None] = None  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_main(item_id: str, x_token: Annotated[str, Header()]):     if x_token != fake_secret_token:         raise HTTPException(status_code=400, detail=&quot;Invalid X-Token header&quot;)     if item_id not in fake_db:         raise HTTPException(status_code=404, detail=&quot;Item not found&quot;)     return fake_db[item_id]  @app.post(&quot;/items/&quot;, response_model=Item) async def create_item(item: Item, x_token: Annotated[str, Header()]):     if x_token != fake_secret_token:         raise HTTPException(status_code=400, detail=&quot;Invalid X-Token header&quot;)     if item.id in fake_db:         raise HTTPException(status_code=400, detail=&quot;Item already exists&quot;)     fake_db[item.id] = item     return item`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import FastAPI, Header, HTTPException from pydantic import BaseModel  fake_secret_token = &quot;coneofsilence&quot;  fake_db = {     &quot;foo&quot;: {&quot;id&quot;: &quot;foo&quot;, &quot;title&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;There goes my hero&quot;},     &quot;bar&quot;: {&quot;id&quot;: &quot;bar&quot;, &quot;title&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;}, }  app = FastAPI()  class Item(BaseModel):     id: str     title: str     description: str | None = None  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_main(item_id: str, x_token: str = Header()):     if x_token != fake_secret_token:         raise HTTPException(status_code=400, detail=&quot;Invalid X-Token header&quot;)     if item_id not in fake_db:         raise HTTPException(status_code=404, detail=&quot;Item not found&quot;)     return fake_db[item_id]  @app.post(&quot;/items/&quot;, response_model=Item) async def create_item(item: Item, x_token: str = Header()):     if x_token != fake_secret_token:         raise HTTPException(status_code=400, detail=&quot;Invalid X-Token header&quot;)     if item.id in fake_db:         raise HTTPException(status_code=400, detail=&quot;Item already exists&quot;)     fake_db[item.id] = item     return item`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import FastAPI, Header, HTTPException from pydantic import BaseModel  fake_secret_token = &quot;coneofsilence&quot;  fake_db = {     &quot;foo&quot;: {&quot;id&quot;: &quot;foo&quot;, &quot;title&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;There goes my hero&quot;},     &quot;bar&quot;: {&quot;id&quot;: &quot;bar&quot;, &quot;title&quot;: &quot;Bar&quot;, &quot;description&quot;: &quot;The bartenders&quot;}, }  app = FastAPI()  class Item(BaseModel):     id: str     title: str     description: Union[str, None] = None  @app.get(&quot;/items/{item_id}&quot;, response_model=Item) async def read_main(item_id: str, x_token: str = Header()):     if x_token != fake_secret_token:         raise HTTPException(status_code=400, detail=&quot;Invalid X-Token header&quot;)     if item_id not in fake_db:         raise HTTPException(status_code=404, detail=&quot;Item not found&quot;)     return fake_db[item_id]  @app.post(&quot;/items/&quot;, response_model=Item) async def create_item(item: Item, x_token: str = Header()):     if x_token != fake_secret_token:         raise HTTPException(status_code=400, detail=&quot;Invalid X-Token header&quot;)     if item.id in fake_db:         raise HTTPException(status_code=400, detail=&quot;Item already exists&quot;)     fake_db[item.id] = item     return item`

#### Extended testing file

You could then update `test_main.py` with the extended tests:

`from fastapi.testclient import TestClient  from .main import app  client = TestClient(app)  def test_read_item():     response = client.get(&quot;/items/foo&quot;, headers={&quot;X-Token&quot;: &quot;coneofsilence&quot;})     assert response.status_code == 200     assert response.json() == {         &quot;id&quot;: &quot;foo&quot;,         &quot;title&quot;: &quot;Foo&quot;,         &quot;description&quot;: &quot;There goes my hero&quot;,     }  def test_read_item_bad_token():     response = client.get(&quot;/items/foo&quot;, headers={&quot;X-Token&quot;: &quot;hailhydra&quot;})     assert response.status_code == 400     assert response.json() == {&quot;detail&quot;: &quot;Invalid X-Token header&quot;}  def test_read_inexistent_item():     response = client.get(&quot;/items/baz&quot;, headers={&quot;X-Token&quot;: &quot;coneofsilence&quot;})     assert response.status_code == 404     assert response.json() == {&quot;detail&quot;: &quot;Item not found&quot;}  def test_create_item():     response = client.post(         &quot;/items/&quot;,         headers={&quot;X-Token&quot;: &quot;coneofsilence&quot;},         json={&quot;id&quot;: &quot;foobar&quot;, &quot;title&quot;: &quot;Foo Bar&quot;, &quot;description&quot;: &quot;The Foo Barters&quot;},     )     assert response.status_code == 200     assert response.json() == {         &quot;id&quot;: &quot;foobar&quot;,         &quot;title&quot;: &quot;Foo Bar&quot;,         &quot;description&quot;: &quot;The Foo Barters&quot;,     }  def test_create_item_bad_token():     response = client.post(         &quot;/items/&quot;,         headers={&quot;X-Token&quot;: &quot;hailhydra&quot;},         json={&quot;id&quot;: &quot;bazz&quot;, &quot;title&quot;: &quot;Bazz&quot;, &quot;description&quot;: &quot;Drop the bazz&quot;},     )     assert response.status_code == 400     assert response.json() == {&quot;detail&quot;: &quot;Invalid X-Token header&quot;}  def test_create_existing_item():     response = client.post(         &quot;/items/&quot;,         headers={&quot;X-Token&quot;: &quot;coneofsilence&quot;},         json={             &quot;id&quot;: &quot;foo&quot;,             &quot;title&quot;: &quot;The Foo ID Stealers&quot;,             &quot;description&quot;: &quot;There goes my stealer&quot;,         },     )     assert response.status_code == 400     assert response.json() == {&quot;detail&quot;: &quot;Item already exists&quot;}`

Whenever you need the client to pass information in the request and you don't know how to, you can search (Google) how to do it in `httpx`, or even how to do it with `requests`, as HTTPX's design is based on Requests' design.

Then you just do the same in your tests.

E.g.:

- To pass a *path* or *query* parameter, add it to the URL itself.
- To pass a JSON body, pass a Python object (e.g. a `dict`) to the parameter `json`.
- If you need to send *Form Data* instead of JSON, use the `data` parameter instead.
- To pass *headers*, use a `dict` in the `headers` parameter.
- For *cookies*, a `dict` in the `cookies` parameter.

For more information about how to pass data to the backend (using `httpx` or the `TestClient`) check the HTTPX documentation.

Info

Note that the `TestClient` receives data that can be converted to JSON, not Pydantic models.

If you have a Pydantic model in your test and you want to send its data to the application during testing, you can use the `jsonable_encoder` described in JSON Compatible Encoder.

### Run it

After that, you just need to install `pytest`:

`$ pip install pytest  ---&gt; 100%`

It will detect the files and tests automatically, execute them, and report the results back to you.

Run the tests with:

`$ pytest  ================ test session starts ================ platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1 rootdir: /home/user/code/superawesome-cli/app plugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1 collected 6 items  ---&gt; 100%  test_main.py &lt;span style=&quot;color: green; white-space: pre;&quot;&gt;......                            [100%]&lt;/span&gt;  &lt;span style=&quot;color: green;&quot;&gt;================= 1 passed in 0.03s =================&lt;/span&gt;`




When you create a **FastAPI** *path operation* you can normally return any data from it: a `dict`, a `list`, a Pydantic model, a database model, etc.

By default, **FastAPI** would automatically convert that return value to JSON using the `jsonable_encoder` explained in JSON Compatible Encoder.

Then, behind the scenes, it would put that JSON-compatible data (e.g. a `dict`) inside of a `JSONResponse` that would be used to send the response to the client.

But you can return a `JSONResponse` directly from your *path operations*.

It might be useful, for example, to return custom headers or cookies.

### Return a `Response`

In fact, you can return any `Response` or any sub-class of it.

Tip

`JSONResponse` itself is a sub-class of `Response`.

And when you return a `Response`, **FastAPI** will pass it directly.

It won't do any data conversion with Pydantic models, it won't convert the contents to any type, etc.

This gives you a lot of flexibility. You can return any data type, override any data declaration or validation, etc.

### Using the `jsonable_encoder` in a `Response`

Because **FastAPI** doesn't do any change to a `Response` you return, you have to make sure it's contents are ready for it.

For example, you cannot put a Pydantic model in a `JSONResponse` without first converting it to a `dict` with all the data types (like `datetime`, `UUID`, etc) converted to JSON-compatible types.

For those cases, you can use the `jsonable_encoder` to convert your data before passing it to a response:

`from datetime import datetime from typing import Union  from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from fastapi.responses import JSONResponse from pydantic import BaseModel  class Item(BaseModel):     title: str     timestamp: datetime     description: Union[str, None] = None  app = FastAPI()  @app.put(&quot;/items/{id}&quot;) def update_item(id: str, item: Item):     json_compatible_item_data = jsonable_encoder(item)    return JSONResponse(content=json_compatible_item_data)`

Technical Details

You could also use `from starlette.responses import JSONResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

### Returning a custom `Response`

The example above shows all the parts you need, but it's not very useful yet, as you could have just returned the `item` directly, and **FastAPI** would put it in a `JSONResponse` for you, converting it to a `dict`, etc. All that by default.

Now, let's see how you could use that to return a custom response.

Let's say that you want to return an XML response.

You could put your XML content in a string, put it in a `Response`, and return it:

`from fastapi import FastAPI, Response app = FastAPI()  @app.get(&quot;/legacy/&quot;) def get_legacy_data():     data = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;     &lt;shampoo&gt;     &lt;Header&gt;         Apply shampoo here.     &lt;/Header&gt;     &lt;Body&gt;         You'll have to use soap here.     &lt;/Body&gt;     &lt;/shampoo&gt;     &quot;&quot;&quot;     return Response(content=data, media_type=&quot;application/xml&quot;)`

### Notes

When you return a `Response` directly its data is not validated, converted (serialized), nor documented automatically.

But you can still document it as described in Additional Responses in OpenAPI.

You can see in later sections how to use/declare these custom `Response`s while still having automatic data conversion, documentation, etc.




Warning

This is a rather advanced topic.

If you are starting with **FastAPI**, you might not need this.

You can declare additional responses, with additional status codes, media types, descriptions, etc.

Those additional responses will be included in the OpenAPI schema, so they will also appear in the API docs.

But for those additional responses you have to make sure you return a `Response` like `JSONResponse` directly, with your status code and content.

### Additional Response with `model`

You can pass to your *path operation decorators* a parameter `responses`.

It receives a `dict`, the keys are status codes for each response, like `200`, and the values are other `dict`s with the information for each of them.

Each of those response `dict`s can have a key `model`, containing a Pydantic model, just like `response_model`.

**FastAPI** will take that model, generate its JSON Schema and include it in the correct place in OpenAPI.

For example, to declare another response with a status code `404` and a Pydantic model `Message`, you can write:

`from fastapi import FastAPI from fastapi.responses import JSONResponse from pydantic import BaseModel  class Item(BaseModel):     id: str     value: str  class Message(BaseModel):     message: str  app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;, response_model=Item, responses={404: {&quot;model&quot;: Message}}) async def read_item(item_id: str):     if item_id == &quot;foo&quot;:         return {&quot;id&quot;: &quot;foo&quot;, &quot;value&quot;: &quot;there goes my hero&quot;}     return JSONResponse(status_code=404, content={&quot;message&quot;: &quot;Item not found&quot;})`

Note

Have in mind that you have to return the `JSONResponse` directly.

Info

The `model` key is not part of OpenAPI.

**FastAPI** will take the Pydantic model from there, generate the `JSON Schema`, and put it in the correct place.

The correct place is:

- In the key `content`, that has as value another JSON object (`dict`) that contains:
  - A key with the media type, e.g. `application/json`, that contains as value another JSON object, that contains:
    - A key `schema`, that has as the value the JSON Schema from the model, here's the correct place.
      - **FastAPI** adds a reference here to the global JSON Schemas in another place in your OpenAPI instead of including it directly. This way, other applications and clients can use those JSON Schemas directly, provide better code generation tools, etc.

The generated responses in the OpenAPI for this *path operation* will be:

`{     &quot;responses&quot;: {         &quot;404&quot;: {            &quot;description&quot;: &quot;Additional Response&quot;,            &quot;content&quot;: {                &quot;application/json&quot;: {                    &quot;schema&quot;: {                        &quot;$ref&quot;: &quot;#/components/schemas/Message&quot;                    }                }            }        },        &quot;200&quot;: {             &quot;description&quot;: &quot;Successful Response&quot;,             &quot;content&quot;: {                 &quot;application/json&quot;: {                     &quot;schema&quot;: {                         &quot;$ref&quot;: &quot;#/components/schemas/Item&quot;                     }                 }             }         },         &quot;422&quot;: {             &quot;description&quot;: &quot;Validation Error&quot;,             &quot;content&quot;: {                 &quot;application/json&quot;: {                     &quot;schema&quot;: {                         &quot;$ref&quot;: &quot;#/components/schemas/HTTPValidationError&quot;                     }                 }             }         }     } }`

The schemas are referenced to another place inside the OpenAPI schema:

`{     &quot;components&quot;: {         &quot;schemas&quot;: {             &quot;Message&quot;: {                &quot;title&quot;: &quot;Message&quot;,                &quot;required&quot;: [                    &quot;message&quot;                ],                &quot;type&quot;: &quot;object&quot;,                &quot;properties&quot;: {                    &quot;message&quot;: {                        &quot;title&quot;: &quot;Message&quot;,                        &quot;type&quot;: &quot;string&quot;                    }                }            },            &quot;Item&quot;: {                 &quot;title&quot;: &quot;Item&quot;,                 &quot;required&quot;: [                     &quot;id&quot;,                     &quot;value&quot;                 ],                 &quot;type&quot;: &quot;object&quot;,                 &quot;properties&quot;: {                     &quot;id&quot;: {                         &quot;title&quot;: &quot;Id&quot;,                         &quot;type&quot;: &quot;string&quot;                     },                     &quot;value&quot;: {                         &quot;title&quot;: &quot;Value&quot;,                         &quot;type&quot;: &quot;string&quot;                     }                 }             },             &quot;ValidationError&quot;: {                 &quot;title&quot;: &quot;ValidationError&quot;,                 &quot;required&quot;: [                     &quot;loc&quot;,                     &quot;msg&quot;,                     &quot;type&quot;                 ],                 &quot;type&quot;: &quot;object&quot;,                 &quot;properties&quot;: {                     &quot;loc&quot;: {                         &quot;title&quot;: &quot;Location&quot;,                         &quot;type&quot;: &quot;array&quot;,                         &quot;items&quot;: {                             &quot;type&quot;: &quot;string&quot;                         }                     },                     &quot;msg&quot;: {                         &quot;title&quot;: &quot;Message&quot;,                         &quot;type&quot;: &quot;string&quot;                     },                     &quot;type&quot;: {                         &quot;title&quot;: &quot;Error Type&quot;,                         &quot;type&quot;: &quot;string&quot;                     }                 }             },             &quot;HTTPValidationError&quot;: {                 &quot;title&quot;: &quot;HTTPValidationError&quot;,                 &quot;type&quot;: &quot;object&quot;,                 &quot;properties&quot;: {                     &quot;detail&quot;: {                         &quot;title&quot;: &quot;Detail&quot;,                         &quot;type&quot;: &quot;array&quot;,                         &quot;items&quot;: {                             &quot;$ref&quot;: &quot;#/components/schemas/ValidationError&quot;                         }                     }                 }             }         }     } }`

### Additional media types for the main response

You can use this same `responses` parameter to add different media types for the same main response.

For example, you can add an additional media type of `image/png`, declaring that your *path operation* can return a JSON object (with media type `application/json`) or a PNG image:

`from typing import Union  from fastapi import FastAPI from fastapi.responses import FileResponse from pydantic import BaseModel  class Item(BaseModel):     id: str     value: str  app = FastAPI()  @app.get(     &quot;/items/{item_id}&quot;,     response_model=Item,     responses={        200: {            &quot;content&quot;: {&quot;image/png&quot;: {}},            &quot;description&quot;: &quot;Return the JSON item or an image.&quot;,        }    }, ) async def read_item(item_id: str, img: Union[bool, None] = None):     if img:         return FileResponse(&quot;image.png&quot;, media_type=&quot;image/png&quot;)    else:         return {&quot;id&quot;: &quot;foo&quot;, &quot;value&quot;: &quot;there goes my hero&quot;}`

Note

Notice that you have to return the image using a `FileResponse` directly.

Info

Unless you specify a different media type explicitly in your `responses` parameter, FastAPI will assume the response has the same media type as the main response class (default `application/json`).

But if you have specified a custom response class with `None` as its media type, FastAPI will use `application/json` for any additional response that has an associated model.

### Combining information

You can also combine response information from multiple places, including the `response_model`, `status_code`, and `responses` parameters.

You can declare a `response_model`, using the default status code `200` (or a custom one if you need), and then declare additional information for that same response in `responses`, directly in the OpenAPI schema.

**FastAPI** will keep the additional information from `responses`, and combine it with the JSON Schema from your model.

For example, you can declare a response with a status code `404` that uses a Pydantic model and has a custom `description`.

And a response with a status code `200` that uses your `response_model`, but includes a custom `example`:

`from fastapi import FastAPI from fastapi.responses import JSONResponse from pydantic import BaseModel  class Item(BaseModel):     id: str     value: str  class Message(BaseModel):     message: str  app = FastAPI()  @app.get(     &quot;/items/{item_id}&quot;,     response_model=Item,    responses={        404: {&quot;model&quot;: Message, &quot;description&quot;: &quot;The item was not found&quot;},        200: {            &quot;description&quot;: &quot;Item requested by ID&quot;,            &quot;content&quot;: {                &quot;application/json&quot;: {                    &quot;example&quot;: {&quot;id&quot;: &quot;bar&quot;, &quot;value&quot;: &quot;The bar tenders&quot;}                }            },        },    }, ) async def read_item(item_id: str):     if item_id == &quot;foo&quot;:         return {&quot;id&quot;: &quot;foo&quot;, &quot;value&quot;: &quot;there goes my hero&quot;}     else:         return JSONResponse(status_code=404, content={&quot;message&quot;: &quot;Item not found&quot;})`

It will all be combined and included in your OpenAPI, and shown in the API docs:

<image @ https://fastapi.tiangolo.com/img/tutorial/additional-responses/image01.png>

### Combine predefined responses and custom ones

You might want to have some predefined responses that apply to many *path operations*, but you want to combine them with custom responses needed by each *path operation*.

For those cases, you can use the Python technique of "unpacking" a `dict` with `**dict_to_unpack`:

`old_dict = {     &quot;old key&quot;: &quot;old value&quot;,     &quot;second old key&quot;: &quot;second old value&quot;, } new_dict = {**old_dict, &quot;new key&quot;: &quot;new value&quot;}`

Here, `new_dict` will contain all the key-value pairs from `old_dict` plus the new key-value pair:

`{     &quot;old key&quot;: &quot;old value&quot;,     &quot;second old key&quot;: &quot;second old value&quot;,     &quot;new key&quot;: &quot;new value&quot;, }`

You can use that technique to re-use some predefined responses in your *path operations* and combine them with additional custom ones.

For example:

`from typing import Union  from fastapi import FastAPI from fastapi.responses import FileResponse from pydantic import BaseModel  class Item(BaseModel):     id: str     value: str  responses = {     404: {&quot;description&quot;: &quot;Item not found&quot;},    302: {&quot;description&quot;: &quot;The item was moved&quot;},    403: {&quot;description&quot;: &quot;Not enough privileges&quot;}, }  app = FastAPI()  @app.get(     &quot;/items/{item_id}&quot;,     response_model=Item,     responses={**responses, 200: {&quot;content&quot;: {&quot;image/png&quot;: {}}}}, ) async def read_item(item_id: str, img: Union[bool, None] = None):     if img:         return FileResponse(&quot;image.png&quot;, media_type=&quot;image/png&quot;)     else:         return {&quot;id&quot;: &quot;foo&quot;, &quot;value&quot;: &quot;there goes my hero&quot;}`

### More information about OpenAPI responses

To see what exactly you can include in the responses, you can check these sections in the OpenAPI specification:

- OpenAPI Responses Object, it includes the `Response Object`.
- OpenAPI Response Object, you can include anything from this directly in each response inside your `responses` parameter. Including `description`, `headers`, `content` (inside of this is that you declare different media types and JSON Schemas), and `links`.




### Use a `Response` parameter

You can declare a parameter of type `Response` in your *path operation function* (as you can do for cookies).

And then you can set headers in that *temporal* response object.

`from fastapi import FastAPI, Response app = FastAPI()  @app.get(&quot;/headers-and-object/&quot;) def get_headers(response: Response):     response.headers[&quot;X-Cat-Dog&quot;] = &quot;alone in the world&quot;    return {&quot;message&quot;: &quot;Hello World&quot;}`

And then you can return any object you need, as you normally would (a `dict`, a database model, etc).

And if you declared a `response_model`, it will still be used to filter and convert the object you returned.

**FastAPI** will use that *temporal* response to extract the headers (also cookies and status code), and will put them in the final response that contains the value you returned, filtered by any `response_model`.

You can also declare the `Response` parameter in dependencies, and set headers (and cookies) in them.

### Return a `Response` directly

You can also add headers when you return a `Response` directly.

Create a response as described in Return a Response Directly and pass the headers as an additional parameter:

`from fastapi import FastAPI from fastapi.responses import JSONResponse  app = FastAPI()  @app.get(&quot;/headers/&quot;) def get_headers():     content = {&quot;message&quot;: &quot;Hello World&quot;}     headers = {&quot;X-Cat-Dog&quot;: &quot;alone in the world&quot;, &quot;Content-Language&quot;: &quot;en-US&quot;}    return JSONResponse(content=content, headers=headers)`

Technical Details

You could also use `from starlette.responses import Response` or `from starlette.responses import JSONResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

And as the `Response` can be used frequently to set headers and cookies, **FastAPI** also provides it at `fastapi.Response`.

Have in mind that custom proprietary headers can be added using the 'X-' prefix.

But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations (read more in CORS (Cross-Origin Resource Sharing)), using the parameter `expose_headers` documented in Starlette's CORS docs.




You probably read before that you can set a default Response Status Code.

But in some cases you need to return a different status code than the default.

### Use case

For example, imagine that you want to return an HTTP status code of "OK" `200` by default.

But if the data didn't exist, you want to create it, and return an HTTP status code of "CREATED" `201`.

But you still want to be able to filter and convert the data you return with a `response_model`.

For those cases, you can use a `Response` parameter.

### Use a `Response` parameter

You can declare a parameter of type `Response` in your *path operation function* (as you can do for cookies and headers).

And then you can set the `status_code` in that *temporal* response object.

`from fastapi import FastAPI, Response, status app = FastAPI()  tasks = {&quot;foo&quot;: &quot;Listen to the Bar Fighters&quot;}  @app.put(&quot;/get-or-create-task/{task_id}&quot;, status_code=200) def get_or_create_task(task_id: str, response: Response):     if task_id not in tasks:         tasks[task_id] = &quot;This didn't exist before&quot;         response.status_code = status.HTTP_201_CREATED    return tasks[task_id]`

And then you can return any object you need, as you normally would (a `dict`, a database model, etc).

And if you declared a `response_model`, it will still be used to filter and convert the object you returned.

**FastAPI** will use that *temporal* response to extract the status code (also cookies and headers), and will put them in the final response that contains the value you returned, filtered by any `response_model`.

You can also declare the `Response` parameter in dependencies, and set the status code in them. But have in mind that the last one to be set will win.




By default, **FastAPI** will return the responses using `JSONResponse`.

You can override it by returning a `Response` directly as seen in Return a Response directly.

But if you return a `Response` directly, the data won't be automatically converted, and the documentation won't be automatically generated (for example, including the specific "media type", in the HTTP header `Content-Type` as part of the generated OpenAPI).

But you can also declare the `Response` that you want to be used, in the *path operation decorator*.

The contents that you return from your *path operation function* will be put inside of that `Response`.

And if that `Response` has a JSON media type (`application/json`), like is the case with the `JSONResponse` and `UJSONResponse`, the data you return will be automatically converted (and filtered) with any Pydantic `response_model` that you declared in the *path operation decorator*.

Note

If you use a response class with no media type, FastAPI will expect your response to have no content, so it will not document the response format in its generated OpenAPI docs.

### Use `ORJSONResponse`

For example, if you are squeezing performance, you can install and use `orjson` and set the response to be `ORJSONResponse`.

Import the `Response` class (sub-class) you want to use and declare it in the *path operation decorator*.

For large responses, returning a `Response` directly is much faster than returning a dictionary.

This is because by default, FastAPI will inspect every item inside and make sure it is serializable with JSON, using the same JSON Compatible Encoder explained in the tutorial. This is what allows you to return **arbitrary objects**, for example database models.

But if you are certain that the content that you are returning is **serializable with JSON**, you can pass it directly to the response class and avoid the extra overhead that FastAPI would have by passing your return content through the `jsonable_encoder` before passing it to the response class.

`from fastapi import FastAPI from fastapi.responses import ORJSONResponse app = FastAPI()  @app.get(&quot;/items/&quot;, response_class=ORJSONResponse) async def read_items():     return ORJSONResponse([{&quot;item_id&quot;: &quot;Foo&quot;}])`

Info

The parameter `response_class` will also be used to define the "media type" of the response.

In this case, the HTTP header `Content-Type` will be set to `application/json`.

And it will be documented as such in OpenAPI.

Tip

The `ORJSONResponse` is currently only available in FastAPI, not in Starlette.

### HTML Response

To return a response with HTML directly from **FastAPI**, use `HTMLResponse`.

- Import `HTMLResponse`.
- Pass `HTMLResponse` as the parameter `response_class` of your *path operation decorator*.

`from fastapi import FastAPI from fastapi.responses import HTMLResponse app = FastAPI()  @app.get(&quot;/items/&quot;, response_class=HTMLResponse) async def read_items():     return &quot;&quot;&quot;     &lt;html&gt;         &lt;head&gt;             &lt;title&gt;Some HTML in here&lt;/title&gt;         &lt;/head&gt;         &lt;body&gt;             &lt;h1&gt;Look ma! HTML!&lt;/h1&gt;         &lt;/body&gt;     &lt;/html&gt;     &quot;&quot;&quot;`

Info

The parameter `response_class` will also be used to define the "media type" of the response.

In this case, the HTTP header `Content-Type` will be set to `text/html`.

And it will be documented as such in OpenAPI.

#### Return a `Response`

As seen in Return a Response directly, you can also override the response directly in your *path operation*, by returning it.

The same example from above, returning an `HTMLResponse`, could look like:

`from fastapi import FastAPI from fastapi.responses import HTMLResponse app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items():     html_content = &quot;&quot;&quot;     &lt;html&gt;         &lt;head&gt;             &lt;title&gt;Some HTML in here&lt;/title&gt;         &lt;/head&gt;         &lt;body&gt;             &lt;h1&gt;Look ma! HTML!&lt;/h1&gt;         &lt;/body&gt;     &lt;/html&gt;     &quot;&quot;&quot;     return HTMLResponse(content=html_content, status_code=200)`

Warning

A `Response` returned directly by your *path operation function* won't be documented in OpenAPI (for example, the `Content-Type` won't be documented) and won't be visible in the automatic interactive docs.

Info

Of course, the actual `Content-Type` header, status code, etc, will come from the `Response` object your returned.

#### Document in OpenAPI and override `Response`

If you want to override the response from inside of the function but at the same time document the "media type" in OpenAPI, you can use the `response_class` parameter AND return a `Response` object.

The `response_class` will then be used only to document the OpenAPI *path operation*, but your `Response` will be used as is.

##### Return an `HTMLResponse` directly

For example, it could be something like:

`from fastapi import FastAPI from fastapi.responses import HTMLResponse  app = FastAPI()  def generate_html_response():     html_content = &quot;&quot;&quot;     &lt;html&gt;         &lt;head&gt;             &lt;title&gt;Some HTML in here&lt;/title&gt;         &lt;/head&gt;         &lt;body&gt;             &lt;h1&gt;Look ma! HTML!&lt;/h1&gt;         &lt;/body&gt;     &lt;/html&gt;     &quot;&quot;&quot;     return HTMLResponse(content=html_content, status_code=200)  @app.get(&quot;/items/&quot;, response_class=HTMLResponse) async def read_items():     return generate_html_response()`

In this example, the function `generate_html_response()` already generates and returns a `Response` instead of returning the HTML in a `str`.

By returning the result of calling `generate_html_response()`, you are already returning a `Response` that will override the default **FastAPI** behavior.

But as you passed the `HTMLResponse` in the `response_class` too, **FastAPI** will know how to document it in OpenAPI and the interactive docs as HTML with `text/html`:

<image @ https://fastapi.tiangolo.com/img/tutorial/custom-response/image01.png>

### Available responses

Here are some of the available responses.

Have in mind that you can use `Response` to return anything else, or even create a custom sub-class.

Technical Details

You could also use `from starlette.responses import HTMLResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

#### `Response`

The main `Response` class, all the other responses inherit from it.

You can return it directly.

It accepts the following parameters:

- `content` - A `str` or `bytes`.
- `status_code` - An `int` HTTP status code.
- `headers` - A `dict` of strings.
- `media_type` - A `str` giving the media type. E.g. `&quot;text/html&quot;`.

FastAPI (actually Starlette) will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types.

`from fastapi import FastAPI, Response app = FastAPI()  @app.get(&quot;/legacy/&quot;) def get_legacy_data():     data = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;     &lt;shampoo&gt;     &lt;Header&gt;         Apply shampoo here.     &lt;/Header&gt;     &lt;Body&gt;         You'll have to use soap here.     &lt;/Body&gt;     &lt;/shampoo&gt;     &quot;&quot;&quot;     return Response(content=data, media_type=&quot;application/xml&quot;)`

#### `HTMLResponse`

Takes some text or bytes and returns an HTML response, as you read above.

#### `PlainTextResponse`

Takes some text or bytes and returns an plain text response.

`from fastapi import FastAPI from fastapi.responses import PlainTextResponse app = FastAPI()  @app.get(&quot;/&quot;, response_class=PlainTextResponse) async def main():     return &quot;Hello World&quot;`

#### `JSONResponse`

Takes some data and returns an `application/json` encoded response.

This is the default response used in **FastAPI**, as you read above.

#### `ORJSONResponse`

A fast alternative JSON response using `orjson`, as you read above.

#### `UJSONResponse`

An alternative JSON response using `ujson`.

Warning

`ujson` is less careful than Python's built-in implementation in how it handles some edge-cases.

`from fastapi import FastAPI from fastapi.responses import UJSONResponse app = FastAPI()  @app.get(&quot;/items/&quot;, response_class=UJSONResponse) async def read_items():     return [{&quot;item_id&quot;: &quot;Foo&quot;}]`

Tip

It's possible that `ORJSONResponse` might be a faster alternative.

#### `RedirectResponse`

Returns an HTTP redirect. Uses a 307 status code (Temporary Redirect) by default.

You can return a `RedirectResponse` directly:

`from fastapi import FastAPI from fastapi.responses import RedirectResponse app = FastAPI()  @app.get(&quot;/typer&quot;) async def redirect_typer():     return RedirectResponse(&quot;https://typer.tiangolo.com&quot;)`

***

Or you can use it in the `response_class` parameter:

`from fastapi import FastAPI from fastapi.responses import RedirectResponse app = FastAPI()  @app.get(&quot;/fastapi&quot;, response_class=RedirectResponse) async def redirect_fastapi():     return &quot;https://fastapi.tiangolo.com&quot;`

If you do that, then you can return the URL directly from your *path operation* function.

In this case, the `status_code` used will be the default one for the `RedirectResponse`, which is `307`.

***

You can also use the `status_code` parameter combined with the `response_class` parameter:

`from fastapi import FastAPI from fastapi.responses import RedirectResponse app = FastAPI()  @app.get(&quot;/pydantic&quot;, response_class=RedirectResponse, status_code=302) async def redirect_pydantic():     return &quot;https://pydantic-docs.helpmanual.io/&quot;`

#### `StreamingResponse`

Takes an async generator or a normal generator/iterator and streams the response body.

`from fastapi import FastAPI from fastapi.responses import StreamingResponse app = FastAPI()  async def fake_video_streamer():     for i in range(10):         yield b&quot;some fake video bytes&quot;  @app.get(&quot;/&quot;) async def main():     return StreamingResponse(fake_video_streamer())`

##### Using `StreamingResponse` with file-like objects

If you have a file-like object (e.g. the object returned by `open()`), you can create a generator function to iterate over that file-like object.

That way, you don't have to read it all first in memory, and you can pass that generator function to the `StreamingResponse`, and return it.

This includes many libraries to interact with cloud storage, video processing, and others.

`from fastapi import FastAPI from fastapi.responses import StreamingResponse some_file_path = &quot;large-video-file.mp4&quot; app = FastAPI()  @app.get(&quot;/&quot;) def main():     def iterfile():  # (1)        with open(some_file_path, mode=&quot;rb&quot;) as file_like:  # (2)            yield from file_like  # (3)     return StreamingResponse(iterfile(), media_type=&quot;video/mp4&quot;)`

1. This is the generator function. It's a "generator function" because it contains `yield` statements inside.

2. By using a `with` block, we make sure that the file-like object is closed after the generator function is done. So, after it finishes sending the response.

3. This `yield from` tells the function to iterate over that thing named `file_like`. And then, for each part iterated, yield that part as coming from this generator function.

   So, it is a generator function that transfers the "generating" work to something else internally.

   By doing it this way, we can put it in a `with` block, and that way, ensure that it is closed after finishing.

Tip

Notice that here as we are using standard `open()` that doesn't support `async` and `await`, we declare the path operation with normal `def`.

#### `FileResponse`

Asynchronously streams a file as the response.

Takes a different set of arguments to instantiate than the other response types:

- `path` - The filepath to the file to stream.
- `headers` - Any custom headers to include, as a dictionary.
- `media_type` - A string giving the media type. If unset, the filename or path will be used to infer a media type.
- `filename` - If set, this will be included in the response `Content-Disposition`.

File responses will include appropriate `Content-Length`, `Last-Modified` and `ETag` headers.

`from fastapi import FastAPI from fastapi.responses import FileResponse some_file_path = &quot;large-video-file.mp4&quot; app = FastAPI()  @app.get(&quot;/&quot;) async def main():     return FileResponse(some_file_path)`

You can also use the `response_class` parameter:

`from fastapi import FastAPI from fastapi.responses import FileResponse some_file_path = &quot;large-video-file.mp4&quot; app = FastAPI()  @app.get(&quot;/&quot;, response_class=FileResponse) async def main():     return some_file_path`

In this case, you can return the file path directly from your *path operation* function.

### Custom response class

You can create your own custom response class, inheriting from `Response` and using it.

For example, let's say that you want to use `orjson`, but with some custom settings not used in the included `ORJSONResponse` class.

Let's say you want it to return indented and formatted JSON, so you want to use the orjson option `orjson.OPT_INDENT_2`.

You could create a `CustomORJSONResponse`. The main thing you have to do is create a `Response.render(content)` method that returns the content as `bytes`:

`from typing import Any  import orjson from fastapi import FastAPI, Response  app = FastAPI()  class CustomORJSONResponse(Response):     media_type = &quot;application/json&quot;     def render(self, content: Any) -&gt; bytes:        assert orjson is not None, &quot;orjson must be installed&quot;        return orjson.dumps(content, option=orjson.OPT_INDENT_2)  @app.get(&quot;/&quot;, response_class=CustomORJSONResponse) async def main():     return {&quot;message&quot;: &quot;Hello World&quot;}`

Now instead of returning:

`{&quot;message&quot;: &quot;Hello World&quot;}`

...this response will return:

`{   &quot;message&quot;: &quot;Hello World&quot; }`

Of course, you will probably find much better ways to take advantage of this than formatting JSON. 😉

### Default response class

When creating a **FastAPI** class instance or an `APIRouter` you can specify which response class to use by default.

The parameter that defines this is `default_response_class`.

In the example below, **FastAPI** will use `ORJSONResponse` by default, in all *path operations*, instead of `JSONResponse`.

`from fastapi import FastAPI from fastapi.responses import ORJSONResponse app = FastAPI(default_response_class=ORJSONResponse)  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;item_id&quot;: &quot;Foo&quot;}]`

Tip

You can still override `response_class` in *path operations* as before.

### Additional documentation

You can also declare the media type and many other details in OpenAPI using `responses`: Additional Responses in OpenAPI.




### Use a `Response` parameter

You can declare a parameter of type `Response` in your *path operation function*.

And then you can set cookies in that *temporal* response object.

`from fastapi import FastAPI, Response app = FastAPI()  @app.post(&quot;/cookie-and-object/&quot;) def create_cookie(response: Response):     response.set_cookie(key=&quot;fakesession&quot;, value=&quot;fake-cookie-session-value&quot;)    return {&quot;message&quot;: &quot;Come to the dark side, we have cookies&quot;}`

And then you can return any object you need, as you normally would (a `dict`, a database model, etc).

And if you declared a `response_model`, it will still be used to filter and convert the object you returned.

**FastAPI** will use that *temporal* response to extract the cookies (also headers and status code), and will put them in the final response that contains the value you returned, filtered by any `response_model`.

You can also declare the `Response` parameter in dependencies, and set cookies (and headers) in them.

### Return a `Response` directly

You can also create cookies when returning a `Response` directly in your code.

To do that, you can create a response as described in Return a Response Directly.

Then set Cookies in it, and then return it:

`from fastapi import FastAPI from fastapi.responses import JSONResponse  app = FastAPI()  @app.post(&quot;/cookie/&quot;) def create_cookie():     content = {&quot;message&quot;: &quot;Come to the dark side, we have cookies&quot;}     response = JSONResponse(content=content)    response.set_cookie(key=&quot;fakesession&quot;, value=&quot;fake-cookie-session-value&quot;)    return response`

Tip

Have in mind that if you return a response directly instead of using the `Response` parameter, FastAPI will return it directly.

So, you will have to make sure your data is of the correct type. E.g. it is compatible with JSON, if you are returning a `JSONResponse`.

And also that you are not sending any data that should have been filtered by a `response_model`.

#### More info

Technical Details

You could also use `from starlette.responses import Response` or `from starlette.responses import JSONResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

And as the `Response` can be used frequently to set headers and cookies, **FastAPI** also provides it at `fastapi.Response`.

To see all the available parameters and options, check the documentation in Starlette.




### Parameterized dependencies

All the dependencies we have seen are a fixed function or class.

But there could be cases where you want to be able to set parameters on the dependency, without having to declare many different functions or classes.

Let's imagine that we want to have a dependency that checks if the query parameter `q` contains some fixed content.

But we want to be able to parameterize that fixed content.

### A "callable" instance

In Python there's a way to make an instance of a class a "callable".

Not the class itself (which is already a callable), but an instance of that class.

To do that, we declare a method `__call__`:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI  app = FastAPI()  class FixedContentQueryChecker:     def __init__(self, fixed_content: str):         self.fixed_content = fixed_content      def __call__(self, q: str = &quot;&quot;):        if q:             return self.fixed_content in q         return False  checker = FixedContentQueryChecker(&quot;bar&quot;)  @app.get(&quot;/query-checker/&quot;) async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):     return {&quot;fixed_content_in_query&quot;: fixed_content_included}`

`from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  class FixedContentQueryChecker:     def __init__(self, fixed_content: str):         self.fixed_content = fixed_content      def __call__(self, q: str = &quot;&quot;):        if q:             return self.fixed_content in q         return False  checker = FixedContentQueryChecker(&quot;bar&quot;)  @app.get(&quot;/query-checker/&quot;) async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):     return {&quot;fixed_content_in_query&quot;: fixed_content_included}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI  app = FastAPI()  class FixedContentQueryChecker:     def __init__(self, fixed_content: str):         self.fixed_content = fixed_content      def __call__(self, q: str = &quot;&quot;):        if q:             return self.fixed_content in q         return False  checker = FixedContentQueryChecker(&quot;bar&quot;)  @app.get(&quot;/query-checker/&quot;) async def read_query_check(fixed_content_included: bool = Depends(checker)):     return {&quot;fixed_content_in_query&quot;: fixed_content_included}`

In this case, this `__call__` is what **FastAPI** will use to check for additional parameters and sub-dependencies, and this is what will be called to pass a value to the parameter in your *path operation function* later.

### Parameterize the instance

And now, we can use `__init__` to declare the parameters of the instance that we can use to "parameterize" the dependency:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI  app = FastAPI()  class FixedContentQueryChecker:     def __init__(self, fixed_content: str):        self.fixed_content = fixed_content      def __call__(self, q: str = &quot;&quot;):         if q:             return self.fixed_content in q         return False  checker = FixedContentQueryChecker(&quot;bar&quot;)  @app.get(&quot;/query-checker/&quot;) async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):     return {&quot;fixed_content_in_query&quot;: fixed_content_included}`

`from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  class FixedContentQueryChecker:     def __init__(self, fixed_content: str):        self.fixed_content = fixed_content      def __call__(self, q: str = &quot;&quot;):         if q:             return self.fixed_content in q         return False  checker = FixedContentQueryChecker(&quot;bar&quot;)  @app.get(&quot;/query-checker/&quot;) async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):     return {&quot;fixed_content_in_query&quot;: fixed_content_included}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI  app = FastAPI()  class FixedContentQueryChecker:     def __init__(self, fixed_content: str):        self.fixed_content = fixed_content      def __call__(self, q: str = &quot;&quot;):         if q:             return self.fixed_content in q         return False  checker = FixedContentQueryChecker(&quot;bar&quot;)  @app.get(&quot;/query-checker/&quot;) async def read_query_check(fixed_content_included: bool = Depends(checker)):     return {&quot;fixed_content_in_query&quot;: fixed_content_included}`

In this case, **FastAPI** won't ever touch or care about `__init__`, we will use it directly in our code.

### Create an instance

We could create an instance of this class with:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI  app = FastAPI()  class FixedContentQueryChecker:     def __init__(self, fixed_content: str):         self.fixed_content = fixed_content      def __call__(self, q: str = &quot;&quot;):         if q:             return self.fixed_content in q         return False  checker = FixedContentQueryChecker(&quot;bar&quot;)  @app.get(&quot;/query-checker/&quot;) async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):     return {&quot;fixed_content_in_query&quot;: fixed_content_included}`

`from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  class FixedContentQueryChecker:     def __init__(self, fixed_content: str):         self.fixed_content = fixed_content      def __call__(self, q: str = &quot;&quot;):         if q:             return self.fixed_content in q         return False  checker = FixedContentQueryChecker(&quot;bar&quot;)  @app.get(&quot;/query-checker/&quot;) async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):     return {&quot;fixed_content_in_query&quot;: fixed_content_included}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI  app = FastAPI()  class FixedContentQueryChecker:     def __init__(self, fixed_content: str):         self.fixed_content = fixed_content      def __call__(self, q: str = &quot;&quot;):         if q:             return self.fixed_content in q         return False  checker = FixedContentQueryChecker(&quot;bar&quot;)  @app.get(&quot;/query-checker/&quot;) async def read_query_check(fixed_content_included: bool = Depends(checker)):     return {&quot;fixed_content_in_query&quot;: fixed_content_included}`

And that way we are able to "parameterize" our dependency, that now has `&quot;bar&quot;` inside of it, as the attribute `checker.fixed_content`.

### Use the instance as a dependency

Then, we could use this `checker` in a `Depends(checker)`, instead of `Depends(FixedContentQueryChecker)`, because the dependency is the instance, `checker`, not the class itself.

And when solving the dependency, **FastAPI** will call this `checker` like:

...and pass whatever that returns as the value of the dependency in our *path operation function* as the parameter `fixed_content_included`:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI  app = FastAPI()  class FixedContentQueryChecker:     def __init__(self, fixed_content: str):         self.fixed_content = fixed_content      def __call__(self, q: str = &quot;&quot;):         if q:             return self.fixed_content in q         return False  checker = FixedContentQueryChecker(&quot;bar&quot;)  @app.get(&quot;/query-checker/&quot;) async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):     return {&quot;fixed_content_in_query&quot;: fixed_content_included}`

`from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  class FixedContentQueryChecker:     def __init__(self, fixed_content: str):         self.fixed_content = fixed_content      def __call__(self, q: str = &quot;&quot;):         if q:             return self.fixed_content in q         return False  checker = FixedContentQueryChecker(&quot;bar&quot;)  @app.get(&quot;/query-checker/&quot;) async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):     return {&quot;fixed_content_in_query&quot;: fixed_content_included}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI  app = FastAPI()  class FixedContentQueryChecker:     def __init__(self, fixed_content: str):         self.fixed_content = fixed_content      def __call__(self, q: str = &quot;&quot;):         if q:             return self.fixed_content in q         return False  checker = FixedContentQueryChecker(&quot;bar&quot;)  @app.get(&quot;/query-checker/&quot;) async def read_query_check(fixed_content_included: bool = Depends(checker)):     return {&quot;fixed_content_in_query&quot;: fixed_content_included}`

Tip

All this might seem contrived. And it might not be very clear how is it useful yet.

These examples are intentionally simple, but show how it all works.

In the chapters about security, there are utility functions that are implemented in this same way.

If you understood all this, you already know how those utility tools for security work underneath.




Up to now, you have been declaring the parts of the request that you need with their types.

Taking data from:

- The path as parameters.
- Headers.
- Cookies.
- etc.

And by doing so, **FastAPI** is validating that data, converting it and generating documentation for your API automatically.

But there are situations where you might need to access the `Request` object directly.

### Details about the `Request` object

As **FastAPI** is actually **Starlette** underneath, with a layer of several tools on top, you can use Starlette's `Request` object directly when you need to.

It would also mean that if you get data from the `Request` object directly (for example, read the body) it won't be validated, converted or documented (with OpenAPI, for the automatic API user interface) by FastAPI.

Although any other parameter declared normally (for example, the body with a Pydantic model) would still be validated, converted, annotated, etc.

But there are specific cases where it's useful to get the `Request` object.

### Use the `Request` object directly

Let's imagine you want to get the client's IP address/host inside of your *path operation function*.

For that you need to access the request directly.

`from fastapi import FastAPI, Request app = FastAPI()  @app.get(&quot;/items/{item_id}&quot;) def read_root(item_id: str, request: Request):     client_host = request.client.host    return {&quot;client_host&quot;: client_host, &quot;item_id&quot;: item_id}`

By declaring a *path operation function* parameter with the type being the `Request` **FastAPI** will know to pass the `Request` in that parameter.

Tip

Note that in this case, we are declaring a path parameter beside the request parameter.

So, the path parameter will be extracted, validated, converted to the specified type and annotated with OpenAPI.

The same way, you can declare any other parameter as normally, and additionally, get the `Request` too.

### `Request` documentation

You can read more details about the `Request` object in the official Starlette documentation site.

Technical Details

You could also use `from starlette.requests import Request`.

**FastAPI** provides it directly just as a convenience for you, the developer. But it comes directly from Starlette.




If you need to have two independent FastAPI applications, with their own independent OpenAPI and their own docs UIs, you can have a main app and "mount" one (or more) sub-application(s).

### Mounting a **FastAPI** application

"Mounting" means adding a completely "independent" application in a specific path, that then takes care of handling everything under that path, with the *path operations* declared in that sub-application.

#### Top-level application

First, create the main, top-level, **FastAPI** application, and its *path operations*:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/app&quot;) def read_main():     return {&quot;message&quot;: &quot;Hello World from main app&quot;}  subapi = FastAPI()  @subapi.get(&quot;/sub&quot;) def read_sub():     return {&quot;message&quot;: &quot;Hello World from sub API&quot;}  app.mount(&quot;/subapi&quot;, subapi)`

#### Sub-application

Then, create your sub-application, and its *path operations*.

This sub-application is just another standard FastAPI application, but this is the one that will be "mounted":

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/app&quot;) def read_main():     return {&quot;message&quot;: &quot;Hello World from main app&quot;}  subapi = FastAPI()  @subapi.get(&quot;/sub&quot;) def read_sub():     return {&quot;message&quot;: &quot;Hello World from sub API&quot;}  app.mount(&quot;/subapi&quot;, subapi)`

#### Mount the sub-application

In your top-level application, `app`, mount the sub-application, `subapi`.

In this case, it will be mounted at the path `/subapi`:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/app&quot;) def read_main():     return {&quot;message&quot;: &quot;Hello World from main app&quot;}  subapi = FastAPI()  @subapi.get(&quot;/sub&quot;) def read_sub():     return {&quot;message&quot;: &quot;Hello World from sub API&quot;}  app.mount(&quot;/subapi&quot;, subapi)`

#### Check the automatic API docs

Now, run `uvicorn` with the main app, if your file is `main.py`, it would be:

`$ uvicorn main:app --reload  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

And open the docs at http://127.0.0.1:8000/docs.

You will see the automatic API docs for the main app, including only its own *path operations*:

<image @ https://fastapi.tiangolo.com/img/tutorial/sub-applications/image01.png>

And then, open the docs for the sub-application, at http://127.0.0.1:8000/subapi/docs.

You will see the automatic API docs for the sub-application, including only its own *path operations*, all under the correct sub-path prefix `/subapi`:

<image @ https://fastapi.tiangolo.com/img/tutorial/sub-applications/image02.png>

If you try interacting with any of the two user interfaces, they will work correctly, because the browser will be able to talk to each specific app or sub-app.

#### Technical Details: `root_path`

When you mount a sub-application as described above, FastAPI will take care of communicating the mount path for the sub-application using a mechanism from the ASGI specification called a `root_path`.

That way, the sub-application will know to use that path prefix for the docs UI.

And the sub-application could also have its own mounted sub-applications and everything would work correctly, because FastAPI handles all these `root_path`s automatically.

You will learn more about the `root_path` and how to use it explicitly in the section about Behind a Proxy.




FastAPI is built on top of **Pydantic**, and I have been showing you how to use Pydantic models to declare requests and responses.

But FastAPI also supports using `dataclasses` the same way:

`from dataclasses import dataclass from typing import Union  from fastapi import FastAPI  @dataclass class Item:     name: str    price: float    description: Union[str, None] = None    tax: Union[float, None] = None  app = FastAPI()  @app.post(&quot;/items/&quot;) async def create_item(item: Item):     return item`

This is still supported thanks to **Pydantic**, as it has internal support for `dataclasses`.

So, even with the code above that doesn't use Pydantic explicitly, FastAPI is using Pydantic to convert those standard dataclasses to Pydantic's own flavor of dataclasses.

And of course, it supports the same:

- data validation
- data serialization
- data documentation, etc.

This works the same way as with Pydantic models. And it is actually achieved in the same way underneath, using Pydantic.

Info

Have in mind that dataclasses can't do everything Pydantic models can do.

So, you might still need to use Pydantic models.

But if you have a bunch of dataclasses laying around, this is a nice trick to use them to power a web API using FastAPI. 🤓

### Dataclasses in `response_model`

You can also use `dataclasses` in the `response_model` parameter:

`from dataclasses import dataclass, field from typing import List, Union  from fastapi import FastAPI  @dataclass class Item:     name: str    price: float    tags: List[str] = field(default_factory=list)    description: Union[str, None] = None    tax: Union[float, None] = None  app = FastAPI()  @app.get(&quot;/items/next&quot;, response_model=Item) async def read_next_item():     return {         &quot;name&quot;: &quot;Island In The Moon&quot;,         &quot;price&quot;: 12.99,         &quot;description&quot;: &quot;A place to be be playin' and havin' fun&quot;,         &quot;tags&quot;: [&quot;breater&quot;],     }`

The dataclass will be automatically converted to a Pydantic dataclass.

This way, its schema will show up in the API docs user interface:

<image @ https://fastapi.tiangolo.com/img/tutorial/dataclasses/image01.png>

### Dataclasses in Nested Data Structures

You can also combine `dataclasses` with other type annotations to make nested data structures.

In some cases, you might still have to use Pydantic's version of `dataclasses`. For example, if you have errors with the automatically generated API documentation.

In that case, you can simply swap the standard `dataclasses` with `pydantic.dataclasses`, which is a drop-in replacement:

`from dataclasses import field  # (1) from typing import List, Union  from fastapi import FastAPI from pydantic.dataclasses import dataclass  # (2)  @dataclass class Item:     name: str    description: Union[str, None] = None  @dataclass class Author:     name: str    items: List[Item] = field(default_factory=list)  # (3)  app = FastAPI()  @app.post(&quot;/authors/{author_id}/items/&quot;, response_model=Author)  # (4) async def create_author_items(author_id: str, items: List[Item]):  # (5)     return {&quot;name&quot;: author_id, &quot;items&quot;: items}  # (6)  @app.get(&quot;/authors/&quot;, response_model=List[Author])  # (7) def get_authors():  # (8)     return [  # (9)         {             &quot;name&quot;: &quot;Breaters&quot;,             &quot;items&quot;: [                 {                     &quot;name&quot;: &quot;Island In The Moon&quot;,                     &quot;description&quot;: &quot;A place to be be playin' and havin' fun&quot;,                 },                 {&quot;name&quot;: &quot;Holy Buddies&quot;},             ],         },         {             &quot;name&quot;: &quot;System of an Up&quot;,             &quot;items&quot;: [                 {                     &quot;name&quot;: &quot;Salt&quot;,                     &quot;description&quot;: &quot;The kombucha mushroom people's favorite&quot;,                 },                 {&quot;name&quot;: &quot;Pad Thai&quot;},                 {                     &quot;name&quot;: &quot;Lonely Night&quot;,                     &quot;description&quot;: &quot;The mostests lonliest nightiest of allest&quot;,                 },             ],         },     ]`

1. We still import `field` from standard `dataclasses`.

2. `pydantic.dataclasses` is a drop-in replacement for `dataclasses`.

3. The `Author` dataclass includes a list of `Item` dataclasses.

4. The `Author` dataclass is used as the `response_model` parameter.

5. You can use other standard type annotations with dataclasses as the request body.

   In this case, it's a list of `Item` dataclasses.

6. Here we are returning a dictionary that contains `items` which is a list of dataclasses.

   FastAPI is still capable of serializing the data to JSON.

7. Here the `response_model` is using a type annotation of a list of `Author` dataclasses.

   Again, you can combine `dataclasses` with standard type annotations.

8. Notice that this *path operation function* uses regular `def` instead of `async def`.

   As always, in FastAPI you can combine `def` and `async def` as needed.

   If you need a refresher about when to use which, check out the section *"In a hurry?"* in the docs about `async` and `await`.

9. This *path operation function* is not returning dataclasses (although it could), but a list of dictionaries with internal data.

   FastAPI will use the `response_model` parameter (that includes dataclasses) to convert the response.

You can combine `dataclasses` with other type annotations in many different combinations to form complex data structures.

Check the in-code annotation tips above to see more specific details.

### Learn More

You can also combine `dataclasses` with other Pydantic models, inherit from them, include them in your own models, etc.

To learn more, check the Pydantic docs about dataclasses.

### Version

This is available since FastAPI version `0.67.0`. 🔖




In some situations, you might need to use a **proxy** server like Traefik or Nginx with a configuration that adds an extra path prefix that is not seen by your application.

In these cases you can use `root_path` to configure your application.

The `root_path` is a mechanism provided by the ASGI specification (that FastAPI is built on, through Starlette).

The `root_path` is used to handle these specific cases.

And it's also used internally when mounting sub-applications.

### Proxy with a stripped path prefix

Having a proxy with a stripped path prefix, in this case, means that you could declare a path at `/app` in your code, but then, you add a layer on top (the proxy) that would put your **FastAPI** application under a path like `/api/v1`.

In this case, the original path `/app` would actually be served at `/api/v1/app`.

Even though all your code is written assuming there's just `/app`.

And the proxy would be **"stripping"** the **path prefix** on the fly before transmitting the request to Uvicorn, keep your application convinced that it is serving at `/app`, so that you don't have to update all your code to include the prefix `/api/v1`.

Up to here, everything would work as normally.

But then, when you open the integrated docs UI (the frontend), it would expect to get the OpenAPI schema at `/openapi.json`, instead of `/api/v1/openapi.json`.

So, the frontend (that runs in the browser) would try to reach `/openapi.json` and wouldn't be able to get the OpenAPI schema.

Because we have a proxy with a path prefix of `/api/v1` for our app, the frontend needs to fetch the OpenAPI schema at `/api/v1/openapi.json`.

```
graph LR

browser("Browser")
proxy["Proxy on http://0.0.0.0:9999/api/v1/app"]
server["Server on http://127.0.0.1:8000/app"]

browser --> proxy
proxy --> server
```

Tip

The IP `0.0.0.0` is commonly used to mean that the program listens on all the IPs available in that machine/server.

The docs UI would also need the OpenAPI schema to declare that this API `server` is located at `/api/v1` (behind the proxy). For example:

`{     &quot;openapi&quot;: &quot;3.1.0&quot;,     // More stuff here     &quot;servers&quot;: [        {            &quot;url&quot;: &quot;/api/v1&quot;        }    ],    &quot;paths&quot;: {             // More stuff here     } }`

In this example, the "Proxy" could be something like **Traefik**. And the server would be something like **Uvicorn**, running your FastAPI application.

#### Providing the `root_path`

To achieve this, you can use the command line option `--root-path` like:

`$ uvicorn main:app --root-path /api/v1  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

If you use Hypercorn, it also has the option `--root-path`.

Technical Details

The ASGI specification defines a `root_path` for this use case.

And the `--root-path` command line option provides that `root_path`.

#### Checking the current `root_path`

You can get the current `root_path` used by your application for each request, it is part of the `scope` dictionary (that's part of the ASGI spec).

Here we are including it in the message just for demonstration purposes.

`from fastapi import FastAPI, Request  app = FastAPI()  @app.get(&quot;/app&quot;) def read_main(request: Request):     return {&quot;message&quot;: &quot;Hello World&quot;, &quot;root_path&quot;: request.scope.get(&quot;root_path&quot;)}`

Then, if you start Uvicorn with:

`$ uvicorn main:app --root-path /api/v1  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

The response would be something like:

`{     &quot;message&quot;: &quot;Hello World&quot;,     &quot;root_path&quot;: &quot;/api/v1&quot; }`

#### Setting the `root_path` in the FastAPI app

Alternatively, if you don't have a way to provide a command line option like `--root-path` or equivalent, you can set the `root_path` parameter when creating your FastAPI app:

`from fastapi import FastAPI, Request  app = FastAPI(root_path=&quot;/api/v1&quot;)  @app.get(&quot;/app&quot;) def read_main(request: Request):     return {&quot;message&quot;: &quot;Hello World&quot;, &quot;root_path&quot;: request.scope.get(&quot;root_path&quot;)}`

Passing the `root_path` to `FastAPI` would be the equivalent of passing the `--root-path` command line option to Uvicorn or Hypercorn.

#### About `root_path`

Have in mind that the server (Uvicorn) won't use that `root_path` for anything else than passing it to the app.

But if you go with your browser to http://127.0.0.1:8000/app you will see the normal response:

`{     &quot;message&quot;: &quot;Hello World&quot;,     &quot;root_path&quot;: &quot;/api/v1&quot; }`

So, it won't expect to be accessed at `http://127.0.0.1:8000/api/v1/app`.

Uvicorn will expect the proxy to access Uvicorn at `http://127.0.0.1:8000/app`, and then it would be the proxy's responsibility to add the extra `/api/v1` prefix on top.

### About proxies with a stripped path prefix

Have in mind that a proxy with stripped path prefix is only one of the ways to configure it.

Probably in many cases the default will be that the proxy doesn't have a stripped path prefix.

In a case like that (without a stripped path prefix), the proxy would listen on something like `https://myawesomeapp.com`, and then if the browser goes to `https://myawesomeapp.com/api/v1/app` and your server (e.g. Uvicorn) listens on `http://127.0.0.1:8000` the proxy (without a stripped path prefix) would access Uvicorn at the same path: `http://127.0.0.1:8000/api/v1/app`.

### Testing locally with Traefik

You can easily run the experiment locally with a stripped path prefix using Traefik.

Download Traefik, it's a single binary, you can extract the compressed file and run it directly from the terminal.

Then create a file `traefik.toml` with:

`[entryPoints]   [entryPoints.http]     address = &quot;:9999&quot; [providers]   [providers.file]     filename = &quot;routes.toml&quot;`

This tells Traefik to listen on port 9999 and to use another file `routes.toml`.

Tip

We are using port 9999 instead of the standard HTTP port 80 so that you don't have to run it with admin (`sudo`) privileges.

Now create that other file `routes.toml`:

`[http]   [http.middlewares]      [http.middlewares.api-stripprefix.stripPrefix]       prefixes = [&quot;/api/v1&quot;]   [http.routers]      [http.routers.app-http]       entryPoints = [&quot;http&quot;]       service = &quot;app&quot;       rule = &quot;PathPrefix(`/api/v1`)&quot;      middlewares = [&quot;api-stripprefix&quot;]    [http.services]      [http.services.app]       [http.services.app.loadBalancer]         [[http.services.app.loadBalancer.servers]]           url = &quot;http://127.0.0.1:8000&quot;`

This file configures Traefik to use the path prefix `/api/v1`.

And then it will redirect its requests to your Uvicorn running on `http://127.0.0.1:8000`.

Now start Traefik:

`$ ./traefik --configFile=traefik.toml  INFO[0000] Configuration loaded from file: /home/user/awesomeapi/traefik.toml`

And now start your app with Uvicorn, using the `--root-path` option:

`$ uvicorn main:app --root-path /api/v1  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

#### Check the responses

Now, if you go to the URL with the port for Uvicorn: http://127.0.0.1:8000/app, you will see the normal response:

`{     &quot;message&quot;: &quot;Hello World&quot;,     &quot;root_path&quot;: &quot;/api/v1&quot; }`

Tip

Notice that even though you are accessing it at `http://127.0.0.1:8000/app` it shows the `root_path` of `/api/v1`, taken from the option `--root-path`.

And now open the URL with the port for Traefik, including the path prefix: http://127.0.0.1:9999/api/v1/app.

We get the same response:

`{     &quot;message&quot;: &quot;Hello World&quot;,     &quot;root_path&quot;: &quot;/api/v1&quot; }`

but this time at the URL with the prefix path provided by the proxy: `/api/v1`.

Of course, the idea here is that everyone would access the app through the proxy, so the version with the path prefix `/api/v1` is the "correct" one.

And the version without the path prefix (`http://127.0.0.1:8000/app`), provided by Uvicorn directly, would be exclusively for the *proxy* (Traefik) to access it.

That demonstrates how the Proxy (Traefik) uses the path prefix and how the server (Uvicorn) uses the `root_path` from the option `--root-path`.

#### Check the docs UI

But here's the fun part. ✨

The "official" way to access the app would be through the proxy with the path prefix that we defined. So, as we would expect, if you try the docs UI served by Uvicorn directly, without the path prefix in the URL, it won't work, because it expects to be accessed through the proxy.

You can check it at http://127.0.0.1:8000/docs:

<image @ https://fastapi.tiangolo.com/img/tutorial/behind-a-proxy/image01.png>

But if we access the docs UI at the "official" URL using the proxy with port `9999`, at `/api/v1/docs`, it works correctly! 🎉

You can check it at http://127.0.0.1:9999/api/v1/docs:

<image @ https://fastapi.tiangolo.com/img/tutorial/behind-a-proxy/image02.png>

Right as we wanted it. ✔️

This is because FastAPI uses this `root_path` to create the default `server` in OpenAPI with the URL provided by `root_path`.

### Additional servers

Warning

This is a more advanced use case. Feel free to skip it.

By default, **FastAPI** will create a `server` in the OpenAPI schema with the URL for the `root_path`.

But you can also provide other alternative `servers`, for example if you want *the same* docs UI to interact with a staging and production environments.

If you pass a custom list of `servers` and there's a `root_path` (because your API lives behind a proxy), **FastAPI** will insert a "server" with this `root_path` at the beginning of the list.

For example:

`from fastapi import FastAPI, Request  app = FastAPI(     servers=[        {&quot;url&quot;: &quot;https://stag.example.com&quot;, &quot;description&quot;: &quot;Staging environment&quot;},        {&quot;url&quot;: &quot;https://prod.example.com&quot;, &quot;description&quot;: &quot;Production environment&quot;},    ],    root_path=&quot;/api/v1&quot;, )  @app.get(&quot;/app&quot;) def read_main(request: Request):     return {&quot;message&quot;: &quot;Hello World&quot;, &quot;root_path&quot;: request.scope.get(&quot;root_path&quot;)}`

Will generate an OpenAPI schema like:

`{     &quot;openapi&quot;: &quot;3.1.0&quot;,     // More stuff here     &quot;servers&quot;: [         {            &quot;url&quot;: &quot;/api/v1&quot;        },        {             &quot;url&quot;: &quot;https://stag.example.com&quot;,             &quot;description&quot;: &quot;Staging environment&quot;         },         {             &quot;url&quot;: &quot;https://prod.example.com&quot;,             &quot;description&quot;: &quot;Production environment&quot;         }     ],     &quot;paths&quot;: {             // More stuff here     } }`

Tip

Notice the auto-generated server with a `url` value of `/api/v1`, taken from the `root_path`.

In the docs UI at http://127.0.0.1:9999/api/v1/docs it would look like:

<image @ https://fastapi.tiangolo.com/img/tutorial/behind-a-proxy/image03.png>

Tip

The docs UI will interact with the server that you select.

#### Disable automatic server from `root_path`

If you don't want **FastAPI** to include an automatic server using the `root_path`, you can use the parameter `root_path_in_servers=False`:

`from fastapi import FastAPI, Request  app = FastAPI(     servers=[         {&quot;url&quot;: &quot;https://stag.example.com&quot;, &quot;description&quot;: &quot;Staging environment&quot;},         {&quot;url&quot;: &quot;https://prod.example.com&quot;, &quot;description&quot;: &quot;Production environment&quot;},     ],     root_path=&quot;/api/v1&quot;,     root_path_in_servers=False, )  @app.get(&quot;/app&quot;) def read_main(request: Request):     return {&quot;message&quot;: &quot;Hello World&quot;, &quot;root_path&quot;: request.scope.get(&quot;root_path&quot;)}`

and then it won't include it in the OpenAPI schema.

### Mounting a sub-application

If you need to mount a sub-application (as described in Sub Applications - Mounts) while also using a proxy with `root_path`, you can do it normally, as you would expect.

FastAPI will internally use the `root_path` smartly, so it will just work. ✨




You can use WebSockets with **FastAPI**.

### Install `WebSockets`

First you need to install `WebSockets`:

`$ pip install websockets  ---&gt; 100%`

### WebSockets client

#### In production

In your production system, you probably have a frontend created with a modern framework like React, Vue.js or Angular.

And to communicate using WebSockets with your backend you would probably use your frontend's utilities.

Or you might have a native mobile application that communicates with your WebSocket backend directly, in native code.

Or you might have any other way to communicate with the WebSocket endpoint.

***

But for this example, we'll use a very simple HTML document with some JavaScript, all inside a long string.

This, of course, is not optimal and you wouldn't use it for production.

In production you would have one of the options above.

But it's the simplest way to focus on the server-side of WebSockets and have a working example:

`from fastapi import FastAPI, WebSocket from fastapi.responses import HTMLResponse app = FastAPI()  html = &quot;&quot;&quot; &lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;        &lt;title&gt;Chat&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;WebSocket Chat&lt;/h1&gt;        &lt;form action=&quot;&quot; onsubmit=&quot;sendMessage(event)&quot;&gt;            &lt;input type=&quot;text&quot; id=&quot;messageText&quot; autocomplete=&quot;off&quot;/&gt;            &lt;button&gt;Send&lt;/button&gt;        &lt;/form&gt;        &lt;ul id='messages'&gt;        &lt;/ul&gt;        &lt;script&gt;            var ws = new WebSocket(&quot;ws://localhost:8000/ws&quot;);            ws.onmessage = function(event) {                var messages = document.getElementById('messages')                var message = document.createElement('li')                var content = document.createTextNode(event.data)                message.appendChild(content)                messages.appendChild(message)            };            function sendMessage(event) {                var input = document.getElementById(&quot;messageText&quot;)                ws.send(input.value)                input.value = ''                event.preventDefault()            }        &lt;/script&gt;    &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;  @app.get(&quot;/&quot;) async def get():     return HTMLResponse(html)  @app.websocket(&quot;/ws&quot;) async def websocket_endpoint(websocket: WebSocket):     await websocket.accept()     while True:         data = await websocket.receive_text()         await websocket.send_text(f&quot;Message text was: {data}&quot;)`

### Create a `websocket`

In your **FastAPI** application, create a `websocket`:

`from fastapi import FastAPI, WebSocket from fastapi.responses import HTMLResponse  app = FastAPI()  html = &quot;&quot;&quot; &lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;         &lt;title&gt;Chat&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;h1&gt;WebSocket Chat&lt;/h1&gt;         &lt;form action=&quot;&quot; onsubmit=&quot;sendMessage(event)&quot;&gt;             &lt;input type=&quot;text&quot; id=&quot;messageText&quot; autocomplete=&quot;off&quot;/&gt;             &lt;button&gt;Send&lt;/button&gt;         &lt;/form&gt;         &lt;ul id='messages'&gt;         &lt;/ul&gt;         &lt;script&gt;             var ws = new WebSocket(&quot;ws://localhost:8000/ws&quot;);             ws.onmessage = function(event) {                 var messages = document.getElementById('messages')                 var message = document.createElement('li')                 var content = document.createTextNode(event.data)                 message.appendChild(content)                 messages.appendChild(message)             };             function sendMessage(event) {                 var input = document.getElementById(&quot;messageText&quot;)                 ws.send(input.value)                 input.value = ''                 event.preventDefault()             }         &lt;/script&gt;     &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;  @app.get(&quot;/&quot;) async def get():     return HTMLResponse(html)  @app.websocket(&quot;/ws&quot;) async def websocket_endpoint(websocket: WebSocket):     await websocket.accept()     while True:         data = await websocket.receive_text()         await websocket.send_text(f&quot;Message text was: {data}&quot;)`

Technical Details

You could also use `from starlette.websockets import WebSocket`.

**FastAPI** provides the same `WebSocket` directly just as a convenience for you, the developer. But it comes directly from Starlette.

### Await for messages and send messages

In your WebSocket route you can `await` for messages and send messages.

`from fastapi import FastAPI, WebSocket from fastapi.responses import HTMLResponse  app = FastAPI()  html = &quot;&quot;&quot; &lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;         &lt;title&gt;Chat&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;h1&gt;WebSocket Chat&lt;/h1&gt;         &lt;form action=&quot;&quot; onsubmit=&quot;sendMessage(event)&quot;&gt;             &lt;input type=&quot;text&quot; id=&quot;messageText&quot; autocomplete=&quot;off&quot;/&gt;             &lt;button&gt;Send&lt;/button&gt;         &lt;/form&gt;         &lt;ul id='messages'&gt;         &lt;/ul&gt;         &lt;script&gt;             var ws = new WebSocket(&quot;ws://localhost:8000/ws&quot;);             ws.onmessage = function(event) {                 var messages = document.getElementById('messages')                 var message = document.createElement('li')                 var content = document.createTextNode(event.data)                 message.appendChild(content)                 messages.appendChild(message)             };             function sendMessage(event) {                 var input = document.getElementById(&quot;messageText&quot;)                 ws.send(input.value)                 input.value = ''                 event.preventDefault()             }         &lt;/script&gt;     &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;  @app.get(&quot;/&quot;) async def get():     return HTMLResponse(html)  @app.websocket(&quot;/ws&quot;) async def websocket_endpoint(websocket: WebSocket):     await websocket.accept()    while True:        data = await websocket.receive_text()        await websocket.send_text(f&quot;Message text was: {data}&quot;)`

You can receive and send binary, text, and JSON data.

### Try it

If your file is named `main.py`, run your application with:

`$ uvicorn main:app --reload  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

Open your browser at http://127.0.0.1:8000.

You will see a simple page like:

<image @ https://fastapi.tiangolo.com/img/tutorial/websockets/image01.png>

You can type messages in the input box, and send them:

<image @ https://fastapi.tiangolo.com/img/tutorial/websockets/image02.png>

And your **FastAPI** application with WebSockets will respond back:

<image @ https://fastapi.tiangolo.com/img/tutorial/websockets/image03.png>

You can send (and receive) many messages:

<image @ https://fastapi.tiangolo.com/img/tutorial/websockets/image04.png>

And all of them will use the same WebSocket connection.

### Using `Depends` and others

In WebSocket endpoints you can import from `fastapi` and use:

- `Depends`
- `Security`
- `Cookie`
- `Header`
- `Path`
- `Query`

They work the same way as for other FastAPI endpoints/*path operations*:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import (     Cookie,     Depends,     FastAPI,     Query,     WebSocket,     WebSocketException,     status, ) from fastapi.responses import HTMLResponse  app = FastAPI()  html = &quot;&quot;&quot; &lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;         &lt;title&gt;Chat&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;h1&gt;WebSocket Chat&lt;/h1&gt;         &lt;form action=&quot;&quot; onsubmit=&quot;sendMessage(event)&quot;&gt;             &lt;label&gt;Item ID: &lt;input type=&quot;text&quot; id=&quot;itemId&quot; autocomplete=&quot;off&quot; value=&quot;foo&quot;/&gt;&lt;/label&gt;             &lt;label&gt;Token: &lt;input type=&quot;text&quot; id=&quot;token&quot; autocomplete=&quot;off&quot; value=&quot;some-key-token&quot;/&gt;&lt;/label&gt;             &lt;button onclick=&quot;connect(event)&quot;&gt;Connect&lt;/button&gt;             &lt;hr&gt;             &lt;label&gt;Message: &lt;input type=&quot;text&quot; id=&quot;messageText&quot; autocomplete=&quot;off&quot;/&gt;&lt;/label&gt;             &lt;button&gt;Send&lt;/button&gt;         &lt;/form&gt;         &lt;ul id='messages'&gt;         &lt;/ul&gt;         &lt;script&gt;         var ws = null;             function connect(event) {                 var itemId = document.getElementById(&quot;itemId&quot;)                 var token = document.getElementById(&quot;token&quot;)                 ws = new WebSocket(&quot;ws://localhost:8000/items/&quot; + itemId.value + &quot;/ws?token=&quot; + token.value);                 ws.onmessage = function(event) {                     var messages = document.getElementById('messages')                     var message = document.createElement('li')                     var content = document.createTextNode(event.data)                     message.appendChild(content)                     messages.appendChild(message)                 };                 event.preventDefault()             }             function sendMessage(event) {                 var input = document.getElementById(&quot;messageText&quot;)                 ws.send(input.value)                 input.value = ''                 event.preventDefault()             }         &lt;/script&gt;     &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;  @app.get(&quot;/&quot;) async def get():     return HTMLResponse(html)  async def get_cookie_or_token(     websocket: WebSocket,     session: Annotated[str | None, Cookie()] = None,    token: Annotated[str | None, Query()] = None, ):     if session is None and token is None:         raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)     return session or token  @app.websocket(&quot;/items/{item_id}/ws&quot;) async def websocket_endpoint(     *,     websocket: WebSocket,     item_id: str,     q: int | None = None,     cookie_or_token: Annotated[str, Depends(get_cookie_or_token)], ):     await websocket.accept()     while True:         data = await websocket.receive_text()         await websocket.send_text(             f&quot;Session cookie or query token value is: {cookie_or_token}&quot;         )         if q is not None:             await websocket.send_text(f&quot;Query parameter q is: {q}&quot;)         await websocket.send_text(f&quot;Message text was: {data}, for item ID: {item_id}&quot;)`

`from typing import Annotated, Union  from fastapi import (     Cookie,     Depends,     FastAPI,     Query,     WebSocket,     WebSocketException,     status, ) from fastapi.responses import HTMLResponse  app = FastAPI()  html = &quot;&quot;&quot; &lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;         &lt;title&gt;Chat&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;h1&gt;WebSocket Chat&lt;/h1&gt;         &lt;form action=&quot;&quot; onsubmit=&quot;sendMessage(event)&quot;&gt;             &lt;label&gt;Item ID: &lt;input type=&quot;text&quot; id=&quot;itemId&quot; autocomplete=&quot;off&quot; value=&quot;foo&quot;/&gt;&lt;/label&gt;             &lt;label&gt;Token: &lt;input type=&quot;text&quot; id=&quot;token&quot; autocomplete=&quot;off&quot; value=&quot;some-key-token&quot;/&gt;&lt;/label&gt;             &lt;button onclick=&quot;connect(event)&quot;&gt;Connect&lt;/button&gt;             &lt;hr&gt;             &lt;label&gt;Message: &lt;input type=&quot;text&quot; id=&quot;messageText&quot; autocomplete=&quot;off&quot;/&gt;&lt;/label&gt;             &lt;button&gt;Send&lt;/button&gt;         &lt;/form&gt;         &lt;ul id='messages'&gt;         &lt;/ul&gt;         &lt;script&gt;         var ws = null;             function connect(event) {                 var itemId = document.getElementById(&quot;itemId&quot;)                 var token = document.getElementById(&quot;token&quot;)                 ws = new WebSocket(&quot;ws://localhost:8000/items/&quot; + itemId.value + &quot;/ws?token=&quot; + token.value);                 ws.onmessage = function(event) {                     var messages = document.getElementById('messages')                     var message = document.createElement('li')                     var content = document.createTextNode(event.data)                     message.appendChild(content)                     messages.appendChild(message)                 };                 event.preventDefault()             }             function sendMessage(event) {                 var input = document.getElementById(&quot;messageText&quot;)                 ws.send(input.value)                 input.value = ''                 event.preventDefault()             }         &lt;/script&gt;     &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;  @app.get(&quot;/&quot;) async def get():     return HTMLResponse(html)  async def get_cookie_or_token(     websocket: WebSocket,     session: Annotated[Union[str, None], Cookie()] = None,    token: Annotated[Union[str, None], Query()] = None, ):     if session is None and token is None:         raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)     return session or token  @app.websocket(&quot;/items/{item_id}/ws&quot;) async def websocket_endpoint(     *,     websocket: WebSocket,     item_id: str,     q: Union[int, None] = None,     cookie_or_token: Annotated[str, Depends(get_cookie_or_token)], ):     await websocket.accept()     while True:         data = await websocket.receive_text()         await websocket.send_text(             f&quot;Session cookie or query token value is: {cookie_or_token}&quot;         )         if q is not None:             await websocket.send_text(f&quot;Query parameter q is: {q}&quot;)         await websocket.send_text(f&quot;Message text was: {data}, for item ID: {item_id}&quot;)`

`from typing import Union  from fastapi import (     Cookie,     Depends,     FastAPI,     Query,     WebSocket,     WebSocketException,     status, ) from fastapi.responses import HTMLResponse from typing_extensions import Annotated  app = FastAPI()  html = &quot;&quot;&quot; &lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;         &lt;title&gt;Chat&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;h1&gt;WebSocket Chat&lt;/h1&gt;         &lt;form action=&quot;&quot; onsubmit=&quot;sendMessage(event)&quot;&gt;             &lt;label&gt;Item ID: &lt;input type=&quot;text&quot; id=&quot;itemId&quot; autocomplete=&quot;off&quot; value=&quot;foo&quot;/&gt;&lt;/label&gt;             &lt;label&gt;Token: &lt;input type=&quot;text&quot; id=&quot;token&quot; autocomplete=&quot;off&quot; value=&quot;some-key-token&quot;/&gt;&lt;/label&gt;             &lt;button onclick=&quot;connect(event)&quot;&gt;Connect&lt;/button&gt;             &lt;hr&gt;             &lt;label&gt;Message: &lt;input type=&quot;text&quot; id=&quot;messageText&quot; autocomplete=&quot;off&quot;/&gt;&lt;/label&gt;             &lt;button&gt;Send&lt;/button&gt;         &lt;/form&gt;         &lt;ul id='messages'&gt;         &lt;/ul&gt;         &lt;script&gt;         var ws = null;             function connect(event) {                 var itemId = document.getElementById(&quot;itemId&quot;)                 var token = document.getElementById(&quot;token&quot;)                 ws = new WebSocket(&quot;ws://localhost:8000/items/&quot; + itemId.value + &quot;/ws?token=&quot; + token.value);                 ws.onmessage = function(event) {                     var messages = document.getElementById('messages')                     var message = document.createElement('li')                     var content = document.createTextNode(event.data)                     message.appendChild(content)                     messages.appendChild(message)                 };                 event.preventDefault()             }             function sendMessage(event) {                 var input = document.getElementById(&quot;messageText&quot;)                 ws.send(input.value)                 input.value = ''                 event.preventDefault()             }         &lt;/script&gt;     &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;  @app.get(&quot;/&quot;) async def get():     return HTMLResponse(html)  async def get_cookie_or_token(     websocket: WebSocket,     session: Annotated[Union[str, None], Cookie()] = None,    token: Annotated[Union[str, None], Query()] = None, ):     if session is None and token is None:         raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)     return session or token  @app.websocket(&quot;/items/{item_id}/ws&quot;) async def websocket_endpoint(     *,     websocket: WebSocket,     item_id: str,     q: Union[int, None] = None,     cookie_or_token: Annotated[str, Depends(get_cookie_or_token)], ):     await websocket.accept()     while True:         data = await websocket.receive_text()         await websocket.send_text(             f&quot;Session cookie or query token value is: {cookie_or_token}&quot;         )         if q is not None:             await websocket.send_text(f&quot;Query parameter q is: {q}&quot;)         await websocket.send_text(f&quot;Message text was: {data}, for item ID: {item_id}&quot;)`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import (     Cookie,     Depends,     FastAPI,     Query,     WebSocket,     WebSocketException,     status, ) from fastapi.responses import HTMLResponse  app = FastAPI()  html = &quot;&quot;&quot; &lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;         &lt;title&gt;Chat&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;h1&gt;WebSocket Chat&lt;/h1&gt;         &lt;form action=&quot;&quot; onsubmit=&quot;sendMessage(event)&quot;&gt;             &lt;label&gt;Item ID: &lt;input type=&quot;text&quot; id=&quot;itemId&quot; autocomplete=&quot;off&quot; value=&quot;foo&quot;/&gt;&lt;/label&gt;             &lt;label&gt;Token: &lt;input type=&quot;text&quot; id=&quot;token&quot; autocomplete=&quot;off&quot; value=&quot;some-key-token&quot;/&gt;&lt;/label&gt;             &lt;button onclick=&quot;connect(event)&quot;&gt;Connect&lt;/button&gt;             &lt;hr&gt;             &lt;label&gt;Message: &lt;input type=&quot;text&quot; id=&quot;messageText&quot; autocomplete=&quot;off&quot;/&gt;&lt;/label&gt;             &lt;button&gt;Send&lt;/button&gt;         &lt;/form&gt;         &lt;ul id='messages'&gt;         &lt;/ul&gt;         &lt;script&gt;         var ws = null;             function connect(event) {                 var itemId = document.getElementById(&quot;itemId&quot;)                 var token = document.getElementById(&quot;token&quot;)                 ws = new WebSocket(&quot;ws://localhost:8000/items/&quot; + itemId.value + &quot;/ws?token=&quot; + token.value);                 ws.onmessage = function(event) {                     var messages = document.getElementById('messages')                     var message = document.createElement('li')                     var content = document.createTextNode(event.data)                     message.appendChild(content)                     messages.appendChild(message)                 };                 event.preventDefault()             }             function sendMessage(event) {                 var input = document.getElementById(&quot;messageText&quot;)                 ws.send(input.value)                 input.value = ''                 event.preventDefault()             }         &lt;/script&gt;     &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;  @app.get(&quot;/&quot;) async def get():     return HTMLResponse(html)  async def get_cookie_or_token(     websocket: WebSocket,     session: str | None = Cookie(default=None),    token: str | None = Query(default=None), ):     if session is None and token is None:         raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)     return session or token  @app.websocket(&quot;/items/{item_id}/ws&quot;) async def websocket_endpoint(     websocket: WebSocket,     item_id: str,     q: int | None = None,     cookie_or_token: str = Depends(get_cookie_or_token), ):     await websocket.accept()     while True:         data = await websocket.receive_text()         await websocket.send_text(             f&quot;Session cookie or query token value is: {cookie_or_token}&quot;         )         if q is not None:             await websocket.send_text(f&quot;Query parameter q is: {q}&quot;)         await websocket.send_text(f&quot;Message text was: {data}, for item ID: {item_id}&quot;)`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import (     Cookie,     Depends,     FastAPI,     Query,     WebSocket,     WebSocketException,     status, ) from fastapi.responses import HTMLResponse  app = FastAPI()  html = &quot;&quot;&quot; &lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;         &lt;title&gt;Chat&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;h1&gt;WebSocket Chat&lt;/h1&gt;         &lt;form action=&quot;&quot; onsubmit=&quot;sendMessage(event)&quot;&gt;             &lt;label&gt;Item ID: &lt;input type=&quot;text&quot; id=&quot;itemId&quot; autocomplete=&quot;off&quot; value=&quot;foo&quot;/&gt;&lt;/label&gt;             &lt;label&gt;Token: &lt;input type=&quot;text&quot; id=&quot;token&quot; autocomplete=&quot;off&quot; value=&quot;some-key-token&quot;/&gt;&lt;/label&gt;             &lt;button onclick=&quot;connect(event)&quot;&gt;Connect&lt;/button&gt;             &lt;hr&gt;             &lt;label&gt;Message: &lt;input type=&quot;text&quot; id=&quot;messageText&quot; autocomplete=&quot;off&quot;/&gt;&lt;/label&gt;             &lt;button&gt;Send&lt;/button&gt;         &lt;/form&gt;         &lt;ul id='messages'&gt;         &lt;/ul&gt;         &lt;script&gt;         var ws = null;             function connect(event) {                 var itemId = document.getElementById(&quot;itemId&quot;)                 var token = document.getElementById(&quot;token&quot;)                 ws = new WebSocket(&quot;ws://localhost:8000/items/&quot; + itemId.value + &quot;/ws?token=&quot; + token.value);                 ws.onmessage = function(event) {                     var messages = document.getElementById('messages')                     var message = document.createElement('li')                     var content = document.createTextNode(event.data)                     message.appendChild(content)                     messages.appendChild(message)                 };                 event.preventDefault()             }             function sendMessage(event) {                 var input = document.getElementById(&quot;messageText&quot;)                 ws.send(input.value)                 input.value = ''                 event.preventDefault()             }         &lt;/script&gt;     &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;  @app.get(&quot;/&quot;) async def get():     return HTMLResponse(html)  async def get_cookie_or_token(     websocket: WebSocket,     session: Union[str, None] = Cookie(default=None),    token: Union[str, None] = Query(default=None), ):     if session is None and token is None:         raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)     return session or token  @app.websocket(&quot;/items/{item_id}/ws&quot;) async def websocket_endpoint(     websocket: WebSocket,     item_id: str,     q: Union[int, None] = None,     cookie_or_token: str = Depends(get_cookie_or_token), ):     await websocket.accept()     while True:         data = await websocket.receive_text()         await websocket.send_text(             f&quot;Session cookie or query token value is: {cookie_or_token}&quot;         )         if q is not None:             await websocket.send_text(f&quot;Query parameter q is: {q}&quot;)         await websocket.send_text(f&quot;Message text was: {data}, for item ID: {item_id}&quot;)`

Info

As this is a WebSocket it doesn't really make sense to raise an `HTTPException`, instead we raise a `WebSocketException`.

You can use a closing code from the valid codes defined in the specification.

#### Try the WebSockets with dependencies

If your file is named `main.py`, run your application with:

`$ uvicorn main:app --reload  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

Open your browser at http://127.0.0.1:8000.

There you can set:

- The "Item ID", used in the path.
- The "Token" used as a query parameter.

Tip

Notice that the query `token` will be handled by a dependency.

With that you can connect the WebSocket and then send and receive messages:

<image @ https://fastapi.tiangolo.com/img/tutorial/websockets/image05.png>

### Handling disconnections and multiple clients

When a WebSocket connection is closed, the `await websocket.receive_text()` will raise a `WebSocketDisconnect` exception, which you can then catch and handle like in this example.

Python 3.9+Python 3.6+

`from fastapi import FastAPI, WebSocket, WebSocketDisconnect from fastapi.responses import HTMLResponse  app = FastAPI()  html = &quot;&quot;&quot; &lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;         &lt;title&gt;Chat&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;h1&gt;WebSocket Chat&lt;/h1&gt;         &lt;h2&gt;Your ID: &lt;span id=&quot;ws-id&quot;&gt;&lt;/span&gt;&lt;/h2&gt;         &lt;form action=&quot;&quot; onsubmit=&quot;sendMessage(event)&quot;&gt;             &lt;input type=&quot;text&quot; id=&quot;messageText&quot; autocomplete=&quot;off&quot;/&gt;             &lt;button&gt;Send&lt;/button&gt;         &lt;/form&gt;         &lt;ul id='messages'&gt;         &lt;/ul&gt;         &lt;script&gt;             var client_id = Date.now()             document.querySelector(&quot;#ws-id&quot;).textContent = client_id;             var ws = new WebSocket(`ws://localhost:8000/ws/${client_id}`);             ws.onmessage = function(event) {                 var messages = document.getElementById('messages')                 var message = document.createElement('li')                 var content = document.createTextNode(event.data)                 message.appendChild(content)                 messages.appendChild(message)             };             function sendMessage(event) {                 var input = document.getElementById(&quot;messageText&quot;)                 ws.send(input.value)                 input.value = ''                 event.preventDefault()             }         &lt;/script&gt;     &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;  class ConnectionManager:     def __init__(self):         self.active_connections: list[WebSocket] = []      async def connect(self, websocket: WebSocket):         await websocket.accept()         self.active_connections.append(websocket)      def disconnect(self, websocket: WebSocket):         self.active_connections.remove(websocket)      async def send_personal_message(self, message: str, websocket: WebSocket):         await websocket.send_text(message)      async def broadcast(self, message: str):         for connection in self.active_connections:             await connection.send_text(message)  manager = ConnectionManager()  @app.get(&quot;/&quot;) async def get():     return HTMLResponse(html)  @app.websocket(&quot;/ws/{client_id}&quot;) async def websocket_endpoint(websocket: WebSocket, client_id: int):     await manager.connect(websocket)     try:         while True:             data = await websocket.receive_text()             await manager.send_personal_message(f&quot;You wrote: {data}&quot;, websocket)             await manager.broadcast(f&quot;Client #{client_id} says: {data}&quot;)     except WebSocketDisconnect:        manager.disconnect(websocket)        await manager.broadcast(f&quot;Client #{client_id} left the chat&quot;)`

`from typing import List  from fastapi import FastAPI, WebSocket, WebSocketDisconnect from fastapi.responses import HTMLResponse  app = FastAPI()  html = &quot;&quot;&quot; &lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;         &lt;title&gt;Chat&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;h1&gt;WebSocket Chat&lt;/h1&gt;         &lt;h2&gt;Your ID: &lt;span id=&quot;ws-id&quot;&gt;&lt;/span&gt;&lt;/h2&gt;         &lt;form action=&quot;&quot; onsubmit=&quot;sendMessage(event)&quot;&gt;             &lt;input type=&quot;text&quot; id=&quot;messageText&quot; autocomplete=&quot;off&quot;/&gt;             &lt;button&gt;Send&lt;/button&gt;         &lt;/form&gt;         &lt;ul id='messages'&gt;         &lt;/ul&gt;         &lt;script&gt;             var client_id = Date.now()             document.querySelector(&quot;#ws-id&quot;).textContent = client_id;             var ws = new WebSocket(`ws://localhost:8000/ws/${client_id}`);             ws.onmessage = function(event) {                 var messages = document.getElementById('messages')                 var message = document.createElement('li')                 var content = document.createTextNode(event.data)                 message.appendChild(content)                 messages.appendChild(message)             };             function sendMessage(event) {                 var input = document.getElementById(&quot;messageText&quot;)                 ws.send(input.value)                 input.value = ''                 event.preventDefault()             }         &lt;/script&gt;     &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot;  class ConnectionManager:     def __init__(self):         self.active_connections: List[WebSocket] = []      async def connect(self, websocket: WebSocket):         await websocket.accept()         self.active_connections.append(websocket)      def disconnect(self, websocket: WebSocket):         self.active_connections.remove(websocket)      async def send_personal_message(self, message: str, websocket: WebSocket):         await websocket.send_text(message)      async def broadcast(self, message: str):         for connection in self.active_connections:             await connection.send_text(message)  manager = ConnectionManager()  @app.get(&quot;/&quot;) async def get():     return HTMLResponse(html)  @app.websocket(&quot;/ws/{client_id}&quot;) async def websocket_endpoint(websocket: WebSocket, client_id: int):     await manager.connect(websocket)     try:         while True:             data = await websocket.receive_text()             await manager.send_personal_message(f&quot;You wrote: {data}&quot;, websocket)             await manager.broadcast(f&quot;Client #{client_id} says: {data}&quot;)     except WebSocketDisconnect:        manager.disconnect(websocket)        await manager.broadcast(f&quot;Client #{client_id} left the chat&quot;)`

To try it out:

- Open the app with several browser tabs.
- Write messages from them.
- Then close one of the tabs.

That will raise the `WebSocketDisconnect` exception, and all the other clients will receive a message like:

`Client #1596980209979 left the chat`

Tip

The app above is a minimal and simple example to demonstrate how to handle and broadcast messages to several WebSocket connections.

But have in mind that, as everything is handled in memory, in a single list, it will only work while the process is running, and will only work with a single process.

If you need something easy to integrate with FastAPI but that is more robust, supported by Redis, PostgreSQL or others, check encode/broadcaster.

### More info

To learn more about the options, check Starlette's documentation for:

- The `WebSocket` class.
- Class-based WebSocket handling.




You can use any template engine you want with **FastAPI**.

A common choice is Jinja2, the same one used by Flask and other tools.

There are utilities to configure it easily that you can use directly in your **FastAPI** application (provided by Starlette).

### Install dependencies

Install `jinja2`:

`$ pip install jinja2  ---&gt; 100%`

### Using `Jinja2Templates`

- Import `Jinja2Templates`.
- Create a `templates` object that you can re-use later.
- Declare a `Request` parameter in the *path operation* that will return a template.
- Use the `templates` you created to render and return a `TemplateResponse`, passing the `request` as one of the key-value pairs in the Jinja2 "context".

`from fastapi import FastAPI, Request from fastapi.responses import HTMLResponse from fastapi.staticfiles import StaticFiles from fastapi.templating import Jinja2Templates app = FastAPI()  app.mount(&quot;/static&quot;, StaticFiles(directory=&quot;static&quot;), name=&quot;static&quot;)  templates = Jinja2Templates(directory=&quot;templates&quot;)  @app.get(&quot;/items/{id}&quot;, response_class=HTMLResponse) async def read_item(request: Request, id: str):     return templates.TemplateResponse(&quot;item.html&quot;, {&quot;request&quot;: request, &quot;id&quot;: id})`

Note

Notice that you have to pass the `request` as part of the key-value pairs in the context for Jinja2. So, you also have to declare it in your *path operation*.

Tip

By declaring `response_class=HTMLResponse` the docs UI will be able to know that the response will be HTML.

Technical Details

You could also use `from starlette.templating import Jinja2Templates`.

**FastAPI** provides the same `starlette.templating` as `fastapi.templating` just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with `Request` and `StaticFiles`.

### Writing templates

Then you can write a template at `templates/item.html` with:

`&lt;html&gt; &lt;head&gt;     &lt;title&gt;Item Details&lt;/title&gt;     &lt;link href=&quot;{{ url_for('static', path='/styles.css') }}&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt;     &lt;h1&gt;Item ID: {{ id }}&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;`

It will show the `id` taken from the "context" `dict` you passed:

`{&quot;request&quot;: request, &quot;id&quot;: id}`

### Templates and static files

And you can also use `url_for()` inside of the template, and use it, for example, with the `StaticFiles` you mounted.

`&lt;html&gt; &lt;head&gt;     &lt;title&gt;Item Details&lt;/title&gt;     &lt;link href=&quot;{{ url_for('static', path='/styles.css') }}&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt;     &lt;h1&gt;Item ID: {{ id }}&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;`

In this example, it would link to a CSS file at `static/styles.css` with:

And because you are using `StaticFiles`, that CSS file would be served automatically by your **FastAPI** application at the URL `/static/styles.css`.

### More details

For more details, including how to test templates, check Starlette's docs on templates.




1. FastAPI
2. Advanced User Guide

When you need your event handlers (`startup` and `shutdown`) to run in your tests, you can use the `TestClient` with a `with` statement:

`from fastapi import FastAPI from fastapi.testclient import TestClient  app = FastAPI()  items = {}  @app.on_event(&quot;startup&quot;) async def startup_event():     items[&quot;foo&quot;] = {&quot;name&quot;: &quot;Fighters&quot;}    items[&quot;bar&quot;] = {&quot;name&quot;: &quot;Tenders&quot;}  @app.get(&quot;/items/{item_id}&quot;) async def read_items(item_id: str):     return items[item_id]  def test_read_items():     with TestClient(app) as client:        response = client.get(&quot;/items/foo&quot;)        assert response.status_code == 200        assert response.json() == {&quot;name&quot;: &quot;Fighters&quot;}`




You can use the same `TestClient` to test WebSockets.

For this, you use the `TestClient` in a `with` statement, connecting to the WebSocket:

`from fastapi import FastAPI from fastapi.testclient import TestClient from fastapi.websockets import WebSocket  app = FastAPI()  @app.get(&quot;/&quot;) async def read_main():     return {&quot;msg&quot;: &quot;Hello World&quot;}  @app.websocket(&quot;/ws&quot;) async def websocket(websocket: WebSocket):     await websocket.accept()     await websocket.send_json({&quot;msg&quot;: &quot;Hello WebSocket&quot;})     await websocket.close()  def test_read_main():     client = TestClient(app)     response = client.get(&quot;/&quot;)     assert response.status_code == 200     assert response.json() == {&quot;msg&quot;: &quot;Hello World&quot;}  def test_websocket():     client = TestClient(app)    with client.websocket_connect(&quot;/ws&quot;) as websocket:        data = websocket.receive_json()        assert data == {&quot;msg&quot;: &quot;Hello WebSocket&quot;}`




You can define logic (code) that should be executed before the application **starts up**. This means that this code will be executed **once**, **before** the application **starts receiving requests**.

The same way, you can define logic (code) that should be executed when the application is **shutting down**. In this case, this code will be executed **once**, **after** having handled possibly **many requests**.

Because this code is executed before the application **starts** taking requests, and right after it **finishes** handling requests, it covers the whole application **lifespan** (the word "lifespan" will be important in a second 😉).

This can be very useful for setting up **resources** that you need to use for the whole app, and that are **shared** among requests, and/or that you need to **clean up** afterwards. For example, a database connection pool, or loading a shared machine learning model.

### Use Case

Let's start with an example **use case** and then see how to solve it with this.

Let's imagine that you have some **machine learning models** that you want to use to handle requests. 🤖

The same models are shared among requests, so, it's not one model per request, or one per user or something similar.

Let's imagine that loading the model can **take quite some time**, because it has to read a lot of **data from disk**. So you don't want to do it for every request.

You could load it at the top level of the module/file, but that would also mean that it would **load the model** even if you are just running a simple automated test, then that test would be **slow** because it would have to wait for the model to load before being able to run an independent part of the code.

That's what we'll solve, let's load the model before the requests are handled, but only right before the application starts receiving requests, not while the code is being loaded.

### Lifespan

You can define this *startup* and *shutdown* logic using the `lifespan` parameter of the `FastAPI` app, and a "context manager" (I'll show you what that is in a second).

Let's start with an example and then see it in detail.

We create an async function `lifespan()` with `yield` like this:

`from contextlib import asynccontextmanager  from fastapi import FastAPI  def fake_answer_to_everything_ml_model(x: float):     return x * 42  ml_models = {}  @asynccontextmanager async def lifespan(app: FastAPI):     # Load the ML model     ml_models[&quot;answer_to_everything&quot;] = fake_answer_to_everything_ml_model    yield     # Clean up the ML models and release the resources     ml_models.clear()  app = FastAPI(lifespan=lifespan)  @app.get(&quot;/predict&quot;) async def predict(x: float):     result = ml_models[&quot;answer_to_everything&quot;](x)     return {&quot;result&quot;: result}`

Here we are simulating the expensive *startup* operation of loading the model by putting the (fake) model function in the dictionary with machine learning models before the `yield`. This code will be executed **before** the application **starts taking requests**, during the *startup*.

And then, right after the `yield`, we unload the model. This code will be executed **after** the application **finishes handling requests**, right before the *shutdown*. This could, for example, release resources like memory or a GPU.

Tip

The `shutdown` would happen when you are **stopping** the application.

Maybe you need to start a new version, or you just got tired of running it. 🤷

#### Lifespan function

The first thing to notice, is that we are defining an async function with `yield`. This is very similar to Dependencies with `yield`.

`from contextlib import asynccontextmanager  from fastapi import FastAPI  def fake_answer_to_everything_ml_model(x: float):     return x * 42  ml_models = {}  @asynccontextmanager async def lifespan(app: FastAPI):     # Load the ML model    ml_models[&quot;answer_to_everything&quot;] = fake_answer_to_everything_ml_model    yield    # Clean up the ML models and release the resources    ml_models.clear()  app = FastAPI(lifespan=lifespan)  @app.get(&quot;/predict&quot;) async def predict(x: float):     result = ml_models[&quot;answer_to_everything&quot;](x)     return {&quot;result&quot;: result}`

The first part of the function, before the `yield`, will be executed **before** the application starts.

And the part after the `yield` will be executed **after** the application has finished.

#### Async Context Manager

If you check, the function is decorated with an `@asynccontextmanager`.

That converts the function into something called an "**async context manager**".

`from contextlib import asynccontextmanager from fastapi import FastAPI  def fake_answer_to_everything_ml_model(x: float):     return x * 42  ml_models = {}  @asynccontextmanager async def lifespan(app: FastAPI):     # Load the ML model     ml_models[&quot;answer_to_everything&quot;] = fake_answer_to_everything_ml_model     yield     # Clean up the ML models and release the resources     ml_models.clear()  app = FastAPI(lifespan=lifespan)  @app.get(&quot;/predict&quot;) async def predict(x: float):     result = ml_models[&quot;answer_to_everything&quot;](x)     return {&quot;result&quot;: result}`

A **context manager** in Python is something that you can use in a `with` statement, for example, `open()` can be used as a context manager:

`with open(&quot;file.txt&quot;) as file:     file.read()`

In recent versions of Python, there's also an **async context manager**. You would use it with `async with`:

`async with lifespan(app):     await do_stuff()`

When you create a context manager or an async context manager like above, what it does is that, before entering the `with` block, it will execute the code before the `yield`, and after exiting the `with` block, it will execute the code after the `yield`.

In our code example above, we don't use it directly, but we pass it to FastAPI for it to use it.

The `lifespan` parameter of the `FastAPI` app takes an **async context manager**, so we can pass our new `lifespan` async context manager to it.

`from contextlib import asynccontextmanager  from fastapi import FastAPI  def fake_answer_to_everything_ml_model(x: float):     return x * 42  ml_models = {}  @asynccontextmanager async def lifespan(app: FastAPI):     # Load the ML model     ml_models[&quot;answer_to_everything&quot;] = fake_answer_to_everything_ml_model     yield     # Clean up the ML models and release the resources     ml_models.clear()  app = FastAPI(lifespan=lifespan)  @app.get(&quot;/predict&quot;) async def predict(x: float):     result = ml_models[&quot;answer_to_everything&quot;](x)     return {&quot;result&quot;: result}`

### Alternative Events (deprecated)

Warning

The recommended way to handle the *startup* and *shutdown* is using the `lifespan` parameter of the `FastAPI` app as described above.

You can probably skip this part.

There's an alternative way to define this logic to be executed during *startup* and during *shutdown*.

You can define event handlers (functions) that need to be executed before the application starts up, or when the application is shutting down.

These functions can be declared with `async def` or normal `def`.

#### `startup` event

To add a function that should be run before the application starts, declare it with the event `&quot;startup&quot;`:

`from fastapi import FastAPI  app = FastAPI()  items = {}  @app.on_event(&quot;startup&quot;) async def startup_event():     items[&quot;foo&quot;] = {&quot;name&quot;: &quot;Fighters&quot;}     items[&quot;bar&quot;] = {&quot;name&quot;: &quot;Tenders&quot;}  @app.get(&quot;/items/{item_id}&quot;) async def read_items(item_id: str):     return items[item_id]`

In this case, the `startup` event handler function will initialize the items "database" (just a `dict`) with some values.

You can add more than one event handler function.

And your application won't start receiving requests until all the `startup` event handlers have completed.

#### `shutdown` event

To add a function that should be run when the application is shutting down, declare it with the event `&quot;shutdown&quot;`:

`from fastapi import FastAPI  app = FastAPI()  @app.on_event(&quot;shutdown&quot;) def shutdown_event():     with open(&quot;log.txt&quot;, mode=&quot;a&quot;) as log:         log.write(&quot;Application shutdown&quot;)  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;name&quot;: &quot;Foo&quot;}]`

Here, the `shutdown` event handler function will write a text line `&quot;Application shutdown&quot;` to a file `log.txt`.

Info

In the `open()` function, the `mode=&quot;a&quot;` means "append", so, the line will be added after whatever is on that file, without overwriting the previous contents.

Tip

Notice that in this case we are using a standard Python `open()` function that interacts with a file.

So, it involves I/O (input/output), that requires "waiting" for things to be written to disk.

But `open()` doesn't use `async` and `await`.

So, we declare the event handler function with standard `def` instead of `async def`.

#### `startup` and `shutdown` together

There's a high chance that the logic for your *startup* and *shutdown* is connected, you might want to start something and then finish it, acquire a resource and then release it, etc.

Doing that in separated functions that don't share logic or variables together is more difficult as you would need to store values in global variables or similar tricks.

Because of that, it's now recommended to instead use the `lifespan` as explained above.

### Technical Details

Just a technical detail for the curious nerds. 🤓

Underneath, in the ASGI technical specification, this is part of the Lifespan Protocol, and it defines events called `startup` and `shutdown`.

Info

You can read more about the Starlette `lifespan` handlers in Starlette's Lifespan' docs.

Including how to handle lifespan state that can be used in other areas of your code.

### Sub Applications

🚨 Have in mind that these lifespan events (startup and shutdown) will only be executed for the main application, not for Sub Applications - Mounts.




### Overriding dependencies during testing

There are some scenarios where you might want to override a dependency during testing.

You don't want the original dependency to run (nor any of the sub-dependencies it might have).

Instead, you want to provide a different dependency that will be used only during tests (possibly only some specific tests), and will provide a value that can be used where the value of the original dependency was used.

#### Use cases: external service

An example could be that you have an external authentication provider that you need to call.

You send it a token and it returns an authenticated user.

This provider might be charging you per request, and calling it might take some extra time than if you had a fixed mock user for tests.

You probably want to test the external provider once, but not necessarily call it for every test that runs.

In this case, you can override the dependency that calls that provider, and use a custom dependency that returns a mock user, only for your tests.

#### Use the `app.dependency_overrides` attribute

For these cases, your **FastAPI** application has an attribute `app.dependency_overrides`, it is a simple `dict`.

To override a dependency for testing, you put as a key the original dependency (a function), and as the value, your dependency override (another function).

And then **FastAPI** will call that override instead of the original dependency.

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI from fastapi.testclient import TestClient  app = FastAPI()  async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return {&quot;message&quot;: &quot;Hello Items!&quot;, &quot;params&quot;: commons}  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return {&quot;message&quot;: &quot;Hello Users!&quot;, &quot;params&quot;: commons}  client = TestClient(app)  async def override_dependency(q: str | None = None):     return {&quot;q&quot;: q, &quot;skip&quot;: 5, &quot;limit&quot;: 10}  app.dependency_overrides[common_parameters] = override_dependency  def test_override_in_items():     response = client.get(&quot;/items/&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: None, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }  def test_override_in_items_with_q():     response = client.get(&quot;/items/?q=foo&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: &quot;foo&quot;, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }  def test_override_in_items_with_params():     response = client.get(&quot;/items/?q=foo&amp;skip=100&amp;limit=200&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: &quot;foo&quot;, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI from fastapi.testclient import TestClient  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return {&quot;message&quot;: &quot;Hello Items!&quot;, &quot;params&quot;: commons}  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return {&quot;message&quot;: &quot;Hello Users!&quot;, &quot;params&quot;: commons}  client = TestClient(app)  async def override_dependency(q: Union[str, None] = None):     return {&quot;q&quot;: q, &quot;skip&quot;: 5, &quot;limit&quot;: 10}  app.dependency_overrides[common_parameters] = override_dependency  def test_override_in_items():     response = client.get(&quot;/items/&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: None, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }  def test_override_in_items_with_q():     response = client.get(&quot;/items/?q=foo&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: &quot;foo&quot;, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }  def test_override_in_items_with_params():     response = client.get(&quot;/items/?q=foo&amp;skip=100&amp;limit=200&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: &quot;foo&quot;, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }`

`from typing import Union  from fastapi import Depends, FastAPI from fastapi.testclient import TestClient from typing_extensions import Annotated  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return {&quot;message&quot;: &quot;Hello Items!&quot;, &quot;params&quot;: commons}  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return {&quot;message&quot;: &quot;Hello Users!&quot;, &quot;params&quot;: commons}  client = TestClient(app)  async def override_dependency(q: Union[str, None] = None):     return {&quot;q&quot;: q, &quot;skip&quot;: 5, &quot;limit&quot;: 10}  app.dependency_overrides[common_parameters] = override_dependency  def test_override_in_items():     response = client.get(&quot;/items/&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: None, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }  def test_override_in_items_with_q():     response = client.get(&quot;/items/?q=foo&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: &quot;foo&quot;, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }  def test_override_in_items_with_params():     response = client.get(&quot;/items/?q=foo&amp;skip=100&amp;limit=200&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: &quot;foo&quot;, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI from fastapi.testclient import TestClient  app = FastAPI()  async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: dict = Depends(common_parameters)):     return {&quot;message&quot;: &quot;Hello Items!&quot;, &quot;params&quot;: commons}  @app.get(&quot;/users/&quot;) async def read_users(commons: dict = Depends(common_parameters)):     return {&quot;message&quot;: &quot;Hello Users!&quot;, &quot;params&quot;: commons}  client = TestClient(app)  async def override_dependency(q: str | None = None):     return {&quot;q&quot;: q, &quot;skip&quot;: 5, &quot;limit&quot;: 10}  app.dependency_overrides[common_parameters] = override_dependency  def test_override_in_items():     response = client.get(&quot;/items/&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: None, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }  def test_override_in_items_with_q():     response = client.get(&quot;/items/?q=foo&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: &quot;foo&quot;, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }  def test_override_in_items_with_params():     response = client.get(&quot;/items/?q=foo&amp;skip=100&amp;limit=200&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: &quot;foo&quot;, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI from fastapi.testclient import TestClient  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: dict = Depends(common_parameters)):     return {&quot;message&quot;: &quot;Hello Items!&quot;, &quot;params&quot;: commons}  @app.get(&quot;/users/&quot;) async def read_users(commons: dict = Depends(common_parameters)):     return {&quot;message&quot;: &quot;Hello Users!&quot;, &quot;params&quot;: commons}  client = TestClient(app)  async def override_dependency(q: Union[str, None] = None):     return {&quot;q&quot;: q, &quot;skip&quot;: 5, &quot;limit&quot;: 10}  app.dependency_overrides[common_parameters] = override_dependency  def test_override_in_items():     response = client.get(&quot;/items/&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: None, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }  def test_override_in_items_with_q():     response = client.get(&quot;/items/?q=foo&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: &quot;foo&quot;, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }  def test_override_in_items_with_params():     response = client.get(&quot;/items/?q=foo&amp;skip=100&amp;limit=200&quot;)     assert response.status_code == 200     assert response.json() == {         &quot;message&quot;: &quot;Hello Items!&quot;,         &quot;params&quot;: {&quot;q&quot;: &quot;foo&quot;, &quot;skip&quot;: 5, &quot;limit&quot;: 10},     }`

Tip

You can set a dependency override for a dependency used anywhere in your **FastAPI** application.

The original dependency could be used in a *path operation function*, a *path operation decorator* (when you don't use the return value), a `.include_router()` call, etc.

FastAPI will still be able to override it.

Then you can reset your overrides (remove them) by setting `app.dependency_overrides` to be an empty `dict`:

`app.dependency_overrides = {}`

Tip

If you want to override a dependency only during some tests, you can set the override at the beginning of the test (inside the test function) and reset it at the end (at the end of the test function).




You have already seen how to test your **FastAPI** applications using the provided `TestClient`. Up to now, you have only seen how to write synchronous tests, without using `async` functions.

Being able to use asynchronous functions in your tests could be useful, for example, when you're querying your database asynchronously. Imagine you want to test sending requests to your FastAPI application and then verify that your backend successfully wrote the correct data in the database, while using an async database library.

Let's look at how we can make that work.

### pytest.mark.anyio

If we want to call asynchronous functions in our tests, our test functions have to be asynchronous. AnyIO provides a neat plugin for this, that allows us to specify that some test functions are to be called asynchronously.

### HTTPX

Even if your **FastAPI** application uses normal `def` functions instead of `async def`, it is still an `async` application underneath.

The `TestClient` does some magic inside to call the asynchronous FastAPI application in your normal `def` test functions, using standard pytest. But that magic doesn't work anymore when we're using it inside asynchronous functions. By running our tests asynchronously, we can no longer use the `TestClient` inside our test functions.

The `TestClient` is based on HTTPX, and luckily, we can use it directly to test the API.

### Example

For a simple example, let's consider a file structure similar to the one described in Bigger Applications and Testing:

`. ├── app │   ├── __init__.py │   ├── main.py │   └── test_main.py`

The file `main.py` would have:

`from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/&quot;) async def root():     return {&quot;message&quot;: &quot;Tomato&quot;}`

The file `test_main.py` would have the tests for `main.py`, it could look like this now:

`import pytest from httpx import AsyncClient  from .main import app  @pytest.mark.anyio async def test_root():     async with AsyncClient(app=app, base_url=&quot;http://test&quot;) as ac:         response = await ac.get(&quot;/&quot;)     assert response.status_code == 200     assert response.json() == {&quot;message&quot;: &quot;Tomato&quot;}`

### Run it

You can run your tests as usual via:

### In Detail

The marker `@pytest.mark.anyio` tells pytest that this test function should be called asynchronously:

`import pytest from httpx import AsyncClient  from .main import app  @pytest.mark.anyio async def test_root():     async with AsyncClient(app=app, base_url=&quot;http://test&quot;) as ac:         response = await ac.get(&quot;/&quot;)     assert response.status_code == 200     assert response.json() == {&quot;message&quot;: &quot;Tomato&quot;}`

Tip

Note that the test function is now `async def` instead of just `def` as before when using the `TestClient`.

Then we can create an `AsyncClient` with the app, and send async requests to it, using `await`.

`import pytest from httpx import AsyncClient  from .main import app  @pytest.mark.anyio async def test_root():     async with AsyncClient(app=app, base_url=&quot;http://test&quot;) as ac:        response = await ac.get(&quot;/&quot;)    assert response.status_code == 200     assert response.json() == {&quot;message&quot;: &quot;Tomato&quot;}`

This is the equivalent to:

`response = client.get('/')`

...that we used to make our requests with the `TestClient`.

Tip

Note that we're using async/await with the new `AsyncClient` - the request is asynchronous.

### Other Asynchronous Function Calls

As the testing function is now asynchronous, you can now also call (and `await`) other `async` functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.

Tip

If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests (e.g. when using MongoDB's MotorClient) Remember to instantiate objects that need an event loop only within async functions, e.g. an `'@app.on_event(&quot;startup&quot;)` callback.




Info

These docs are about to be updated. 🎉

The current version assumes Pydantic v1, and SQLAlchemy versions less than 2.0.

The new docs will include Pydantic v2 and will use SQLModel (which is also based on SQLAlchemy) once it is updated to use Pydantic v2 as well.

You can use the same dependency overrides from Testing Dependencies with Overrides to alter a database for testing.

You could want to set up a different database for testing, rollback the data after the tests, pre-fill it with some testing data, etc.

The main idea is exactly the same you saw in that previous chapter.

### Add tests for the SQL app

Let's update the example from SQL (Relational) Databases to use a testing database.

All the app code is the same, you can go back to that chapter check how it was.

The only changes here are in the new testing file.

Your normal dependency `get_db()` would return a database session.

In the test, you could use a dependency override to return your *custom* database session instead of the one that would be used normally.

In this example we'll create a temporary database only for the tests.

### File structure

We create a new file at `sql_app/tests/test_sql_app.py`.

So the new file structure looks like:

`. └── sql_app     ├── __init__.py     ├── crud.py     ├── database.py     ├── main.py     ├── models.py     ├── schemas.py     └── tests        ├── __init__.py        └── test_sql_app.py`

### Create the new database session

First, we create a new database session with the new database.

We'll use an in-memory database that persists during the tests instead of the local file `sql_app.db`.

But the rest of the session code is more or less the same, we just copy it.

`from fastapi.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.pool import StaticPool  from ..database import Base from ..main import app, get_db SQLALCHEMY_DATABASE_URL = &quot;sqlite://&quot; engine = create_engine(     SQLALCHEMY_DATABASE_URL,    connect_args={&quot;check_same_thread&quot;: False},    poolclass=StaticPool, ) TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)  Base.metadata.create_all(bind=engine)  def override_get_db():     try:         db = TestingSessionLocal()         yield db     finally:         db.close()  app.dependency_overrides[get_db] = override_get_db  client = TestClient(app)  def test_create_user():     response = client.post(         &quot;/users/&quot;,         json={&quot;email&quot;: &quot;deadpool@example.com&quot;, &quot;password&quot;: &quot;chimichangas4life&quot;},     )     assert response.status_code == 200, response.text     data = response.json()     assert data[&quot;email&quot;] == &quot;deadpool@example.com&quot;     assert &quot;id&quot; in data     user_id = data[&quot;id&quot;]      response = client.get(f&quot;/users/{user_id}&quot;)     assert response.status_code == 200, response.text     data = response.json()     assert data[&quot;email&quot;] == &quot;deadpool@example.com&quot;     assert data[&quot;id&quot;] == user_id`

Tip

You could reduce duplication in that code by putting it in a function and using it from both `database.py` and `tests/test_sql_app.py`.

For simplicity and to focus on the specific testing code, we are just copying it.

### Create the database

Because now we are going to use a new database in a new file, we need to make sure we create the database with:

`Base.metadata.create_all(bind=engine)`

That is normally called in `main.py`, but the line in `main.py` uses the database file `sql_app.db`, and we need to make sure we create `test.db` for the tests.

So we add that line here, with the new file.

`from fastapi.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.pool import StaticPool  from ..database import Base from ..main import app, get_db  SQLALCHEMY_DATABASE_URL = &quot;sqlite://&quot;  engine = create_engine(     SQLALCHEMY_DATABASE_URL,     connect_args={&quot;check_same_thread&quot;: False},     poolclass=StaticPool, ) TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)  Base.metadata.create_all(bind=engine)  def override_get_db():     try:         db = TestingSessionLocal()         yield db     finally:         db.close()  app.dependency_overrides[get_db] = override_get_db  client = TestClient(app)  def test_create_user():     response = client.post(         &quot;/users/&quot;,         json={&quot;email&quot;: &quot;deadpool@example.com&quot;, &quot;password&quot;: &quot;chimichangas4life&quot;},     )     assert response.status_code == 200, response.text     data = response.json()     assert data[&quot;email&quot;] == &quot;deadpool@example.com&quot;     assert &quot;id&quot; in data     user_id = data[&quot;id&quot;]      response = client.get(f&quot;/users/{user_id}&quot;)     assert response.status_code == 200, response.text     data = response.json()     assert data[&quot;email&quot;] == &quot;deadpool@example.com&quot;     assert data[&quot;id&quot;] == user_id`

### Dependency override

Now we create the dependency override and add it to the overrides for our app.

`from fastapi.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.pool import StaticPool  from ..database import Base from ..main import app, get_db  SQLALCHEMY_DATABASE_URL = &quot;sqlite://&quot;  engine = create_engine(     SQLALCHEMY_DATABASE_URL,     connect_args={&quot;check_same_thread&quot;: False},     poolclass=StaticPool, ) TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)  Base.metadata.create_all(bind=engine) def override_get_db():     try:        db = TestingSessionLocal()        yield db     finally:         db.close()  app.dependency_overrides[get_db] = override_get_db  client = TestClient(app)  def test_create_user():     response = client.post(         &quot;/users/&quot;,         json={&quot;email&quot;: &quot;deadpool@example.com&quot;, &quot;password&quot;: &quot;chimichangas4life&quot;},     )     assert response.status_code == 200, response.text     data = response.json()     assert data[&quot;email&quot;] == &quot;deadpool@example.com&quot;     assert &quot;id&quot; in data     user_id = data[&quot;id&quot;]      response = client.get(f&quot;/users/{user_id}&quot;)     assert response.status_code == 200, response.text     data = response.json()     assert data[&quot;email&quot;] == &quot;deadpool@example.com&quot;     assert data[&quot;id&quot;] == user_id`

Tip

The code for `override_get_db()` is almost exactly the same as for `get_db()`, but in `override_get_db()` we use the `TestingSessionLocal` for the testing database instead.

### Test the app

Then we can just test the app as normally.

`from fastapi.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.pool import StaticPool  from ..database import Base from ..main import app, get_db  SQLALCHEMY_DATABASE_URL = &quot;sqlite://&quot;  engine = create_engine(     SQLALCHEMY_DATABASE_URL,     connect_args={&quot;check_same_thread&quot;: False},     poolclass=StaticPool, ) TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)  Base.metadata.create_all(bind=engine)  def override_get_db():     try:         db = TestingSessionLocal()         yield db     finally:         db.close()  app.dependency_overrides[get_db] = override_get_db  client = TestClient(app) def test_create_user():     response = client.post(        &quot;/users/&quot;,        json={&quot;email&quot;: &quot;deadpool@example.com&quot;, &quot;password&quot;: &quot;chimichangas4life&quot;},    )    assert response.status_code == 200, response.text    data = response.json()    assert data[&quot;email&quot;] == &quot;deadpool@example.com&quot;    assert &quot;id&quot; in data    user_id = data[&quot;id&quot;]     response = client.get(f&quot;/users/{user_id}&quot;)    assert response.status_code == 200, response.text    data = response.json()     assert data[&quot;email&quot;] == &quot;deadpool@example.com&quot;     assert data[&quot;id&quot;] == user_id`

And all the modifications we made in the database during the tests will be in the `test.db` database instead of the main `sql_app.db`.




In many cases your application could need some external settings or configurations, for example secret keys, database credentials, credentials for email services, etc.

Most of these settings are variable (can change), like database URLs. And many could be sensitive, like secrets.

For this reason it's common to provide them in environment variables that are read by the application.

### Environment Variables

Tip

If you already know what "environment variables" are and how to use them, feel free to skip to the next section below.

An environment variable (also known as "env var") is a variable that lives outside of the Python code, in the operating system, and could be read by your Python code (or by other programs as well).

You can create and use environment variables in the shell, without needing Python:

Linux, macOS, Windows BashWindows PowerShell

`// You could create an env var MY_NAME with $ export MY_NAME=&quot;Wade Wilson&quot;  // Then you could use it with other programs, like $ echo &quot;Hello $MY_NAME&quot;  Hello Wade Wilson`

`// Create an env var MY_NAME $ $Env:MY_NAME = &quot;Wade Wilson&quot;  // Use it with other programs, like $ echo &quot;Hello $Env:MY_NAME&quot;  Hello Wade Wilson`

#### Read env vars in Python

You could also create environment variables outside of Python, in the terminal (or with any other method), and then read them in Python.

For example you could have a file `main.py` with:

`import os  name = os.getenv(&quot;MY_NAME&quot;, &quot;World&quot;) print(f&quot;Hello {name} from Python&quot;)`

Tip

The second argument to `os.getenv()` is the default value to return.

If not provided, it's `None` by default, here we provide `&quot;World&quot;` as the default value to use.

Then you could call that Python program:

`// Here we don't set the env var yet $ python main.py  // As we didn't set the env var, we get the default value  Hello World from Python  // But if we create an environment variable first $ export MY_NAME=&quot;Wade Wilson&quot;  // And then call the program again $ python main.py  // Now it can read the environment variable  Hello Wade Wilson from Python`

As environment variables can be set outside of the code, but can be read by the code, and don't have to be stored (committed to `git`) with the rest of the files, it's common to use them for configurations or settings.

You can also create an environment variable only for a specific program invocation, that is only available to that program, and only for its duration.

To do that, create it right before the program itself, on the same line:

`// Create an env var MY_NAME in line for this program call $ MY_NAME=&quot;Wade Wilson&quot; python main.py  // Now it can read the environment variable  Hello Wade Wilson from Python  // The env var no longer exists afterwards $ python main.py  Hello World from Python`

#### Types and validation

These environment variables can only handle text strings, as they are external to Python and have to be compatible with other programs and the rest of the system (and even with different operating systems, as Linux, Windows, macOS).

That means that any value read in Python from an environment variable will be a `str`, and any conversion to a different type or validation has to be done in code.

### Pydantic `Settings`

Fortunately, Pydantic provides a great utility to handle these settings coming from environment variables with Pydantic: Settings management.

#### Install `pydantic-settings`

First, install the `pydantic-settings` package:

`$ pip install pydantic-settings ---&gt; 100%`

It also comes included when you install the `all` extras with:

`$ pip install &quot;fastapi[all]&quot; ---&gt; 100%`

Info

In Pydantic v1 it came included with the main package. Now it is distributed as this independent package so that you can choose to install it or not if you don't need that functionality.

#### Create the `Settings` object

Import `BaseSettings` from Pydantic and create a sub-class, very much like with a Pydantic model.

The same way as with Pydantic models, you declare class attributes with type annotations, and possibly default values.

You can use all the same validation features and tools you use for Pydantic models, like different data types and additional validations with `Field()`.

Pydantic v2Pydantic v1

`from fastapi import FastAPI from pydantic_settings import BaseSettings  class Settings(BaseSettings):     app_name: str = &quot;Awesome API&quot;    admin_email: str    items_per_user: int = 50  settings = Settings() app = FastAPI()  @app.get(&quot;/info&quot;) async def info():     return {         &quot;app_name&quot;: settings.app_name,         &quot;admin_email&quot;: settings.admin_email,         &quot;items_per_user&quot;: settings.items_per_user,     }`

Info

In Pydantic v1 you would import `BaseSettings` directly from `pydantic` instead of from `pydantic_settings`.

`from fastapi import FastAPI from pydantic import BaseSettings  class Settings(BaseSettings):     app_name: str = &quot;Awesome API&quot;    admin_email: str    items_per_user: int = 50  settings = Settings() app = FastAPI()  @app.get(&quot;/info&quot;) async def info():     return {         &quot;app_name&quot;: settings.app_name,         &quot;admin_email&quot;: settings.admin_email,         &quot;items_per_user&quot;: settings.items_per_user,     }`

Tip

If you want something quick to copy and paste, don't use this example, use the last one below.

Then, when you create an instance of that `Settings` class (in this case, in the `settings` object), Pydantic will read the environment variables in a case-insensitive way, so, an upper-case variable `APP_NAME` will still be read for the attribute `app_name`.

Next it will convert and validate the data. So, when you use that `settings` object, you will have data of the types you declared (e.g. `items_per_user` will be an `int`).

#### Use the `settings`

Then you can use the new `settings` object in your application:

`from fastapi import FastAPI from pydantic_settings import BaseSettings  class Settings(BaseSettings):     app_name: str = &quot;Awesome API&quot;     admin_email: str     items_per_user: int = 50  settings = Settings() app = FastAPI()  @app.get(&quot;/info&quot;) async def info():     return {         &quot;app_name&quot;: settings.app_name,        &quot;admin_email&quot;: settings.admin_email,        &quot;items_per_user&quot;: settings.items_per_user,    }`

#### Run the server

Next, you would run the server passing the configurations as environment variables, for example you could set an `ADMIN_EMAIL` and `APP_NAME` with:

`$ ADMIN_EMAIL=&quot;deadpool@example.com&quot; APP_NAME=&quot;ChimichangApp&quot; uvicorn main:app  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

Tip

To set multiple env vars for a single command just separate them with a space, and put them all before the command.

And then the `admin_email` setting would be set to `&quot;deadpool@example.com&quot;`.

The `app_name` would be `&quot;ChimichangApp&quot;`.

And the `items_per_user` would keep its default value of `50`.

### Settings in another module

You could put those settings in another module file as you saw in Bigger Applications - Multiple Files.

For example, you could have a file `config.py` with:

`from pydantic_settings import BaseSettings  class Settings(BaseSettings):     app_name: str = &quot;Awesome API&quot;     admin_email: str     items_per_user: int = 50  settings = Settings()`

And then use it in a file `main.py`:

`from fastapi import FastAPI  from .config import settings app = FastAPI()  @app.get(&quot;/info&quot;) async def info():     return {         &quot;app_name&quot;: settings.app_name,        &quot;admin_email&quot;: settings.admin_email,        &quot;items_per_user&quot;: settings.items_per_user,    }`

### Settings in a dependency

In some occasions it might be useful to provide the settings from a dependency, instead of having a global object with `settings` that is used everywhere.

This could be especially useful during testing, as it's very easy to override a dependency with your own custom settings.

#### The config file

Coming from the previous example, your `config.py` file could look like:

`from pydantic_settings import BaseSettings  class Settings(BaseSettings):     app_name: str = &quot;Awesome API&quot;     admin_email: str     items_per_user: int = 50`

Notice that now we don't create a default instance `settings = Settings()`.

#### The main app file

Now we create a dependency that returns a new `config.Settings()`.

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from functools import lru_cache from typing import Annotated  from fastapi import Depends, FastAPI  from .config import Settings app = FastAPI()  @lru_cache() def get_settings():     return Settings()  @app.get(&quot;/info&quot;) async def info(settings: Annotated[Settings, Depends(get_settings)]):     return {         &quot;app_name&quot;: settings.app_name,         &quot;admin_email&quot;: settings.admin_email,         &quot;items_per_user&quot;: settings.items_per_user,     }`

`from functools import lru_cache  from fastapi import Depends, FastAPI from typing_extensions import Annotated  from .config import Settings app = FastAPI()  @lru_cache() def get_settings():     return Settings()  @app.get(&quot;/info&quot;) async def info(settings: Annotated[Settings, Depends(get_settings)]):     return {         &quot;app_name&quot;: settings.app_name,         &quot;admin_email&quot;: settings.admin_email,         &quot;items_per_user&quot;: settings.items_per_user,     }`

Tip

Prefer to use the `Annotated` version if possible.

`from functools import lru_cache  from fastapi import Depends, FastAPI  from .config import Settings app = FastAPI()  @lru_cache() def get_settings():     return Settings()  @app.get(&quot;/info&quot;) async def info(settings: Settings = Depends(get_settings)):     return {         &quot;app_name&quot;: settings.app_name,         &quot;admin_email&quot;: settings.admin_email,         &quot;items_per_user&quot;: settings.items_per_user,     }`

Tip

We'll discuss the `@lru_cache()` in a bit.

For now you can assume `get_settings()` is a normal function.

And then we can require it from the *path operation function* as a dependency and use it anywhere we need it.

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from functools import lru_cache from typing import Annotated  from fastapi import Depends, FastAPI  from .config import Settings  app = FastAPI()  @lru_cache() def get_settings():     return Settings()  @app.get(&quot;/info&quot;) async def info(settings: Annotated[Settings, Depends(get_settings)]):     return {         &quot;app_name&quot;: settings.app_name,        &quot;admin_email&quot;: settings.admin_email,        &quot;items_per_user&quot;: settings.items_per_user,    }`

`from functools import lru_cache  from fastapi import Depends, FastAPI from typing_extensions import Annotated  from .config import Settings  app = FastAPI()  @lru_cache() def get_settings():     return Settings()  @app.get(&quot;/info&quot;) async def info(settings: Annotated[Settings, Depends(get_settings)]):     return {         &quot;app_name&quot;: settings.app_name,        &quot;admin_email&quot;: settings.admin_email,        &quot;items_per_user&quot;: settings.items_per_user,    }`

Tip

Prefer to use the `Annotated` version if possible.

`from functools import lru_cache  from fastapi import Depends, FastAPI  from .config import Settings  app = FastAPI()  @lru_cache() def get_settings():     return Settings()  @app.get(&quot;/info&quot;) async def info(settings: Settings = Depends(get_settings)):     return {         &quot;app_name&quot;: settings.app_name,        &quot;admin_email&quot;: settings.admin_email,        &quot;items_per_user&quot;: settings.items_per_user,    }`

#### Settings and testing

Then it would be very easy to provide a different settings object during testing by creating a dependency override for `get_settings`:

`from fastapi.testclient import TestClient  from .config import Settings from .main import app, get_settings  client = TestClient(app)  def get_settings_override():     return Settings(admin_email=&quot;testing_admin@example.com&quot;)  app.dependency_overrides[get_settings] = get_settings_override  def test_app():     response = client.get(&quot;/info&quot;)     data = response.json()     assert data == {         &quot;app_name&quot;: &quot;Awesome API&quot;,         &quot;admin_email&quot;: &quot;testing_admin@example.com&quot;,        &quot;items_per_user&quot;: 50,     }`

In the dependency override we set a new value for the `admin_email` when creating the new `Settings` object, and then we return that new object.

Then we can test that it is used.

### Reading a `.env` file

If you have many settings that possibly change a lot, maybe in different environments, it might be useful to put them on a file and then read them from it as if they were environment variables.

This practice is common enough that it has a name, these environment variables are commonly placed in a file `.env`, and the file is called a "dotenv".

Tip

A file starting with a dot (`.`) is a hidden file in Unix-like systems, like Linux and macOS.

But a dotenv file doesn't really have to have that exact filename.

Pydantic has support for reading from these types of files using an external library. You can read more at Pydantic Settings: Dotenv (.env) support.

Tip

For this to work, you need to `pip install python-dotenv`.

#### The `.env` file

You could have a `.env` file with:

`ADMIN_EMAIL=&quot;deadpool@example.com&quot; APP_NAME=&quot;ChimichangApp&quot;`

#### Read settings from `.env`

And then update your `config.py` with:

Pydantic v2Pydantic v1

`from pydantic_settings import BaseSettings, SettingsConfigDict  class Settings(BaseSettings):     app_name: str = &quot;Awesome API&quot;     admin_email: str     items_per_user: int = 50      model_config = SettingsConfigDict(env_file=&quot;.env&quot;)`

Tip

The `model_config` attribute is used just for Pydantic configuration. You can read more at Pydantic Model Config.

`from pydantic import BaseSettings  class Settings(BaseSettings):     app_name: str = &quot;Awesome API&quot;     admin_email: str     items_per_user: int = 50      class Config:        env_file = &quot;.env&quot;`

Tip

The `Config` class is used just for Pydantic configuration. You can read more at Pydantic Model Config.

Info

In Pydantic version 1 the configuration was done in an internal class `Config`, in Pydantic version 2 it's done in an attribute `model_config`. This attribute takes a `dict`, and to get autocompletion and inline errors you can import and use `SettingsConfigDict` to define that `dict`.

Here we define the config `env_file` inside of your Pydantic `Settings` class, and set the value to the filename with the dotenv file we want to use.

#### Creating the `Settings` only once with `lru_cache`

Reading a file from disk is normally a costly (slow) operation, so you probably want to do it only once and then re-use the same settings object, instead of reading it for each request.

But every time we do:

a new `Settings` object would be created, and at creation it would read the `.env` file again.

If the dependency function was just like:

`def get_settings():     return Settings()`

we would create that object for each request, and we would be reading the `.env` file for each request. ⚠️

But as we are using the `@lru_cache()` decorator on top, the `Settings` object will be created only once, the first time it's called. ✔️

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from functools import lru_cache from fastapi import Depends, FastAPI from typing_extensions import Annotated  from . import config  app = FastAPI()  @lru_cache() def get_settings():     return config.Settings()  @app.get(&quot;/info&quot;) async def info(settings: Annotated[config.Settings, Depends(get_settings)]):     return {         &quot;app_name&quot;: settings.app_name,         &quot;admin_email&quot;: settings.admin_email,         &quot;items_per_user&quot;: settings.items_per_user,     }`

`from functools import lru_cache from typing import Annotated  from fastapi import Depends, FastAPI  from . import config  app = FastAPI()  @lru_cache() def get_settings():     return config.Settings()  @app.get(&quot;/info&quot;) async def info(settings: Annotated[config.Settings, Depends(get_settings)]):     return {         &quot;app_name&quot;: settings.app_name,         &quot;admin_email&quot;: settings.admin_email,         &quot;items_per_user&quot;: settings.items_per_user,     }`

Tip

Prefer to use the `Annotated` version if possible.

`from functools import lru_cache from fastapi import Depends, FastAPI  from . import config  app = FastAPI()  @lru_cache() def get_settings():     return config.Settings()  @app.get(&quot;/info&quot;) async def info(settings: config.Settings = Depends(get_settings)):     return {         &quot;app_name&quot;: settings.app_name,         &quot;admin_email&quot;: settings.admin_email,         &quot;items_per_user&quot;: settings.items_per_user,     }`

Then for any subsequent calls of `get_settings()` in the dependencies for the next requests, instead of executing the internal code of `get_settings()` and creating a new `Settings` object, it will return the same object that was returned on the first call, again and again.

##### `lru_cache` Technical Details

`@lru_cache()` modifies the function it decorates to return the same value that was returned the first time, instead of computing it again, executing the code of the function every time.

So, the function below it will be executed once for each combination of arguments. And then the values returned by each of those combinations of arguments will be used again and again whenever the function is called with exactly the same combination of arguments.

For example, if you have a function:

`@lru_cache() def say_hi(name: str, salutation: str = &quot;Ms.&quot;):     return f&quot;Hello {salutation} {name}&quot;`

your program could execute like this:

```
sequenceDiagram

participant code as Code
participant function as say_hi()
participant execute as Execute function

    rect rgba(0, 255, 0, .1)
        code ->> function: say_hi(name="Camila")
        function ->> execute: execute function code
        execute ->> code: return the result
    end

    rect rgba(0, 255, 255, .1)
        code ->> function: say_hi(name="Camila")
        function ->> code: return stored result
    end

    rect rgba(0, 255, 0, .1)
        code ->> function: say_hi(name="Rick")
        function ->> execute: execute function code
        execute ->> code: return the result
    end

    rect rgba(0, 255, 0, .1)
        code ->> function: say_hi(name="Rick", salutation="Mr.")
        function ->> execute: execute function code
        execute ->> code: return the result
    end

    rect rgba(0, 255, 255, .1)
        code ->> function: say_hi(name="Rick")
        function ->> code: return stored result
    end

    rect rgba(0, 255, 255, .1)
        code ->> function: say_hi(name="Camila")
        function ->> code: return stored result
    end
```

In the case of our dependency `get_settings()`, the function doesn't even take any arguments, so it always returns the same value.

That way, it behaves almost as if it was just a global variable. But as it uses a dependency function, then we can override it easily for testing.

`@lru_cache()` is part of `functools` which is part of Python's standard library, you can read more about it in the Python docs for `@lru_cache()`.

### Recap

You can use Pydantic Settings to handle the settings or configurations for your application, with all the power of Pydantic models.

- By using a dependency you can simplify testing.
- You can use `.env` files with it.
- Using `@lru_cache()` lets you avoid reading the dotenv file again and again for each request, while allowing you to override it during testing.




You could create an API with a *path operation* that could trigger a request to an *external API* created by someone else (probably the same developer that would be *using* your API).

The process that happens when your API app calls the *external API* is named a "callback". Because the software that the external developer wrote sends a request to your API and then your API *calls back*, sending a request to an *external API* (that was probably created by the same developer).

In this case, you could want to document how that external API *should* look like. What *path operation* it should have, what body it should expect, what response it should return, etc.

### An app with callbacks

Let's see all this with an example.

Imagine you develop an app that allows creating invoices.

These invoices will have an `id`, `title` (optional), `customer`, and `total`.

The user of your API (an external developer) will create an invoice in your API with a POST request.

Then your API will (let's imagine):

- Send the invoice to some customer of the external developer.
- Collect the money.
- Send a notification back to the API user (the external developer).
  - This will be done by sending a POST request (from *your API*) to some *external API* provided by that external developer (this is the "callback").

### The normal **FastAPI** app

Let's first see how the normal API app would look like before adding the callback.

It will have a *path operation* that will receive an `Invoice` body, and a query parameter `callback_url` that will contain the URL for the callback.

This part is pretty normal, most of the code is probably already familiar to you:

`from typing import Union  from fastapi import APIRouter, FastAPI from pydantic import BaseModel, HttpUrl  app = FastAPI()  class Invoice(BaseModel):     id: str    title: Union[str, None] = None    customer: str    total: float  class InvoiceEvent(BaseModel):     description: str     paid: bool  class InvoiceEventReceived(BaseModel):     ok: bool  invoices_callback_router = APIRouter()  @invoices_callback_router.post(     &quot;{$callback_url}/invoices/{$request.body.id}&quot;, response_model=InvoiceEventReceived ) def invoice_notification(body: InvoiceEvent):     pass  @app.post(&quot;/invoices/&quot;, callbacks=invoices_callback_router.routes) def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):     &quot;&quot;&quot;    Create an invoice.     This will (let's imagine) let the API user (some external developer) create an    invoice.     And this path operation will:     * Send the invoice to the client.    * Collect the money from the client.    * Send a notification back to the API user (the external developer), as a callback.        * At this point is that the API will somehow send a POST request to the            external API with the notification of the invoice event            (e.g. &quot;payment successful&quot;).    &quot;&quot;&quot;    # Send the invoice, collect the money, send the notification (the callback)    return {&quot;msg&quot;: &quot;Invoice received&quot;}`

Tip

The `callback_url` query parameter uses a Pydantic URL type.

The only new thing is the `callbacks=messages_callback_router.routes` as an argument to the *path operation decorator*. We'll see what that is next.

### Documenting the callback

The actual callback code will depend heavily on your own API app.

And it will probably vary a lot from one app to the next.

It could be just one or two lines of code, like:

`callback_url = &quot;https://example.com/api/v1/invoices/events/&quot; httpx.post(callback_url, json={&quot;description&quot;: &quot;Invoice paid&quot;, &quot;paid&quot;: True})`

But possibly the most important part of the callback is making sure that your API user (the external developer) implements the *external API* correctly, according to the data that *your API* is going to send in the request body of the callback, etc.

So, what we will do next is add the code to document how that *external API* should look like to receive the callback from *your API*.

That documentation will show up in the Swagger UI at `/docs` in your API, and it will let external developers know how to build the *external API*.

This example doesn't implement the callback itself (that could be just a line of code), only the documentation part.

Tip

The actual callback is just an HTTP request.

When implementing the callback yourself, you could use something like HTTPX or Requests.

### Write the callback documentation code

This code won't be executed in your app, we only need it to *document* how that *external API* should look like.

But, you already know how to easily create automatic documentation for an API with **FastAPI**.

So we are going to use that same knowledge to document how the *external API* should look like... by creating the *path operation(s)* that the external API should implement (the ones your API will call).

Tip

When writing the code to document a callback, it might be useful to imagine that you are that *external developer*. And that you are currently implementing the *external API*, not *your API*.

Temporarily adopting this point of view (of the *external developer*) can help you feel like it's more obvious where to put the parameters, the Pydantic model for the body, for the response, etc. for that *external API*.

#### Create a callback `APIRouter`

First create a new `APIRouter` that will contain one or more callbacks.

`from typing import Union  from fastapi import APIRouter, FastAPI from pydantic import BaseModel, HttpUrl  app = FastAPI()  class Invoice(BaseModel):     id: str     title: Union[str, None] = None     customer: str     total: float  class InvoiceEvent(BaseModel):     description: str     paid: bool  class InvoiceEventReceived(BaseModel):     ok: bool  invoices_callback_router = APIRouter()  @invoices_callback_router.post(     &quot;{$callback_url}/invoices/{$request.body.id}&quot;, response_model=InvoiceEventReceived ) def invoice_notification(body: InvoiceEvent):     pass  @app.post(&quot;/invoices/&quot;, callbacks=invoices_callback_router.routes) def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):     &quot;&quot;&quot;     Create an invoice.      This will (let's imagine) let the API user (some external developer) create an     invoice.      And this path operation will:      * Send the invoice to the client.     * Collect the money from the client.     * Send a notification back to the API user (the external developer), as a callback.         * At this point is that the API will somehow send a POST request to the             external API with the notification of the invoice event             (e.g. &quot;payment successful&quot;).     &quot;&quot;&quot;     # Send the invoice, collect the money, send the notification (the callback)     return {&quot;msg&quot;: &quot;Invoice received&quot;}`

#### Create the callback *path operation*

To create the callback *path operation* use the same `APIRouter` you created above.

It should look just like a normal FastAPI *path operation*:

- It should probably have a declaration of the body it should receive, e.g. `body: InvoiceEvent`.
- And it could also have a declaration of the response it should return, e.g. `response_model=InvoiceEventReceived`.

`from typing import Union  from fastapi import APIRouter, FastAPI from pydantic import BaseModel, HttpUrl  app = FastAPI()  class Invoice(BaseModel):     id: str     title: Union[str, None] = None     customer: str     total: float  class InvoiceEvent(BaseModel):     description: str    paid: bool  class InvoiceEventReceived(BaseModel):     ok: bool  invoices_callback_router = APIRouter()  @invoices_callback_router.post(     &quot;{$callback_url}/invoices/{$request.body.id}&quot;, response_model=InvoiceEventReceived ) def invoice_notification(body: InvoiceEvent):     pass  @app.post(&quot;/invoices/&quot;, callbacks=invoices_callback_router.routes) def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):     &quot;&quot;&quot;     Create an invoice.      This will (let's imagine) let the API user (some external developer) create an     invoice.      And this path operation will:      * Send the invoice to the client.     * Collect the money from the client.     * Send a notification back to the API user (the external developer), as a callback.         * At this point is that the API will somehow send a POST request to the             external API with the notification of the invoice event             (e.g. &quot;payment successful&quot;).     &quot;&quot;&quot;     # Send the invoice, collect the money, send the notification (the callback)     return {&quot;msg&quot;: &quot;Invoice received&quot;}`

There are 2 main differences from a normal *path operation*:

- It doesn't need to have any actual code, because your app will never call this code. It's only used to document the *external API*. So, the function could just have `pass`.
- The *path* can contain an OpenAPI 3 expression (see more below) where it can use variables with parameters and parts of the original request sent to *your API*.

#### The callback path expression

The callback *path* can have an OpenAPI 3 expression that can contain parts of the original request sent to *your API*.

In this case, it's the `str`:

`&quot;{$callback_url}/invoices/{$request.body.id}&quot;`

So, if your API user (the external developer) sends a request to *your API* to:

`https://yourapi.com/invoices/?callback_url=https://www.external.org/events`

with a JSON body of:

`{     &quot;id&quot;: &quot;2expen51ve&quot;,     &quot;customer&quot;: &quot;Mr. Richie Rich&quot;,     &quot;total&quot;: &quot;9999&quot; }`

Then *your API* will process the invoice, and at some point later, send a callback request to the `callback_url` (the *external API*):

`https://www.external.org/events/invoices/2expen51ve`

with a JSON body containing something like:

`{     &quot;description&quot;: &quot;Payment celebration&quot;,     &quot;paid&quot;: true }`

and it would expect a response from that *external API* with a JSON body like:

Tip

Notice how the callback URL used contains the URL received as a query parameter in `callback_url` (`https://www.external.org/events`) and also the invoice `id` from inside of the JSON body (`2expen51ve`).

#### Add the callback router

At this point you have the *callback path operation(s)* needed (the one(s) that the *external developer* should implement in the *external API*) in the callback router you created above.

Now use the parameter `callbacks` in *your API's path operation decorator* to pass the attribute `.routes` (that's actually just a `list` of routes/*path operations*) from that callback router:

`from typing import Union  from fastapi import APIRouter, FastAPI from pydantic import BaseModel, HttpUrl  app = FastAPI()  class Invoice(BaseModel):     id: str     title: Union[str, None] = None     customer: str     total: float  class InvoiceEvent(BaseModel):     description: str     paid: bool  class InvoiceEventReceived(BaseModel):     ok: bool  invoices_callback_router = APIRouter()  @invoices_callback_router.post(     &quot;{$callback_url}/invoices/{$request.body.id}&quot;, response_model=InvoiceEventReceived ) def invoice_notification(body: InvoiceEvent):     pass  @app.post(&quot;/invoices/&quot;, callbacks=invoices_callback_router.routes) def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):     &quot;&quot;&quot;     Create an invoice.      This will (let's imagine) let the API user (some external developer) create an     invoice.      And this path operation will:      * Send the invoice to the client.     * Collect the money from the client.     * Send a notification back to the API user (the external developer), as a callback.         * At this point is that the API will somehow send a POST request to the             external API with the notification of the invoice event             (e.g. &quot;payment successful&quot;).     &quot;&quot;&quot;     # Send the invoice, collect the money, send the notification (the callback)     return {&quot;msg&quot;: &quot;Invoice received&quot;}`

Tip

Notice that you are not passing the router itself (`invoices_callback_router`) to `callback=`, but the attribute `.routes`, as in `invoices_callback_router.routes`.

#### Check the docs

Now you can start your app with Uvicorn and go to http://127.0.0.1:8000/docs.

You will see your docs including a "Callback" section for your *path operation* that shows how the *external API* should look like:

<image @ https://fastapi.tiangolo.com/img/tutorial/openapi-callbacks/image01.png>




There are cases where you want to tell your API **users** that your app could call *their* app (sending a request) with some data, normally to **notify** of some type of **event**.

This means that instead of the normal process of your users sending requests to your API, it's **your API** (or your app) that could **send requests to their system** (to their API, their app).

This is normally called a **webhook**.

### Webhooks steps

The process normally is that **you define** in your code what is the message that you will send, the **body of the request**.

You also define in some way at which **moments** your app will send those requests or events.

And **your users** define in some way (for example in a web dashboard somewhere) the **URL** where your app should send those requests.

All the **logic** about how to register the URLs for webhooks and the code to actually send those requests is up to you. You write it however you want to in **your own code**.

### Documenting webhooks with **FastAPI** and OpenAPI

With **FastAPI**, using OpenAPI, you can define the names of these webhooks, the types of HTTP operations that your app can send (e.g. `POST`, `PUT`, etc.) and the request **bodies** that your app would send.

This can make it a lot easier for your users to **implement their APIs** to receive your **webhook** requests, they might even be able to autogenerate some of their own API code.

Info

Webhooks are available in OpenAPI 3.1.0 and above, supported by FastAPI `0.99.0` and above.

### An app with webhooks

When you create a **FastAPI** application, there is a `webhooks` attribute that you can use to define *webhooks*, the same way you would define *path operations*, for example with `@app.webhooks.post()`.

`from datetime import datetime  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Subscription(BaseModel):     username: str    montly_fee: float    start_date: datetime @app.webhooks.post(&quot;new-subscription&quot;) def new_subscription(body: Subscription):     &quot;&quot;&quot;     When a new user subscribes to your service we'll send you a POST request with this     data to the URL that you register for the event `new-subscription` in the dashboard.     &quot;&quot;&quot;  @app.get(&quot;/users/&quot;) def read_users():     return [&quot;Rick&quot;, &quot;Morty&quot;]`

The webhooks that you define will end up in the **OpenAPI** schema and the automatic **docs UI**.

Info

The `app.webhooks` object is actually just an `APIRouter`, the same type you would use when structuring your app with multiple files.

Notice that with webhooks you are actually not declaring a *path* (like `/items/`), the text you pass there is just an **identifier** of the webhook (the name of the event), for example in `@app.webhooks.post(&quot;new-subscription&quot;)`, the webhook name is `new-subscription`.

This is because it is expected that **your users** would define the actual **URL path** where they want to receive the webhook request in some other way (e.g. a web dashboard).

#### Check the docs

Now you can start your app with Uvicorn and go to http://127.0.0.1:8000/docs.

You will see your docs have the normal *path operations* and now also some **webhooks**:

<image @ https://fastapi.tiangolo.com/img/tutorial/openapi-webhooks/image01.png>




You can mount WSGI applications as you saw with Sub Applications - Mounts, Behind a Proxy.

For that, you can use the `WSGIMiddleware` and use it to wrap your WSGI application, for example, Flask, Django, etc.

### Using `WSGIMiddleware`

You need to import `WSGIMiddleware`.

Then wrap the WSGI (e.g. Flask) app with the middleware.

And then mount that under a path.

`from fastapi import FastAPI from fastapi.middleware.wsgi import WSGIMiddleware from flask import Flask, request from markupsafe import escape  flask_app = Flask(__name__)  @flask_app.route(&quot;/&quot;) def flask_main():     name = request.args.get(&quot;name&quot;, &quot;World&quot;)     return f&quot;Hello, {escape(name)} from Flask!&quot;  app = FastAPI()  @app.get(&quot;/v2&quot;) def read_main():     return {&quot;message&quot;: &quot;Hello World&quot;}  app.mount(&quot;/v1&quot;, WSGIMiddleware(flask_app))`

### Check it

Now, every request under the path `/v1/` will be handled by the Flask application.

And the rest will be handled by **FastAPI**.

If you run it with Uvicorn and go to http://localhost:8000/v1/ you will see the response from Flask:

And if you go to http://localhost:8000/v2 you will see the response from FastAPI:

`{     &quot;message&quot;: &quot;Hello World&quot; }`




**FastAPI** is already being used in production in many applications and systems. And the test coverage is kept at 100%. But its development is still moving quickly.

New features are added frequently, bugs are fixed regularly, and the code is still continuously improving.

That's why the current versions are still `0.x.x`, this reflects that each version could potentially have breaking changes. This follows the Semantic Versioning conventions.

You can create production applications with **FastAPI** right now (and you have probably been doing it for some time), you just have to make sure that you use a version that works correctly with the rest of your code.

### Pin your `fastapi` version

The first thing you should do is to "pin" the version of **FastAPI** you are using to the specific latest version that you know works correctly for your application.

For example, let's say you are using version `0.45.0` in your app.

If you use a `requirements.txt` file you could specify the version with:

that would mean that you would use exactly the version `0.45.0`.

Or you could also pin it with:

that would mean that you would use the versions `0.45.0` or above, but less than `0.46.0`, for example, a version `0.45.2` would still be accepted.

If you use any other tool to manage your installations, like Poetry, Pipenv, or others, they all have a way that you can use to define specific versions for your packages.

### Available versions

You can see the available versions (e.g. to check what is the current latest) in the Release Notes.

### About versions

Following the Semantic Versioning conventions, any version below `1.0.0` could potentially add breaking changes.

FastAPI also follows the convention that any "PATCH" version change is for bug fixes and non-breaking changes.

Tip

The "PATCH" is the last number, for example, in `0.2.3`, the PATCH version is `3`.

So, you should be able to pin to a version like:

Breaking changes and new features are added in "MINOR" versions.

Tip

The "MINOR" is the number in the middle, for example, in `0.2.3`, the MINOR version is `2`.

### Upgrading the FastAPI versions

You should add tests for your app.

With **FastAPI** it's very easy (thanks to Starlette), check the docs: Testing

After you have tests, then you can upgrade the **FastAPI** version to a more recent one, and make sure that all your code is working correctly by running your tests.

If everything is working, or after you make the necessary changes, and all your tests are passing, then you can pin your `fastapi` to that new recent version.

### About Starlette

You shouldn't pin the version of `starlette`.

Different versions of **FastAPI** will use a specific newer version of Starlette.

So, you can just let **FastAPI** use the correct Starlette version.

### About Pydantic

Pydantic includes the tests for **FastAPI** with its own tests, so new versions of Pydantic (above `1.0.0`) are always compatible with FastAPI.

You can pin Pydantic to any version above `1.0.0` that works for you and below `2.0.0`.

For example:




As **FastAPI** is based on the OpenAPI specification, you get automatic compatibility with many tools, including the automatic API docs (provided by Swagger UI).

One particular advantage that is not necessarily obvious is that you can **generate clients** (sometimes called **SDKs** ) for your API, for many different **programming languages**.

### OpenAPI Client Generators

There are many tools to generate clients from **OpenAPI**.

A common tool is OpenAPI Generator.

If you are building a **frontend**, a very interesting alternative is openapi-typescript-codegen.

There are also some **company-backed** Client and SDK generators based on OpenAPI (FastAPI), in some cases they can offer you **additional features** on top of high-quality generated SDKs/clients.

Some of them also ✨ **sponsor FastAPI** ✨, this ensures the continued and healthy **development** of FastAPI and its **ecosystem**.

And it shows their true commitment to FastAPI and its **community** (you), as they not only want to provide you a **good service** but also want to make sure you have a **good and healthy framework**, FastAPI. 🙇

You might want to try their services and follow their guides:

- Fern
- Speakeasy

### Generate a TypeScript Frontend Client

Let's start with a simple FastAPI application:

Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str    price: float  class ResponseMessage(BaseModel):     message: str  @app.post(&quot;/items/&quot;, response_model=ResponseMessage) async def create_item(item: Item):     return {&quot;message&quot;: &quot;item received&quot;}  @app.get(&quot;/items/&quot;, response_model=list[Item]) async def get_items():     return [         {&quot;name&quot;: &quot;Plumbus&quot;, &quot;price&quot;: 3},         {&quot;name&quot;: &quot;Portal Gun&quot;, &quot;price&quot;: 9001},     ]`

`from typing import List  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str    price: float  class ResponseMessage(BaseModel):     message: str  @app.post(&quot;/items/&quot;, response_model=ResponseMessage) async def create_item(item: Item):     return {&quot;message&quot;: &quot;item received&quot;}  @app.get(&quot;/items/&quot;, response_model=List[Item]) async def get_items():     return [         {&quot;name&quot;: &quot;Plumbus&quot;, &quot;price&quot;: 3},         {&quot;name&quot;: &quot;Portal Gun&quot;, &quot;price&quot;: 9001},     ]`

Notice that the *path operations* define the models they use for request payload and response payload, using the models `Item` and `ResponseMessage`.

#### API Docs

If you go to the API docs, you will see that it has the **schemas** for the data to be sent in requests and received in responses:

<image @ https://fastapi.tiangolo.com/img/tutorial/generate-clients/image01.png>

You can see those schemas because they were declared with the models in the app.

That information is available in the app's **OpenAPI schema**, and then shown in the API docs (by Swagger UI).

And that same information from the models that is included in OpenAPI is what can be used to **generate the client code**.

#### Generate a TypeScript Client

Now that we have the app with the models, we can generate the client code for the frontend.

##### Install `openapi-typescript-codegen`

You can install `openapi-typescript-codegen` in your frontend code with:

`$ npm install openapi-typescript-codegen --save-dev  ---&gt; 100%`

##### Generate Client Code

To generate the client code you can use the command line application `openapi` that would now be installed.

Because it is installed in the local project, you probably wouldn't be able to call that command directly, but you would put it on your `package.json` file.

It could look like this:

`{   &quot;name&quot;: &quot;frontend-app&quot;,   &quot;version&quot;: &quot;1.0.0&quot;,   &quot;description&quot;: &quot;&quot;,   &quot;main&quot;: &quot;index.js&quot;,   &quot;scripts&quot;: {     &quot;generate-client&quot;: &quot;openapi --input http://localhost:8000/openapi.json --output ./src/client --client axios&quot;  },   &quot;author&quot;: &quot;&quot;,   &quot;license&quot;: &quot;&quot;,   &quot;devDependencies&quot;: {     &quot;openapi-typescript-codegen&quot;: &quot;^0.20.1&quot;,     &quot;typescript&quot;: &quot;^4.6.2&quot;   } }`

After having that NPM `generate-client` script there, you can run it with:

`$ npm run generate-client  frontend-app@1.0.0 generate-client /home/user/code/frontend-app &gt; openapi --input http://localhost:8000/openapi.json --output ./src/client --client axios`

That command will generate code in `./src/client` and will use `axios` (the frontend HTTP library) internally.

#### Try Out the Client Code

Now you can import and use the client code, it could look like this, notice that you get autocompletion for the methods:

<image @ https://fastapi.tiangolo.com/img/tutorial/generate-clients/image02.png>

You will also get autocompletion for the payload to send:

<image @ https://fastapi.tiangolo.com/img/tutorial/generate-clients/image03.png>

Tip

Notice the autocompletion for `name` and `price`, that was defined in the FastAPI application, in the `Item` model.

You will have inline errors for the data that you send:

<image @ https://fastapi.tiangolo.com/img/tutorial/generate-clients/image04.png>

The response object will also have autocompletion:

<image @ https://fastapi.tiangolo.com/img/tutorial/generate-clients/image05.png>

In many cases your FastAPI app will be bigger, and you will probably use tags to separate different groups of *path operations*.

For example, you could have a section for **items** and another section for **users**, and they could be separated by tags:

Python 3.9+Python 3.6+

`from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     price: float  class ResponseMessage(BaseModel):     message: str  class User(BaseModel):     username: str     email: str  @app.post(&quot;/items/&quot;, response_model=ResponseMessage, tags=[&quot;items&quot;]) async def create_item(item: Item):     return {&quot;message&quot;: &quot;Item received&quot;}  @app.get(&quot;/items/&quot;, response_model=list[Item], tags=[&quot;items&quot;]) async def get_items():     return [         {&quot;name&quot;: &quot;Plumbus&quot;, &quot;price&quot;: 3},         {&quot;name&quot;: &quot;Portal Gun&quot;, &quot;price&quot;: 9001},     ]  @app.post(&quot;/users/&quot;, response_model=ResponseMessage, tags=[&quot;users&quot;]) async def create_user(user: User):     return {&quot;message&quot;: &quot;User received&quot;}`

`from typing import List  from fastapi import FastAPI from pydantic import BaseModel  app = FastAPI()  class Item(BaseModel):     name: str     price: float  class ResponseMessage(BaseModel):     message: str  class User(BaseModel):     username: str     email: str  @app.post(&quot;/items/&quot;, response_model=ResponseMessage, tags=[&quot;items&quot;]) async def create_item(item: Item):     return {&quot;message&quot;: &quot;Item received&quot;}  @app.get(&quot;/items/&quot;, response_model=List[Item], tags=[&quot;items&quot;]) async def get_items():     return [         {&quot;name&quot;: &quot;Plumbus&quot;, &quot;price&quot;: 3},         {&quot;name&quot;: &quot;Portal Gun&quot;, &quot;price&quot;: 9001},     ]  @app.post(&quot;/users/&quot;, response_model=ResponseMessage, tags=[&quot;users&quot;]) async def create_user(user: User):     return {&quot;message&quot;: &quot;User received&quot;}`

#### Generate a TypeScript Client with Tags

If you generate a client for a FastAPI app using tags, it will normally also separate the client code based on the tags.

This way you will be able to have things ordered and grouped correctly for the client code:

<image @ https://fastapi.tiangolo.com/img/tutorial/generate-clients/image06.png>

In this case you have:

- `ItemsService`
- `UsersService`

#### Client Method Names

Right now the generated method names like `createItemItemsPost` don't look very clean:

`ItemsService.createItemItemsPost({name: &quot;Plumbus&quot;, price: 5})`

...that's because the client generator uses the OpenAPI internal **operation ID** for each *path operation*.

OpenAPI requires that each operation ID is unique across all the *path operations*, so FastAPI uses the **function name**, the **path**, and the **HTTP method/operation** to generate that operation ID, because that way it can make sure that the operation IDs are unique.

But I'll show you how to improve that next. 🤓

### Custom Operation IDs and Better Method Names

You can **modify** the way these operation IDs are **generated** to make them simpler and have **simpler method names** in the clients.

In this case you will have to ensure that each operation ID is **unique** in some other way.

For example, you could make sure that each *path operation* has a tag, and then generate the operation ID based on the **tag** and the *path operation* **name** (the function name).

#### Custom Generate Unique ID Function

FastAPI uses a **unique ID** for each *path operation*, it is used for the **operation ID** and also for the names of any needed custom models, for requests or responses.

You can customize that function. It takes an `APIRoute` and outputs a string.

For example, here it is using the first tag (you will probably have only one tag) and the *path operation* name (the function name).

You can then pass that custom function to **FastAPI** as the `generate_unique_id_function` parameter:

Python 3.9+Python 3.6+

`from fastapi import FastAPI from fastapi.routing import APIRoute from pydantic import BaseModel  def custom_generate_unique_id(route: APIRoute):     return f&quot;{route.tags[0]}-{route.name}&quot;  app = FastAPI(generate_unique_id_function=custom_generate_unique_id)  class Item(BaseModel):     name: str     price: float  class ResponseMessage(BaseModel):     message: str  class User(BaseModel):     username: str     email: str  @app.post(&quot;/items/&quot;, response_model=ResponseMessage, tags=[&quot;items&quot;]) async def create_item(item: Item):     return {&quot;message&quot;: &quot;Item received&quot;}  @app.get(&quot;/items/&quot;, response_model=list[Item], tags=[&quot;items&quot;]) async def get_items():     return [         {&quot;name&quot;: &quot;Plumbus&quot;, &quot;price&quot;: 3},         {&quot;name&quot;: &quot;Portal Gun&quot;, &quot;price&quot;: 9001},     ]  @app.post(&quot;/users/&quot;, response_model=ResponseMessage, tags=[&quot;users&quot;]) async def create_user(user: User):     return {&quot;message&quot;: &quot;User received&quot;}`

`from typing import List  from fastapi import FastAPI from fastapi.routing import APIRoute from pydantic import BaseModel  def custom_generate_unique_id(route: APIRoute):     return f&quot;{route.tags[0]}-{route.name}&quot;  app = FastAPI(generate_unique_id_function=custom_generate_unique_id)  class Item(BaseModel):     name: str     price: float  class ResponseMessage(BaseModel):     message: str  class User(BaseModel):     username: str     email: str  @app.post(&quot;/items/&quot;, response_model=ResponseMessage, tags=[&quot;items&quot;]) async def create_item(item: Item):     return {&quot;message&quot;: &quot;Item received&quot;}  @app.get(&quot;/items/&quot;, response_model=List[Item], tags=[&quot;items&quot;]) async def get_items():     return [         {&quot;name&quot;: &quot;Plumbus&quot;, &quot;price&quot;: 3},         {&quot;name&quot;: &quot;Portal Gun&quot;, &quot;price&quot;: 9001},     ]  @app.post(&quot;/users/&quot;, response_model=ResponseMessage, tags=[&quot;users&quot;]) async def create_user(user: User):     return {&quot;message&quot;: &quot;User received&quot;}`

#### Generate a TypeScript Client with Custom Operation IDs

Now if you generate the client again, you will see that it has the improved method names:

<image @ https://fastapi.tiangolo.com/img/tutorial/generate-clients/image07.png>

As you see, the method names now have the tag and then the function name, now they don't include information from the URL path and the HTTP operation.

#### Preprocess the OpenAPI Specification for the Client Generator

The generated code still has some **duplicated information**.

We already know that this method is related to the **items** because that word is in the `ItemsService` (taken from the tag), but we still have the tag name prefixed in the method name too. 😕

We will probably still want to keep it for OpenAPI in general, as that will ensure that the operation IDs are **unique**.

But for the generated client we could **modify** the OpenAPI operation IDs right before generating the clients, just to make those method names nicer and **cleaner**.

We could download the OpenAPI JSON to a file `openapi.json` and then we could **remove that prefixed tag** with a script like this:

`import json from pathlib import Path  file_path = Path(&quot;./openapi.json&quot;) openapi_content = json.loads(file_path.read_text())  for path_data in openapi_content[&quot;paths&quot;].values():     for operation in path_data.values():         tag = operation[&quot;tags&quot;][0]         operation_id = operation[&quot;operationId&quot;]         to_remove = f&quot;{tag}-&quot;         new_operation_id = operation_id[len(to_remove) :]         operation[&quot;operationId&quot;] = new_operation_id  file_path.write_text(json.dumps(openapi_content))`

With that, the operation IDs would be renamed from things like `items-get_items` to just `get_items`, that way the client generator can generate simpler method names.

#### Generate a TypeScript Client with the Preprocessed OpenAPI

Now as the end result is in a file `openapi.json`, you would modify the `package.json` to use that local file, for example:

`{   &quot;name&quot;: &quot;frontend-app&quot;,   &quot;version&quot;: &quot;1.0.0&quot;,   &quot;description&quot;: &quot;&quot;,   &quot;main&quot;: &quot;index.js&quot;,   &quot;scripts&quot;: {     &quot;generate-client&quot;: &quot;openapi --input ./openapi.json --output ./src/client --client axios&quot;  },   &quot;author&quot;: &quot;&quot;,   &quot;license&quot;: &quot;&quot;,   &quot;devDependencies&quot;: {     &quot;openapi-typescript-codegen&quot;: &quot;^0.20.1&quot;,     &quot;typescript&quot;: &quot;^4.6.2&quot;   } }`

After generating the new client, you would now have **clean method names**, with all the **autocompletion**, **inline errors**, etc:

<image @ https://fastapi.tiangolo.com/img/tutorial/generate-clients/image08.png>

### Benefits

When using the automatically generated clients you would **autocompletion** for:

- Methods.
- Request payloads in the body, query parameters, etc.
- Response payloads.

You would also have **inline errors** for everything.

And whenever you update the backend code, and **regenerate** the frontend, it would have any new *path operations* available as methods, the old ones removed, and any other change would be reflected on the generated code. 🤓

This also means that if something changed it will be **reflected** on the client code automatically. And if you **build** the client it will error out if you have any **mismatch** in the data used.

So, you would **detect many errors** very early in the development cycle instead of having to wait for the errors to show up to your final users in production and then trying to debug where the problem is. ✨




It is easy to assume that HTTPS is something that is just "enabled" or not.

But it is way more complex than that.

Tip

If you are in a hurry or don't care, continue with the next sections for step by step instructions to set everything up with different techniques.

To **learn the basics of HTTPS**, from a consumer perspective, check https://howhttps.works/.

Now, from a **developer's perspective**, here are several things to have in mind while thinking about HTTPS:

- For HTTPS, **the server** needs to **have "certificates"** generated by a **third party**.
  - Those certificates are actually **acquired** from the third party, not "generated".
- Certificates have a **lifetime**.
  - They **expire**.
  - And then they need to be **renewed**, **acquired again** from the third party.
- The encryption of the connection happens at the **TCP level**.
  - That's one layer **below HTTP**.
  - So, the **certificate and encryption** handling is done **before HTTP**.
- **TCP doesn't know about "domains"**. Only about IP addresses.
  - The information about the **specific domain** requested goes in the **HTTP data**.
- The **HTTPS certificates** "certify" a **certain domain**, but the protocol and encryption happen at the TCP level, **before knowing** which domain is being dealt with.
- **By default**, that would mean that you can only have **one HTTPS certificate per IP address**.
  - No matter how big your server is or how small each application you have on it might be.
  - There is a **solution** to this, however.
- There's an **extension** to the **TLS** protocol (the one handling the encryption at the TCP level, before HTTP) called **SNI**.
  - This SNI extension allows one single server (with a **single IP address**) to have **several HTTPS certificates** and serve **multiple HTTPS domains/applications**.
  - For this to work, a **single** component (program) running on the server, listening on the **public IP address**, must have **all the HTTPS certificates** in the server.
- **After** obtaining a secure connection, the communication protocol is **still HTTP**.
  - The contents are **encrypted**, even though they are being sent with the **HTTP protocol**.

It is a common practice to have **one program/HTTP server** running on the server (the machine, host, etc.) and **managing all the HTTPS parts**: receiving the **encrypted HTTPS requests**, sending the **decrypted HTTP requests** to the actual HTTP application running in the same server (the **FastAPI** application, in this case), take the **HTTP response** from the application, **encrypt it** using the appropriate **HTTPS certificate** and sending it back to the client using **HTTPS**. This server is often called a **TLS Termination Proxy**.

Some of the options you could use as a TLS Termination Proxy are:

- Traefik (that can also handle certificate renewals)
- Caddy (that can also handle certificate renewals)
- Nginx
- HAProxy

### Let's Encrypt

Before Let's Encrypt, these **HTTPS certificates** were sold by trusted third parties.

The process to acquire one of these certificates used to be cumbersome, require quite some paperwork and the certificates were quite expensive.

But then **Let's Encrypt** was created.

It is a project from the Linux Foundation. It provides **HTTPS certificates for free**, in an automated way. These certificates use all the standard cryptographic security, and are short-lived (about 3 months), so the **security is actually better** because of their reduced lifespan.

The domains are securely verified and the certificates are generated automatically. This also allows automating the renewal of these certificates.

The idea is to automate the acquisition and renewal of these certificates so that you can have **secure HTTPS, for free, forever**.

### HTTPS for Developers

Here's an example of how an HTTPS API could look like, step by step, paying attention mainly to the ideas important for developers.

#### Domain Name

It would probably all start by you **acquiring** some **domain name**. Then, you would configure it in a DNS server (possibly your same cloud provider).

You would probably get a cloud server (a virtual machine) or something similar, and it would have a fixed **public IP address**.

In the DNS server(s) you would configure a record (an "`A record`") to point **your domain** to the public **IP address of your server**.

You would probably do this just once, the first time, when setting everything up.

Tip

This Domain Name part is way before HTTPS, but as everything depends on the domain and the IP address, it's worth mentioning it here.

#### DNS

Now let's focus on all the actual HTTPS parts.

First, the browser would check with the **DNS servers** what is the **IP for the domain**, in this case, `someapp.example.com`.

The DNS servers would tell the browser to use some specific **IP address**. That would be the public IP address used by your server, that you configured in the DNS servers.

<image @ https://fastapi.tiangolo.com/img/deployment/https/https01.svg>

#### TLS Handshake Start

The browser would then communicate with that IP address on **port 443** (the HTTPS port).

The first part of the communication is just to establish the connection between the client and the server and to decide the cryptographic keys they will use, etc.

<image @ https://fastapi.tiangolo.com/img/deployment/https/https02.svg>

This interaction between the client and the server to establish the TLS connection is called the **TLS handshake**.

#### TLS with SNI Extension

**Only one process** in the server can be listening on a specific **port** in a specific **IP address**. There could be other processes listening on other ports in the same IP address, but only one for each combination of IP address and port.

TLS (HTTPS) uses the specific port `443` by default. So that's the port we would need.

As only one process can be listening on this port, the process that would do it would be the **TLS Termination Proxy**.

The TLS Termination Proxy would have access to one or more **TLS certificates** (HTTPS certificates).

Using the **SNI extension** discussed above, the TLS Termination Proxy would check which of the TLS (HTTPS) certificates available it should use for this connection, using the one that matches the domain expected by the client.

In this case, it would use the certificate for `someapp.example.com`.

<image @ https://fastapi.tiangolo.com/img/deployment/https/https03.svg>

The client already **trusts** the entity that generated that TLS certificate (in this case Let's Encrypt, but we'll see about that later), so it can **verify** that the certificate is valid.

Then, using the certificate, the client and the TLS Termination Proxy **decide how to encrypt** the rest of the **TCP communication**. This completes the **TLS Handshake** part.

After this, the client and the server have an **encrypted TCP connection**, this is what TLS provides. And then they can use that connection to start the actual **HTTP communication**.

And that's what **HTTPS** is, it's just plain **HTTP** inside a **secure TLS connection** instead of a pure (unencrypted) TCP connection.

Tip

Notice that the encryption of the communication happens at the **TCP level**, not at the HTTP level.

#### HTTPS Request

Now that the client and server (specifically the browser and the TLS Termination Proxy) have an **encrypted TCP connection**, they can start the **HTTP communication**.

So, the client sends an **HTTPS request**. This is just an HTTP request through an encrypted TLS connection.

<image @ https://fastapi.tiangolo.com/img/deployment/https/https04.svg>

#### Decrypt the Request

The TLS Termination Proxy would use the encryption agreed to **decrypt the request**, and would transmit the **plain (decrypted) HTTP request** to the process running the application (for example a process with Uvicorn running the FastAPI application).

<image @ https://fastapi.tiangolo.com/img/deployment/https/https05.svg>

#### HTTP Response

The application would process the request and send a **plain (unencrypted) HTTP response** to the TLS Termination Proxy.

<image @ https://fastapi.tiangolo.com/img/deployment/https/https06.svg>

#### HTTPS Response

The TLS Termination Proxy would then **encrypt the response** using the cryptography agreed before (that started with the certificate for `someapp.example.com`), and send it back to the browser.

Next, the browser would verify that the response is valid and encrypted with the right cryptographic key, etc. It would then **decrypt the response** and process it.

<image @ https://fastapi.tiangolo.com/img/deployment/https/https07.svg>

The client (browser) will know that the response comes from the correct server because it is using the cryptography they agreed using the **HTTPS certificate** before.

#### Multiple Applications

In the same server (or servers), there could be **multiple applications**, for example, other API programs or a database.

Only one process can be handling the specific IP and port (the TLS Termination Proxy in our example) but the other applications/processes can be running on the server(s) too, as long as they don't try to use the same **combination of public IP and port**.

<image @ https://fastapi.tiangolo.com/img/deployment/https/https08.svg>

That way, the TLS Termination Proxy could handle HTTPS and certificates for **multiple domains**, for multiple applications, and then transmit the requests to the right application in each case.

#### Certificate Renewal

At some point in the future, each certificate would **expire** (about 3 months after acquiring it).

And then, there would be another program (in some cases it's another program, in some cases it could be the same TLS Termination Proxy) that would talk to Let's Encrypt, and renew the certificate(s).

<image @ https://fastapi.tiangolo.com/img/deployment/https/https.svg>

The **TLS certificates** are **associated with a domain name**, not with an IP address.

So, to renew the certificates, the renewal program needs to **prove** to the authority (Let's Encrypt) that it indeed **"owns" and controls that domain**.

To do that, and to accommodate different application needs, there are several ways it can do it. Some popular ways are:

- **Modify some DNS records**.
  - For this, the renewal program needs to support the APIs of the DNS provider, so, depending on the DNS provider you are using, this might or might not be an option.
- **Run as a server** (at least during the certificate acquisition process) on the public IP address associated with the domain.
  - As we said above, only one process can be listening on a specific IP and port.
  - This is one of the reasons why it's very useful when the same TLS Termination Proxy also takes care of the certificate renewal process.
  - Otherwise, you might have to stop the TLS Termination Proxy momentarily, start the renewal program to acquire the certificates, then configure them with the TLS Termination Proxy, and then restart the TLS Termination Proxy. This is not ideal, as your app(s) will not be available during the time that the TLS Termination Proxy is off.

All this renewal process, while still serving the app, is one of the main reasons why you would want to have a **separate system to handle HTTPS** with a TLS Termination Proxy instead of just using the TLS certificates with the application server directly (e.g. Uvicorn).

### Recap

Having **HTTPS** is very important, and quite **critical** in most cases. Most of the effort you as a developer have to put around HTTPS is just about **understanding these concepts** and how they work.

But once you know the basic information of **HTTPS for developers** you can easily combine and configure different tools to help you manage everything in a simple way.

In some of the next chapters, I'll show you several concrete examples of how to set up **HTTPS** for **FastAPI** applications. 🔒




The main thing you need to run a **FastAPI** application in a remote server machine is an ASGI server program like **Uvicorn**.

There are 3 main alternatives:

- Uvicorn: a high performance ASGI server.
- Hypercorn: an ASGI server compatible with HTTP/2 and Trio among other features.
- Daphne: the ASGI server built for Django Channels.

### Server Machine and Server Program

There's a small detail about names to have in mind. 💡

The word "**server**" is commonly used to refer to both the remote/cloud computer (the physical or virtual machine) and also the program that is running on that machine (e.g. Uvicorn).

Just have that in mind when you read "server" in general, it could refer to one of those two things.

When referring to the remote machine, it's common to call it **server**, but also **machine**, **VM** (virtual machine), **node**. Those all refer to some type of remote machine, normally running Linux, where you run programs.

### Install the Server Program

You can install an ASGI compatible server with:

UvicornHypercorn

- Uvicorn, a lightning-fast ASGI server, built on uvloop and httptools.

`$ pip install &quot;uvicorn[standard]&quot;  ---&gt; 100%`

Tip

By adding the `standard`, Uvicorn will install and use some recommended extra dependencies.

That including `uvloop`, the high-performance drop-in replacement for `asyncio`, that provides the big concurrency performance boost.

- Hypercorn, an ASGI server also compatible with HTTP/2.

`$ pip install hypercorn  ---&gt; 100%`

...or any other ASGI server.

### Run the Server Program

You can then run your application the same way you have done in the tutorials, but without the `--reload` option, e.g.:

UvicornHypercorn

`$ uvicorn main:app --host 0.0.0.0 --port 80  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://0.0.0.0:80 (Press CTRL+C to quit)`

`$ hypercorn main:app --bind 0.0.0.0:80  Running on 0.0.0.0:8080 over http (CTRL + C to quit)`

Warning

Remember to remove the `--reload` option if you were using it.

The `--reload` option consumes much more resources, is more unstable, etc.

It helps a lot during **development**, but you **shouldn't** use it in **production**.

### Hypercorn with Trio

Starlette and **FastAPI** are based on AnyIO, which makes them compatible with both Python's standard library asyncio and Trio.

Nevertheless, Uvicorn is currently only compatible with asyncio, and it normally uses `uvloop`, the high-performance drop-in replacement for `asyncio`.

But if you want to directly use **Trio**, then you can use **Hypercorn** as it supports it. ✨

#### Install Hypercorn with Trio

First you need to install Hypercorn with Trio support:

`$ pip install &quot;hypercorn[trio]&quot; ---&gt; 100%`

#### Run with Trio

Then you can pass the command line option `--worker-class` with the value `trio`:

`$ hypercorn main:app --worker-class trio`

And that will start Hypercorn with your app using Trio as the backend.

Now you can use Trio internally in your app. Or even better, you can use AnyIO, to keep your code compatible with both Trio and asyncio. 🎉

### Deployment Concepts

These examples run the server program (e.g Uvicorn), starting **a single process**, listening on all the IPs (`0.0.0.0`) on a predefined port (e.g. `80`).

This is the basic idea. But you will probably want to take care of some additional things, like:

- Security - HTTPS
- Running on startup
- Restarts
- Replication (the number of processes running)
- Memory
- Previous steps before starting

I'll tell you more about each of these concepts, how to think about them, and some concrete examples with strategies to handle them in the next chapters. 🚀




When deploying a **FastAPI** application, or actually, any type of web API, there are several concepts that you probably care about, and using them you can find the **most appropriate** way to **deploy your application**.

Some of the important concepts are:

- Security - HTTPS
- Running on startup
- Restarts
- Replication (the number of processes running)
- Memory
- Previous steps before starting

We'll see how they would affect **deployments**.

In the end, the ultimate objective is to be able to **serve your API clients** in a way that is **secure**, to **avoid disruptions**, and to use the **compute resources** (for example remote servers/virtual machines) as efficiently as possible. 🚀

I'll tell you a bit more about these **concepts** here, and that would hopefully give you the **intuition** you would need to decide how to deploy your API in very different environments, possibly even in **future** ones that don't exist yet.

By considering these concepts, you will be able to **evaluate and design** the best way to deploy **your own APIs**.

In the next chapters, I'll give you more **concrete recipes** to deploy FastAPI applications.

But for now, let's check these important **conceptual ideas**. These concepts also apply to any other type of web API. 💡

### Security - HTTPS

In the previous chapter about HTTPS we learned about how HTTPS provides encryption for your API.

We also saw that HTTPS is normally provided by a component **external** to your application server, a **TLS Termination Proxy**.

And there has to be something in charge of **renewing the HTTPS certificates**, it could be the same component or it could be something different.

#### Example Tools for HTTPS

Some of the tools you could use as a TLS Termination Proxy are:

- Traefik
  - Automatically handles certificates renewals ✨
- Caddy
  - Automatically handles certificates renewals ✨
- Nginx
  - With an external component like Certbot for certificate renewals
- HAProxy
  - With an external component like Certbot for certificate renewals
- Kubernetes with an Ingress Controller like Nginx
  - With an external component like cert-manager for certificate renewals
- Handled internally by a cloud provider as part of their services (read below 👇)

Another option is that you could use a **cloud service** that does more of the work including setting up HTTPS. It could have some restrictions or charge you more, etc. But in that case, you wouldn't have to set up a TLS Termination Proxy yourself.

I'll show you some concrete examples in the next chapters.

***

Then the next concepts to consider are all about the program running your actual API (e.g. Uvicorn).

### Program and Process

We will talk a lot about the running "**process**", so it's useful to have clarity about what it means, and what's the difference with the word "**program**".

#### What is a Program

The word **program** is commonly used to describe many things:

- The **code** that you write, the **Python files**.
- The **file** that can be **executed** by the operating system, for example: `python`, `python.exe` or `uvicorn`.
- A particular program while it is **running** on the operating system, using the CPU, and storing things on memory. This is also called a **process**.

#### What is a Process

The word **process** is normally used in a more specific way, only referring to the thing that is running in the operating system (like in the last point above):

- A particular program while it is **running** on the operating system.
  - This doesn't refer to the file, nor to the code, it refers **specifically** to the thing that is being **executed** and managed by the operating system.
- Any program, any code, **can only do things** when it is being **executed**. So, when there's a **process running**.
- The process can be **terminated** (or "killed") by you, or by the operating system. At that point, it stops running/being executed, and it can **no longer do things**.
- Each application that you have running on your computer has some process behind it, each running program, each window, etc. And there are normally many processes running **at the same time** while a computer is on.
- There can be **multiple processes** of the **same program** running at the same time.

If you check out the "task manager" or "system monitor" (or similar tools) in your operating system, you will be able to see many of those processes running.

And, for example, you will probably see that there are multiple processes running the same browser program (Firefox, Chrome, Edge, etc). They normally run one process per tab, plus some other extra processes.

<image @ https://fastapi.tiangolo.com/img/deployment/concepts/image01.png>

***

Now that we know the difference between the terms **process** and **program**, let's continue talking about deployments.

### Running on Startup

In most cases, when you create a web API, you want it to be **always running**, uninterrupted, so that your clients can always access it. This is of course, unless you have a specific reason why you want it to run only in certain situations, but most of the time you want it constantly running and **available**.

#### In a Remote Server

When you set up a remote server (a cloud server, a virtual machine, etc.) the simplest thing you can do is to run Uvicorn (or similar) manually, the same way you do when developing locally.

And it will work and will be useful **during development**.

But if your connection to the server is lost, the **running process** will probably die.

And if the server is restarted (for example after updates, or migrations from the cloud provider) you probably **won't notice it**. And because of that, you won't even know that you have to restart the process manually. So, your API will just stay dead. 😱

#### Run Automatically on Startup

In general, you will probably want the server program (e.g. Uvicorn) to be started automatically on server startup, and without needing any **human intervention**, to have a process always running with your API (e.g. Uvicorn running your FastAPI app).

#### Separate Program

To achieve this, you will normally have a **separate program** that would make sure your application is run on startup. And in many cases, it would also make sure other components or applications are also run, for example, a database.

#### Example Tools to Run at Startup

Some examples of the tools that can do this job are:

- Docker
- Kubernetes
- Docker Compose
- Docker in Swarm Mode
- Systemd
- Supervisor
- Handled internally by a cloud provider as part of their services
- Others...

I'll give you more concrete examples in the next chapters.

### Restarts

Similar to making sure your application is run on startup, you probably also want to make sure it is **restarted** after failures.

#### We Make Mistakes

We, as humans, make **mistakes**, all the time. Software almost *always* has **bugs** hidden in different places. 🐛

And we as developers keep improving the code as we find those bugs and as we implement new features (possibly adding new bugs too 😅).

#### Small Errors Automatically Handled

When building web APIs with FastAPI, if there's an error in our code, FastAPI will normally contain it to the single request that triggered the error. 🛡

The client will get a **500 Internal Server Error** for that request, but the application will continue working for the next requests instead of just crashing completely.

#### Bigger Errors - Crashes

Nevertheless, there might be cases where we write some code that **crashes the entire application** making Uvicorn and Python crash. 💥

And still, you would probably not want the application to stay dead because there was an error in one place, you probably want it to **continue running** at least for the *path operations* that are not broken.

#### Restart After Crash

But in those cases with really bad errors that crash the running **process**, you would want an external component that is in charge of **restarting** the process, at least a couple of times...

Tip

...Although if the whole application is just **crashing immediately** it probably doesn't make sense to keep restarting it forever. But in those cases, you will probably notice it during development, or at least right after deployment.

So let's focus on the main cases, where it could crash entirely in some particular cases **in the future**, and it still makes sense to restart it.

You would probably want to have the thing in charge of restarting your application as an **external component**, because by that point, the same application with Uvicorn and Python already crashed, so there's nothing in the same code of the same app that could do anything about it.

#### Example Tools to Restart Automatically

In most cases, the same tool that is used to **run the program on startup** is also used to handle automatic **restarts**.

For example, this could be handled by:

- Docker
- Kubernetes
- Docker Compose
- Docker in Swarm Mode
- Systemd
- Supervisor
- Handled internally by a cloud provider as part of their services
- Others...

### Replication - Processes and Memory

With a FastAPI application, using a server program like Uvicorn, running it once in **one process** can serve multiple clients concurrently.

But in many cases, you will want to run several worker processes at the same time.

#### Multiple Processes - Workers

If you have more clients than what a single process can handle (for example if the virtual machine is not too big) and you have **multiple cores** in the server's CPU, then you could have **multiple processes** running with the same application at the same time, and distribute all the requests among them.

When you run **multiple processes** of the same API program, they are commonly called **workers**.

#### Worker Processes and Ports

Remember from the docs About HTTPS that only one process can be listening on one combination of port and IP address in a server?

This is still true.

So, to be able to have **multiple processes** at the same time, there has to be a **single process listening on a port** that then transmits the communication to each worker process in some way.

#### Memory per Process

Now, when the program loads things in memory, for example, a machine learning model in a variable, or the contents of a large file in a variable, all that **consumes a bit of the memory (RAM)** of the server.

And multiple processes normally **don't share any memory**. This means that each running process has its own things, variables, and memory. And if you are consuming a large amount of memory in your code, **each process** will consume an equivalent amount of memory.

#### Server Memory

For example, if your code loads a Machine Learning model with **1 GB in size**, when you run one process with your API, it will consume at least 1 GB of RAM. And if you start **4 processes** (4 workers), each will consume 1 GB of RAM. So in total, your API will consume **4 GB of RAM**.

And if your remote server or virtual machine only has 3 GB of RAM, trying to load more than 4 GB of RAM will cause problems. 🚨

#### Multiple Processes - An Example

In this example, there's a **Manager Process** that starts and controls two **Worker Processes**.

This Manager Process would probably be the one listening on the **port** in the IP. And it would transmit all the communication to the worker processes.

Those worker processes would be the ones running your application, they would perform the main computations to receive a **request** and return a **response**, and they would load anything you put in variables in RAM.

<image @ https://fastapi.tiangolo.com/img/deployment/concepts/process-ram.svg>

And of course, the same machine would probably have **other processes** running as well, apart from your application.

An interesting detail is that the percentage of the **CPU used** by each process can **vary** a lot over time, but the **memory (RAM)** normally stays more or less **stable**.

If you have an API that does a comparable amount of computations every time and you have a lot of clients, then the **CPU utilization** will probably *also be stable* (instead of constantly going up and down quickly).

#### Examples of Replication Tools and Strategies

There can be several approaches to achieve this, and I'll tell you more about specific strategies in the next chapters, for example when talking about Docker and containers.

The main constraint to consider is that there has to be a **single** component handling the **port** in the **public IP**. And then it has to have a way to **transmit** the communication to the replicated **processes/workers**.

Here are some possible combinations and strategies:

- **Gunicorn** managing **Uvicorn workers**
  - Gunicorn would be the **process manager** listening on the **IP** and **port**, the replication would be by having **multiple Uvicorn worker processes**
- **Uvicorn** managing **Uvicorn workers**
  - One Uvicorn **process manager** would listen on the **IP** and **port**, and it would start **multiple Uvicorn worker processes**
- **Kubernetes** and other distributed **container systems**
  - Something in the **Kubernetes** layer would listen on the **IP** and **port**. The replication would be by having **multiple containers**, each with **one Uvicorn process** running
- **Cloud services** that handle this for you
  - The cloud service will probably **handle replication for you**. It would possibly let you define **a process to run**, or a **container image** to use, in any case, it would most probably be **a single Uvicorn process**, and the cloud service would be in charge of replicating it.

Tip

Don't worry if some of these items about **containers**, Docker, or Kubernetes don't make a lot of sense yet.

I'll tell you more about container images, Docker, Kubernetes, etc. in a future chapter: FastAPI in Containers - Docker.

### Previous Steps Before Starting

There are many cases where you want to perform some steps **before starting** your application.

For example, you might want to run **database migrations**.

But in most cases, you will want to perform these steps only **once**.

So, you will want to have a **single process** to perform those **previous steps**, before starting the application.

And you will have to make sure that it's a single process running those previous steps *even* if afterwards, you start **multiple processes** (multiple workers) for the application itself. If those steps were run by **multiple processes**, they would **duplicate** the work by running it on **parallel**, and if the steps were something delicate like a database migration, they could cause conflicts with each other.

Of course, there are some cases where there's no problem in running the previous steps multiple times, in that case, it's a lot easier to handle.

Tip

Also, have in mind that depending on your setup, in some cases you **might not even need any previous steps** before starting your application.

In that case, you wouldn't have to worry about any of this. 🤷

#### Examples of Previous Steps Strategies

This will **depend heavily** on the way you **deploy your system**, and it would probably be connected to the way you start programs, handling restarts, etc.

Here are some possible ideas:

- An "Init Container" in Kubernetes that runs before your app container
- A bash script that runs the previous steps and then starts your application
  - You would still need a way to start/restart *that* bash script, detect errors, etc.

### Resource Utilization

Your server(s) is (are) a **resource**, you can consume or **utilize**, with your programs, the computation time on the CPUs, and the RAM memory available.

How much of the system resources do you want to be consuming/utilizing? It might be easy to think "not much", but in reality, you will probably want to consume **as much as possible without crashing**.

If you are paying for 3 servers but you are using only a little bit of their RAM and CPU, you are probably **wasting money** 💸, and probably **wasting server electric power** 🌎, etc.

In that case, it could be better to have only 2 servers and use a higher percentage of their resources (CPU, memory, disk, network bandwidth, etc).

On the other hand, if you have 2 servers and you are using **100% of their CPU and RAM**, at some point one process will ask for more memory, and the server will have to use the disk as "memory" (which can be thousands of times slower), or even **crash**. Or one process might need to do some computation and would have to wait until the CPU is free again.

In this case, it would be better to get **one extra server** and run some processes on it so that they all have **enough RAM and CPU time**.

There's also the chance that for some reason you have a **spike** of usage of your API. Maybe it went viral, or maybe some other services or bots start using it. And you might want to have extra resources to be safe in those cases.

You could put an **arbitrary number** to target, for example, something **between 50% to 90%** of resource utilization. The point is that those are probably the main things you will want to measure and use to tweak your deployments.

You can use simple tools like `htop` to see the CPU and RAM used in your server or the amount used by each process. Or you can use more complex monitoring tools, which may be distributed across servers, etc.

### Recap

You have been reading here some of the main concepts that you would probably need to have in mind when deciding how to deploy your application:

- Security - HTTPS
- Running on startup
- Restarts
- Replication (the number of processes running)
- Memory
- Previous steps before starting

Understanding these ideas and how to apply them should give you the intuition necessary to take any decisions when configuring and tweaking your deployments. 🤓

In the next sections, I'll give you more concrete examples of possible strategies you can follow. 🚀




You can use virtually **any cloud provider** to deploy your FastAPI application.

In most of the cases, the main cloud providers have guides to deploy FastAPI with them.

Some cloud providers ✨ **sponsor FastAPI** ✨, this ensures the continued and healthy **development** of FastAPI and its **ecosystem**.

And it shows their true commitment to FastAPI and its **community** (you), as they not only want to provide you a **good service** but also want to make sure you have a **good and healthy framework**, FastAPI. 🙇

You might want to try their services and follow their guides:

- Platform.sh
- Porter
- Deta




Let's check back those deployment concepts from before:

- Security - HTTPS
- Running on startup
- Restarts
- **Replication (the number of processes running)**
- Memory
- Previous steps before starting

Up to this point, with all the tutorials in the docs, you have probably been running a **server program** like Uvicorn, running a **single process**.

When deploying applications you will probably want to have some **replication of processes** to take advantage of **multiple cores** and to be able to handle more requests.

As you saw in the previous chapter about Deployment Concepts, there are multiple strategies you can use.

Here I'll show you how to use **Gunicorn** with **Uvicorn worker processes**.

Info

If you are using containers, for example with Docker or Kubernetes, I'll tell you more about that in the next chapter: FastAPI in Containers - Docker.

In particular, when running on **Kubernetes** you will probably **not** want to use Gunicorn and instead run **a single Uvicorn process per container**, but I'll tell you about it later in that chapter.

### Gunicorn with Uvicorn Workers

**Gunicorn** is mainly an application server using the **WSGI standard**. That means that Gunicorn can serve applications like Flask and Django. Gunicorn by itself is not compatible with **FastAPI**, as FastAPI uses the newest **ASGI standard**.

But Gunicorn supports working as a **process manager** and allowing users to tell it which specific **worker process class** to use. Then Gunicorn would start one or more **worker processes** using that class.

And **Uvicorn** has a **Gunicorn-compatible worker class**.

Using that combination, Gunicorn would act as a **process manager**, listening on the **port** and the **IP**. And it would **transmit** the communication to the worker processes running the **Uvicorn class**.

And then the Gunicorn-compatible **Uvicorn worker** class would be in charge of converting the data sent by Gunicorn to the ASGI standard for FastAPI to use it.

### Install Gunicorn and Uvicorn

`$ pip install &quot;uvicorn[standard]&quot; gunicorn  ---&gt; 100%`

That will install both Uvicorn with the `standard` extra packages (to get high performance) and Gunicorn.

### Run Gunicorn with Uvicorn Workers

Then you can run Gunicorn with:

`$ gunicorn main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:80  [19499] [INFO] Starting gunicorn 20.1.0 [19499] [INFO] Listening at: http://0.0.0.0:80 (19499) [19499] [INFO] Using worker: uvicorn.workers.UvicornWorker [19511] [INFO] Booting worker with pid: 19511 [19513] [INFO] Booting worker with pid: 19513 [19514] [INFO] Booting worker with pid: 19514 [19515] [INFO] Booting worker with pid: 19515 [19511] [INFO] Started server process [19511] [19511] [INFO] Waiting for application startup. [19511] [INFO] Application startup complete. [19513] [INFO] Started server process [19513] [19513] [INFO] Waiting for application startup. [19513] [INFO] Application startup complete. [19514] [INFO] Started server process [19514] [19514] [INFO] Waiting for application startup. [19514] [INFO] Application startup complete. [19515] [INFO] Started server process [19515] [19515] [INFO] Waiting for application startup. [19515] [INFO] Application startup complete.`

Let's see what each of those options mean:

- `main:app`: This is the same syntax used by Uvicorn, `main` means the Python module named "`main`", so, a file `main.py`. And `app` is the name of the variable that is the **FastAPI** application.

  - You can imagine that `main:app` is equivalent to a Python `import` statement like:

  - So, the colon in `main:app` would be equivalent to the Python `import` part in `from main import app`.

  - `--workers`: The number of worker processes to use, each will run a Uvicorn worker, in this case, 4 workers.

  - `--worker-class`: The Gunicorn-compatible worker class to use in the worker processes.

  - Here we pass the class that Gunicorn can import and use with:

    `import uvicorn.workers.UvicornWorker`


- `--bind`: This tells Gunicorn the IP and the port to listen to, using a colon (`:`) to separate the IP and the port.

  - If you were running Uvicorn directly, instead of `--bind 0.0.0.0:80` (the Gunicorn option) you would use `--host 0.0.0.0` and `--port 80`.

In the output, you can see that it shows the **PID** (process ID) of each process (it's just a number).

You can see that:

- The Gunicorn **process manager** starts with PID `19499` (in your case it will be a different number).
- Then it starts `Listening at: http://0.0.0.0:80`.
- Then it detects that it has to use the worker class at `uvicorn.workers.UvicornWorker`.
- And then it starts **4 workers**, each with its own PID: `19511`, `19513`, `19514`, and `19515`.

Gunicorn would also take care of managing **dead processes** and **restarting** new ones if needed to keep the number of workers. So that helps in part with the **restart** concept from the list above.

Nevertheless, you would probably also want to have something outside making sure to **restart Gunicorn** if necessary, and also to **run it on startup**, etc.

### Uvicorn with Workers

Uvicorn also has an option to start and run several **worker processes**.

Nevertheless, as of now, Uvicorn's capabilities for handling worker processes are more limited than Gunicorn's. So, if you want to have a process manager at this level (at the Python level), then it might be better to try with Gunicorn as the process manager.

In any case, you would run it like this:

`$ uvicorn main:app --host 0.0.0.0 --port 8080 --workers 4 &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Uvicorn running on &lt;b&gt;http://0.0.0.0:8080&lt;/b&gt; (Press CTRL+C to quit) &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Started parent process [&lt;font color=&quot;#A1EFE4&quot;&gt;&lt;b&gt;27365&lt;/b&gt;&lt;/font&gt;] &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Started server process [&lt;font color=&quot;#A1EFE4&quot;&gt;27368&lt;/font&gt;] &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Waiting for application startup. &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Application startup complete. &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Started server process [&lt;font color=&quot;#A1EFE4&quot;&gt;27369&lt;/font&gt;] &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Waiting for application startup. &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Application startup complete. &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Started server process [&lt;font color=&quot;#A1EFE4&quot;&gt;27370&lt;/font&gt;] &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Waiting for application startup. &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Application startup complete. &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Started server process [&lt;font color=&quot;#A1EFE4&quot;&gt;27367&lt;/font&gt;] &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Waiting for application startup. &lt;font color=&quot;#A6E22E&quot;&gt;INFO&lt;/font&gt;:     Application startup complete.`

The only new option here is `--workers` telling Uvicorn to start 4 worker processes.

You can also see that it shows the **PID** of each process, `27365` for the parent process (this is the **process manager**) and one for each worker process: `27368`, `27369`, `27370`, and `27367`.

### Deployment Concepts

Here you saw how to use **Gunicorn** (or Uvicorn) managing **Uvicorn worker processes** to **parallelize** the execution of the application, take advantage of **multiple cores** in the CPU, and be able to serve **more requests**.

From the list of deployment concepts from above, using workers would mainly help with the **replication** part, and a little bit with the **restarts**, but you still need to take care of the others:

- **Security - HTTPS**
- **Running on startup**
- ***Restarts***
- Replication (the number of processes running)
- **Memory**
- **Previous steps before starting**

### Containers and Docker

In the next chapter about FastAPI in Containers - Docker I'll tell some strategies you could use to handle the other **deployment concepts**.

I'll also show you the **official Docker image** that includes **Gunicorn with Uvicorn workers** and some default configurations that can be useful for simple cases.

There I'll also show you how to **build your own image from scratch** to run a single Uvicorn process (without Gunicorn). It is a simple process and is probably what you would want to do when using a distributed container management system like **Kubernetes**.

### Recap

You can use **Gunicorn** (or also Uvicorn) as a process manager with Uvicorn workers to take advantage of **multi-core CPUs**, to run **multiple processes in parallel**.

You could use these tools and ideas if you are setting up **your own deployment system** while taking care of the other deployment concepts yourself.

Check out the next chapter to learn about **FastAPI** with containers (e.g. Docker and Kubernetes). You will see that those tools have simple ways to solve the other **deployment concepts** as well. ✨




Here are several pointers to other places in the docs, for general or frequent questions.

### Filter Data - Security

To ensure that you don't return more data than you should, read the docs for Tutorial - Response Model - Return Type.

To add tags to your *path operations*, and group them in the docs UI, read the docs for Tutorial - Path Operation Configurations - Tags.

### Documentation Summary and Description - OpenAPI

To add a summary and description to your *path operations*, and show them in the docs UI, read the docs for Tutorial - Path Operation Configurations - Summary and Description.

### Documentation Response description - OpenAPI

To define the description of the response, shown in the docs UI, read the docs for Tutorial - Path Operation Configurations - Response description.

### Documentation Deprecate a *Path Operation* - OpenAPI

To deprecate a *path operation*, and show it in the docs UI, read the docs for Tutorial - Path Operation Configurations - Deprecation.

### Convert any Data to JSON-compatible

To convert any data to JSON-compatible, read the docs for Tutorial - JSON Compatible Encoder.

To add metadata to your OpenAPI schema, including a license, version, contact, etc, read the docs for Tutorial - Metadata and Docs URLs.

### OpenAPI Custom URL

To customize the OpenAPI URL (or remove it), read the docs for Tutorial - Metadata and Docs URLs.

### OpenAPI Docs URLs

To update the URLs used for the automatically generated docs user interfaces, read the docs for Tutorial - Metadata and Docs URLs.




Info

These docs are about to be updated. 🎉

The current version assumes Pydantic v1.

The new docs will include Pydantic v2 and will use SQLModel once it is updated to use Pydantic v2 as well.

You can also use `encode/databases` with **FastAPI** to connect to databases using `async` and `await`.

It is compatible with:

- PostgreSQL
- MySQL
- SQLite

In this example, we'll use **SQLite**, because it uses a single file and Python has integrated support. So, you can copy this example and run it as is.

Later, for your production application, you might want to use a database server like **PostgreSQL**.

Tip

You could adopt ideas from the section about SQLAlchemy ORM (SQL (Relational) Databases), like using utility functions to perform operations in the database, independent of your **FastAPI** code.

This section doesn't apply those ideas, to be equivalent to the counterpart in Starlette.

### Import and set up `SQLAlchemy`

- Import `SQLAlchemy`.
- Create a `metadata` object.
- Create a table `notes` using the `metadata` object.

`from typing import List  import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel  # SQLAlchemy specific code, as with any other app DATABASE_URL = &quot;sqlite:///./test.db&quot; # DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;  database = databases.Database(DATABASE_URL)  metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table(     &quot;notes&quot;,    metadata,    sqlalchemy.Column(&quot;id&quot;, sqlalchemy.Integer, primary_key=True),    sqlalchemy.Column(&quot;text&quot;, sqlalchemy.String),    sqlalchemy.Column(&quot;completed&quot;, sqlalchemy.Boolean), )  engine = sqlalchemy.create_engine(     DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False} ) metadata.create_all(engine)  class NoteIn(BaseModel):     text: str     completed: bool  class Note(BaseModel):     id: int     text: str     completed: bool  app = FastAPI()  @app.on_event(&quot;startup&quot;) async def startup():     await database.connect()  @app.on_event(&quot;shutdown&quot;) async def shutdown():     await database.disconnect()  @app.get(&quot;/notes/&quot;, response_model=List[Note]) async def read_notes():     query = notes.select()     return await database.fetch_all(query)  @app.post(&quot;/notes/&quot;, response_model=Note) async def create_note(note: NoteIn):     query = notes.insert().values(text=note.text, completed=note.completed)     last_record_id = await database.execute(query)     return {**note.dict(), &quot;id&quot;: last_record_id}`

Tip

Notice that all this code is pure SQLAlchemy Core.

`databases` is not doing anything here yet.

### Import and set up `databases`

- Import `databases`.
- Create a `DATABASE_URL`.
- Create a `database` object.

`from typing import List  import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel  # SQLAlchemy specific code, as with any other app DATABASE_URL = &quot;sqlite:///./test.db&quot; # DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;  database = databases.Database(DATABASE_URL) metadata = sqlalchemy.MetaData()  notes = sqlalchemy.Table(     &quot;notes&quot;,     metadata,     sqlalchemy.Column(&quot;id&quot;, sqlalchemy.Integer, primary_key=True),     sqlalchemy.Column(&quot;text&quot;, sqlalchemy.String),     sqlalchemy.Column(&quot;completed&quot;, sqlalchemy.Boolean), )  engine = sqlalchemy.create_engine(     DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False} ) metadata.create_all(engine)  class NoteIn(BaseModel):     text: str     completed: bool  class Note(BaseModel):     id: int     text: str     completed: bool  app = FastAPI()  @app.on_event(&quot;startup&quot;) async def startup():     await database.connect()  @app.on_event(&quot;shutdown&quot;) async def shutdown():     await database.disconnect()  @app.get(&quot;/notes/&quot;, response_model=List[Note]) async def read_notes():     query = notes.select()     return await database.fetch_all(query)  @app.post(&quot;/notes/&quot;, response_model=Note) async def create_note(note: NoteIn):     query = notes.insert().values(text=note.text, completed=note.completed)     last_record_id = await database.execute(query)     return {**note.dict(), &quot;id&quot;: last_record_id}`

Tip

If you were connecting to a different database (e.g. PostgreSQL), you would need to change the `DATABASE_URL`.

### Create the tables

In this case, we are creating the tables in the same Python file, but in production, you would probably want to create them with Alembic, integrated with migrations, etc.

Here, this section would run directly, right before starting your **FastAPI** application.

- Create an `engine`.
- Create all the tables from the `metadata` object.

`from typing import List  import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel  # SQLAlchemy specific code, as with any other app DATABASE_URL = &quot;sqlite:///./test.db&quot; # DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;  database = databases.Database(DATABASE_URL)  metadata = sqlalchemy.MetaData()  notes = sqlalchemy.Table(     &quot;notes&quot;,     metadata,     sqlalchemy.Column(&quot;id&quot;, sqlalchemy.Integer, primary_key=True),     sqlalchemy.Column(&quot;text&quot;, sqlalchemy.String),     sqlalchemy.Column(&quot;completed&quot;, sqlalchemy.Boolean), )  engine = sqlalchemy.create_engine(     DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False} ) metadata.create_all(engine)  class NoteIn(BaseModel):     text: str     completed: bool  class Note(BaseModel):     id: int     text: str     completed: bool  app = FastAPI()  @app.on_event(&quot;startup&quot;) async def startup():     await database.connect()  @app.on_event(&quot;shutdown&quot;) async def shutdown():     await database.disconnect()  @app.get(&quot;/notes/&quot;, response_model=List[Note]) async def read_notes():     query = notes.select()     return await database.fetch_all(query)  @app.post(&quot;/notes/&quot;, response_model=Note) async def create_note(note: NoteIn):     query = notes.insert().values(text=note.text, completed=note.completed)     last_record_id = await database.execute(query)     return {**note.dict(), &quot;id&quot;: last_record_id}`

### Create models

Create Pydantic models for:

- Notes to be created (`NoteIn`).
- Notes to be returned (`Note`).

`from typing import List  import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel  # SQLAlchemy specific code, as with any other app DATABASE_URL = &quot;sqlite:///./test.db&quot; # DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;  database = databases.Database(DATABASE_URL)  metadata = sqlalchemy.MetaData()  notes = sqlalchemy.Table(     &quot;notes&quot;,     metadata,     sqlalchemy.Column(&quot;id&quot;, sqlalchemy.Integer, primary_key=True),     sqlalchemy.Column(&quot;text&quot;, sqlalchemy.String),     sqlalchemy.Column(&quot;completed&quot;, sqlalchemy.Boolean), )  engine = sqlalchemy.create_engine(     DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False} ) metadata.create_all(engine)  class NoteIn(BaseModel):     text: str    completed: bool  class Note(BaseModel):     id: int    text: str    completed: bool  app = FastAPI()  @app.on_event(&quot;startup&quot;) async def startup():     await database.connect()  @app.on_event(&quot;shutdown&quot;) async def shutdown():     await database.disconnect()  @app.get(&quot;/notes/&quot;, response_model=List[Note]) async def read_notes():     query = notes.select()     return await database.fetch_all(query)  @app.post(&quot;/notes/&quot;, response_model=Note) async def create_note(note: NoteIn):     query = notes.insert().values(text=note.text, completed=note.completed)     last_record_id = await database.execute(query)     return {**note.dict(), &quot;id&quot;: last_record_id}`

By creating these Pydantic models, the input data will be validated, serialized (converted), and annotated (documented).

So, you will be able to see it all in the interactive API docs.

### Connect and disconnect

- Create your `FastAPI` application.
- Create event handlers to connect and disconnect from the database.

`from typing import List  import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel  # SQLAlchemy specific code, as with any other app DATABASE_URL = &quot;sqlite:///./test.db&quot; # DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;  database = databases.Database(DATABASE_URL)  metadata = sqlalchemy.MetaData()  notes = sqlalchemy.Table(     &quot;notes&quot;,     metadata,     sqlalchemy.Column(&quot;id&quot;, sqlalchemy.Integer, primary_key=True),     sqlalchemy.Column(&quot;text&quot;, sqlalchemy.String),     sqlalchemy.Column(&quot;completed&quot;, sqlalchemy.Boolean), )  engine = sqlalchemy.create_engine(     DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False} ) metadata.create_all(engine)  class NoteIn(BaseModel):     text: str     completed: bool  class Note(BaseModel):     id: int     text: str     completed: bool  app = FastAPI()  @app.on_event(&quot;startup&quot;) async def startup():     await database.connect()  @app.on_event(&quot;shutdown&quot;) async def shutdown():     await database.disconnect()  @app.get(&quot;/notes/&quot;, response_model=List[Note]) async def read_notes():     query = notes.select()     return await database.fetch_all(query)  @app.post(&quot;/notes/&quot;, response_model=Note) async def create_note(note: NoteIn):     query = notes.insert().values(text=note.text, completed=note.completed)     last_record_id = await database.execute(query)     return {**note.dict(), &quot;id&quot;: last_record_id}`

### Read notes

Create the *path operation function* to read notes:

`from typing import List  import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel  # SQLAlchemy specific code, as with any other app DATABASE_URL = &quot;sqlite:///./test.db&quot; # DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;  database = databases.Database(DATABASE_URL)  metadata = sqlalchemy.MetaData()  notes = sqlalchemy.Table(     &quot;notes&quot;,     metadata,     sqlalchemy.Column(&quot;id&quot;, sqlalchemy.Integer, primary_key=True),     sqlalchemy.Column(&quot;text&quot;, sqlalchemy.String),     sqlalchemy.Column(&quot;completed&quot;, sqlalchemy.Boolean), )  engine = sqlalchemy.create_engine(     DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False} ) metadata.create_all(engine)  class NoteIn(BaseModel):     text: str     completed: bool  class Note(BaseModel):     id: int     text: str     completed: bool  app = FastAPI()  @app.on_event(&quot;startup&quot;) async def startup():     await database.connect()  @app.on_event(&quot;shutdown&quot;) async def shutdown():     await database.disconnect()  @app.get(&quot;/notes/&quot;, response_model=List[Note]) async def read_notes():     query = notes.select()    return await database.fetch_all(query)  @app.post(&quot;/notes/&quot;, response_model=Note) async def create_note(note: NoteIn):     query = notes.insert().values(text=note.text, completed=note.completed)     last_record_id = await database.execute(query)     return {**note.dict(), &quot;id&quot;: last_record_id}`

Note

Notice that as we communicate with the database using `await`, the *path operation function* is declared with `async`.

#### Notice the `response_model=List[Note]`

It uses `typing.List`.

That documents (and validates, serializes, filters) the output data, as a `list` of `Note`s.

### Create notes

Create the *path operation function* to create notes:

`from typing import List  import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel  # SQLAlchemy specific code, as with any other app DATABASE_URL = &quot;sqlite:///./test.db&quot; # DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;  database = databases.Database(DATABASE_URL)  metadata = sqlalchemy.MetaData()  notes = sqlalchemy.Table(     &quot;notes&quot;,     metadata,     sqlalchemy.Column(&quot;id&quot;, sqlalchemy.Integer, primary_key=True),     sqlalchemy.Column(&quot;text&quot;, sqlalchemy.String),     sqlalchemy.Column(&quot;completed&quot;, sqlalchemy.Boolean), )  engine = sqlalchemy.create_engine(     DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False} ) metadata.create_all(engine)  class NoteIn(BaseModel):     text: str     completed: bool  class Note(BaseModel):     id: int     text: str     completed: bool  app = FastAPI()  @app.on_event(&quot;startup&quot;) async def startup():     await database.connect()  @app.on_event(&quot;shutdown&quot;) async def shutdown():     await database.disconnect()  @app.get(&quot;/notes/&quot;, response_model=List[Note]) async def read_notes():     query = notes.select()     return await database.fetch_all(query)  @app.post(&quot;/notes/&quot;, response_model=Note) async def create_note(note: NoteIn):     query = notes.insert().values(text=note.text, completed=note.completed)    last_record_id = await database.execute(query)    return {**note.dict(), &quot;id&quot;: last_record_id}`

Note

Notice that as we communicate with the database using `await`, the *path operation function* is declared with `async`.

#### About `{**note.dict(), &quot;id&quot;: last_record_id}`

`note` is a Pydantic `Note` object.

`note.dict()` returns a `dict` with its data, something like:

`{     &quot;text&quot;: &quot;Some note&quot;,     &quot;completed&quot;: False, }`

but it doesn't have the `id` field.

So we create a new `dict`, that contains the key-value pairs from `note.dict()` with:

`**note.dict()` "unpacks" the key value pairs directly, so, `{**note.dict()}` would be, more or less, a copy of `note.dict()`.

And then, we extend that copy `dict`, adding another key-value pair: `&quot;id&quot;: last_record_id`:

`{**note.dict(), &quot;id&quot;: last_record_id}`

So, the final result returned would be something like:

`{     &quot;id&quot;: 1,     &quot;text&quot;: &quot;Some note&quot;,     &quot;completed&quot;: False, }`

### Check it

You can copy this code as is, and see the docs at http://127.0.0.1:8000/docs.

There you can see all your API documented and interact with it:

<image @ https://fastapi.tiangolo.com/img/tutorial/async-sql-databases/image01.png>

### More info

You can read more about `encode/databases` at its GitHub page.




When deploying FastAPI applications a common approach is to build a **Linux container image**. It's normally done using **Docker**. You can then deploy that container image in one of a few possible ways.

Using Linux containers has several advantages including **security**, **replicability**, **simplicity**, and others.

Tip

In a hurry and already know this stuff? Jump to the `Dockerfile` below 👇.

Dockerfile Preview 👀

`FROM python:3.9  WORKDIR /code  COPY ./requirements.txt /code/requirements.txt  RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt  COPY ./app /code/app  CMD [&quot;uvicorn&quot;, &quot;app.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;80&quot;]  # If running behind a proxy like Nginx or Traefik add --proxy-headers # CMD [&quot;uvicorn&quot;, &quot;app.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;80&quot;, &quot;--proxy-headers&quot;]`

### What is a Container

Containers (mainly Linux containers) are a very **lightweight** way to package applications including all their dependencies and necessary files while keeping them isolated from other containers (other applications or components) in the same system.

Linux containers run using the same Linux kernel of the host (machine, virtual machine, cloud server, etc). This just means that they are very lightweight (compared to full virtual machines emulating an entire operating system).

This way, containers consume **little resources**, an amount comparable to running the processes directly (a virtual machine would consume much more).

Containers also have their own **isolated** running processes (commonly just one process), file system, and network, simplifying deployment, security, development, etc.

### What is a Container Image

A **container** is run from a **container image**.

A container image is a **static** version of all the files, environment variables, and the default command/program that should be present in a container. **Static** here means that the container **image** is not running, it's not being executed, it's only the packaged files and metadata.

In contrast to a "**container image**" that is the stored static contents, a "**container**" normally refers to the running instance, the thing that is being **executed**.

When the **container** is started and running (started from a **container image**) it could create or change files, environment variables, etc. Those changes will exist only in that container, but would not persist in the underlying container image (would not be saved to disk).

A container image is comparable to the **program** file and contents, e.g. `python` and some file `main.py`.

And the **container** itself (in contrast to the **container image**) is the actual running instance of the image, comparable to a **process**. In fact, a container is running only when it has a **process running** (and normally it's only a single process). The container stops when there's no process running in it.

### Container Images

Docker has been one of the main tools to create and manage **container images** and **containers**.

And there's a public Docker Hub with pre-made **official container images** for many tools, environments, databases, and applications.

For example, there's an official Python Image.

And there are many other images for different things like databases, for example for:

- PostgreSQL
- MySQL
- MongoDB
- Redis, etc.

By using a pre-made container image it's very easy to **combine** and use different tools. For example, to try out a new database. In most cases, you can use the **official images**, and just configure them with environment variables.

That way, in many cases you can learn about containers and Docker and re-use that knowledge with many different tools and components.

So, you would run **multiple containers** with different things, like a database, a Python application, a web server with a React frontend application, and connect them together via their internal network.

All the container management systems (like Docker or Kubernetes) have these networking features integrated into them.

### Containers and Processes

A **container image** normally includes in its metadata the default program or command that should be run when the **container** is started and the parameters to be passed to that program. Very similar to what would be if it was in the command line.

When a **container** is started, it will run that command/program (although you can override it and make it run a different command/program).

A container is running as long as the **main process** (command or program) is running.

A container normally has a **single process**, but it's also possible to start subprocesses from the main process, and that way you will have **multiple processes** in the same container.

But it's not possible to have a running container without **at least one running process**. If the main process stops, the container stops.

### Build a Docker Image for FastAPI

Okay, let's build something now! 🚀

I'll show you how to build a **Docker image** for FastAPI **from scratch**, based on the **official Python** image.

This is what you would want to do in **most cases**, for example:

- Using **Kubernetes** or similar tools
- When running on a **Raspberry Pi**
- Using a cloud service that would run a container image for you, etc.

#### Package Requirements

You would normally have the **package requirements** for your application in some file.

It would depend mainly on the tool you use to **install** those requirements.

The most common way to do it is to have a file `requirements.txt` with the package names and their versions, one per line.

You would of course use the same ideas you read in About FastAPI versions to set the ranges of versions.

For example, your `requirements.txt` could look like:

`fastapi&gt;=0.68.0,&lt;0.69.0 pydantic&gt;=1.8.0,&lt;2.0.0 uvicorn&gt;=0.15.0,&lt;0.16.0`

And you would normally install those package dependencies with `pip`, for example:

`$ pip install -r requirements.txt ---&gt; 100% Successfully installed fastapi pydantic uvicorn`

Info

There are other formats and tools to define and install package dependencies.

I'll show you an example using Poetry later in a section below. 👇

#### Create the **FastAPI** Code

- Create an `app` directory and enter it.
- Create an empty file `__init__.py`.
- Create a `main.py` file with:

`from typing import Union  from fastapi import FastAPI  app = FastAPI()  @app.get(&quot;/&quot;) def read_root():     return {&quot;Hello&quot;: &quot;World&quot;}  @app.get(&quot;/items/{item_id}&quot;) def read_item(item_id: int, q: Union[str, None] = None):     return {&quot;item_id&quot;: item_id, &quot;q&quot;: q}`

#### Dockerfile

Now in the same project directory create a file `Dockerfile` with:

`# (1) FROM python:3.9  # (2) WORKDIR /code  # (3) COPY ./requirements.txt /code/requirements.txt  # (4) RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt  # (5) COPY ./app /code/app  # (6) CMD [&quot;uvicorn&quot;, &quot;app.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;80&quot;]`

1. Start from the official Python base image.

2. Set the current working directory to `/code`.

   This is where we'll put the `requirements.txt` file and the `app` directory.

3. Copy the file with the requirements to the `/code` directory.

   Copy **only** the file with the requirements first, not the rest of the code.

   As this file **doesn't change often**, Docker will detect it and use the **cache** for this step, enabling the cache for the next step too.

4. Install the package dependencies in the requirements file.

   The `--no-cache-dir` option tells `pip` to not save the downloaded packages locally, as that is only if `pip` was going to be run again to install the same packages, but that's not the case when working with containers.

   Note

   The `--no-cache-dir` is only related to `pip`, it has nothing to do with Docker or containers.

   The `--upgrade` option tells `pip` to upgrade the packages if they are already installed.

   Because the previous step copying the file could be detected by the **Docker cache**, this step will also **use the Docker cache** when available.

   Using the cache in this step will **save** you a lot of **time** when building the image again and again during development, instead of **downloading and installing** all the dependencies **every time**.

5. Copy the `./app` directory inside the `/code` directory.

   As this has all the code which is what **changes most frequently** the Docker **cache** won't be used for this or any **following steps** easily.

   So, it's important to put this **near the end** of the `Dockerfile`, to optimize the container image build times.

6. Set the **command** to run the `uvicorn` server.

   `CMD` takes a list of strings, each of these strings is what you would type in the command line separated by spaces.

   This command will be run from the **current working directory**, the same `/code` directory you set above with `WORKDIR /code`.

   Because the program will be started at `/code` and inside of it is the directory `./app` with your code, **Uvicorn** will be able to see and **import** `app` from `app.main`.

Tip

Review what each line does by clicking each number bubble in the code. 👆

You should now have a directory structure like:

`. ├── app │   ├── __init__.py │   └── main.py ├── Dockerfile └── requirements.txt`

##### Behind a TLS Termination Proxy

If you are running your container behind a TLS Termination Proxy (load balancer) like Nginx or Traefik, add the option `--proxy-headers`, this will tell Uvicorn to trust the headers sent by that proxy telling it that the application is running behind HTTPS, etc.

`CMD [&quot;uvicorn&quot;, &quot;app.main:app&quot;, &quot;--proxy-headers&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;80&quot;]`

##### Docker Cache

There's an important trick in this `Dockerfile`, we first copy the **file with the dependencies alone**, not the rest of the code. Let me tell you why is that.

`COPY ./requirements.txt /code/requirements.txt`

Docker and other tools **build** these container images **incrementally**, adding **one layer on top of the other**, starting from the top of the `Dockerfile` and adding any files created by each of the instructions of the `Dockerfile`.

Docker and similar tools also use an **internal cache** when building the image, if a file hasn't changed since the last time building the container image, then it will **re-use the same layer** created the last time, instead of copying the file again and creating a new layer from scratch.

Just avoiding the copy of files doesn't necessarily improve things too much, but because it used the cache for that step, it can **use the cache for the next step**. For example, it could use the cache for the instruction that installs dependencies with:

`RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt`

The file with the package requirements **won't change frequently**. So, by copying only that file, Docker will be able to **use the cache** for that step.

And then, Docker will be able to **use the cache for the next step** that downloads and install those dependencies. And here's where we **save a lot of time**. ✨ ...and avoid boredom waiting. 😪😆

Downloading and installing the package dependencies **could take minutes**, but using the **cache** would **take seconds** at most.

And as you would be building the container image again and again during development to check that your code changes are working, there's a lot of accumulated time this would save.

Then, near the end of the `Dockerfile`, we copy all the code. As this is what **changes most frequently**, we put it near the end, because almost always, anything after this step will not be able to use the cache.

#### Build the Docker Image

Now that all the files are in place, let's build the container image.

- Go to the project directory (in where your `Dockerfile` is, containing your `app` directory).
- Build your FastAPI image:

`$ docker build -t myimage .  ---&gt; 100%`

Tip

Notice the `.` at the end, it's equivalent to `./`, it tells Docker the directory to use to build the container image.

In this case, it's the same current directory (`.`).

#### Start the Docker Container

- Run a container based on your image:

`$ docker run -d --name mycontainer -p 80:80 myimage`

### Check it

You should be able to check it in your Docker container's URL, for example: http://192.168.99.100/items/5?q=somequery or http://127.0.0.1/items/5?q=somequery (or equivalent, using your Docker host).

You will see something like:

`{&quot;item_id&quot;: 5, &quot;q&quot;: &quot;somequery&quot;}`

### Interactive API docs

Now you can go to http://192.168.99.100/docs or http://127.0.0.1/docs (or equivalent, using your Docker host).

You will see the automatic interactive API documentation (provided by Swagger UI):

<image @ https://fastapi.tiangolo.com/img/index/index-01-swagger-ui-simple.png>

### Alternative API docs

And you can also go to http://192.168.99.100/redoc or http://127.0.0.1/redoc (or equivalent, using your Docker host).

You will see the alternative automatic documentation (provided by ReDoc):

<image @ https://fastapi.tiangolo.com/img/index/index-02-redoc-simple.png>

### Build a Docker Image with a Single-File FastAPI

If your FastAPI is a single file, for example, `main.py` without an `./app` directory, your file structure could look like this:

`. ├── Dockerfile ├── main.py └── requirements.txt`

Then you would just have to change the corresponding paths to copy the file inside the `Dockerfile`:

`FROM python:3.9  WORKDIR /code  COPY ./requirements.txt /code/requirements.txt  RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt  # (1) COPY ./main.py /code/ # (2) CMD [&quot;uvicorn&quot;, &quot;main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;80&quot;]`

1. Copy the `main.py` file to the `/code` directory directly (without any `./app` directory).

2. Run Uvicorn and tell it to import the `app` object from `main` (instead of importing from `app.main`).

Then adjust the Uvicorn command to use the new module `main` instead of `app.main` to import the FastAPI object `app`.

### Deployment Concepts

Let's talk again about some of the same Deployment Concepts in terms of containers.

Containers are mainly a tool to simplify the process of **building and deploying** an application, but they don't enforce a particular approach to handle these **deployment concepts**, and there are several possible strategies.

The **good news** is that with each different strategy there's a way to cover all of the deployment concepts. 🎉

Let's review these **deployment concepts** in terms of containers:

- HTTPS
- Running on startup
- Restarts
- Replication (the number of processes running)
- Memory
- Previous steps before starting

### HTTPS

If we focus just on the **container image** for a FastAPI application (and later the running **container**), HTTPS normally would be handled **externally** by another tool.

It could be another container, for example with Traefik, handling **HTTPS** and **automatic** acquisition of **certificates**.

Tip

Traefik has integrations with Docker, Kubernetes, and others, so it's very easy to set up and configure HTTPS for your containers with it.

Alternatively, HTTPS could be handled by a cloud provider as one of their services (while still running the application in a container).

### Running on Startup and Restarts

There is normally another tool in charge of **starting and running** your container.

It could be **Docker** directly, **Docker Compose**, **Kubernetes**, a **cloud service**, etc.

In most (or all) cases, there's a simple option to enable running the container on startup and enabling restarts on failures. For example, in Docker, it's the command line option `--restart`.

Without using containers, making applications run on startup and with restarts can be cumbersome and difficult. But when **working with containers** in most cases that functionality is included by default. ✨

### Replication - Number of Processes

If you have a cluster of machines with **Kubernetes**, Docker Swarm Mode, Nomad, or another similar complex system to manage distributed containers on multiple machines, then you will probably want to **handle replication** at the **cluster level** instead of using a **process manager** (like Gunicorn with workers) in each container.

One of those distributed container management systems like Kubernetes normally has some integrated way of handling **replication of containers** while still supporting **load balancing** for the incoming requests. All at the **cluster level**.

In those cases, you would probably want to build a **Docker image from scratch** as explained above, installing your dependencies, and running **a single Uvicorn process** instead of running something like Gunicorn with Uvicorn workers.

#### Load Balancer

When using containers, you would normally have some component **listening on the main port**. It could possibly be another container that is also a **TLS Termination Proxy** to handle **HTTPS** or some similar tool.

As this component would take the **load** of requests and distribute that among the workers in a (hopefully) **balanced** way, it is also commonly called a **Load Balancer**.

Tip

The same **TLS Termination Proxy** component used for HTTPS would probably also be a **Load Balancer**.

And when working with containers, the same system you use to start and manage them would already have internal tools to transmit the **network communication** (e.g. HTTP requests) from that **load balancer** (that could also be a **TLS Termination Proxy**) to the container(s) with your app.

#### One Load Balancer - Multiple Worker Containers

When working with **Kubernetes** or similar distributed container management systems, using their internal networking mechanisms would allow the single **load balancer** that is listening on the main **port** to transmit communication (requests) to possibly **multiple containers** running your app.

Each of these containers running your app would normally have **just one process** (e.g. a Uvicorn process running your FastAPI application). They would all be **identical containers**, running the same thing, but each with its own process, memory, etc. That way you would take advantage of **parallelization** in **different cores** of the CPU, or even in **different machines**.

And the distributed container system with the **load balancer** would **distribute the requests** to each one of the containers with your app **in turns**. So, each request could be handled by one of the multiple **replicated containers** running your app.

And normally this **load balancer** would be able to handle requests that go to *other* apps in your cluster (e.g. to a different domain, or under a different URL path prefix), and would transmit that communication to the right containers for *that other* application running in your cluster.

#### One Process per Container

In this type of scenario, you probably would want to have **a single (Uvicorn) process per container**, as you would already be handling replication at the cluster level.

So, in this case, you **would not** want to have a process manager like Gunicorn with Uvicorn workers, or Uvicorn using its own Uvicorn workers. You would want to have just a **single Uvicorn process** per container (but probably multiple containers).

Having another process manager inside the container (as would be with Gunicorn or Uvicorn managing Uvicorn workers) would only add **unnecessary complexity** that you are most probably already taking care of with your cluster system.

#### Containers with Multiple Processes and Special Cases

Of course, there are **special cases** where you could want to have **a container** with a **Gunicorn process manager** starting several **Uvicorn worker processes** inside.

In those cases, you can use the **official Docker image** that includes **Gunicorn** as a process manager running multiple **Uvicorn worker processes**, and some default settings to adjust the number of workers based on the current CPU cores automatically. I'll tell you more about it below in Official Docker Image with Gunicorn - Uvicorn.

Here are some examples of when that could make sense:

##### A Simple App

You could want a process manager in the container if your application is **simple enough** that you don't need (at least not yet) to fine-tune the number of processes too much, and you can just use an automated default (with the official Docker image), and you are running it on a **single server**, not a cluster.

##### Docker Compose

You could be deploying to a **single server** (not a cluster) with **Docker Compose**, so you wouldn't have an easy way to manage replication of containers (with Docker Compose) while preserving the shared network and **load balancing**.

Then you could want to have **a single container** with a **process manager** starting **several worker processes** inside.

##### Prometheus and Other Reasons

You could also have **other reasons** that would make it easier to have a **single container** with **multiple processes** instead of having **multiple containers** with **a single process** in each of them.

For example (depending on your setup) you could have some tool like a Prometheus exporter in the same container that should have access to **each of the requests** that come.

In this case, if you had **multiple containers**, by default, when Prometheus came to **read the metrics**, it would get the ones for **a single container each time** (for the container that handled that particular request), instead of getting the **accumulated metrics** for all the replicated containers.

Then, in that case, it could be simpler to have **one container** with **multiple processes**, and a local tool (e.g. a Prometheus exporter) on the same container collecting Prometheus metrics for all the internal processes and exposing those metrics on that single container.

***

The main point is, **none** of these are **rules written in stone** that you have to blindly follow. You can use these ideas to **evaluate your own use case** and decide what is the best approach for your system, checking out how to manage the concepts of:

- Security - HTTPS
- Running on startup
- Restarts
- Replication (the number of processes running)
- Memory
- Previous steps before starting

### Memory

If you run **a single process per container** you will have a more or less well-defined, stable, and limited amount of memory consumed by each of those containers (more than one if they are replicated).

And then you can set those same memory limits and requirements in your configurations for your container management system (for example in **Kubernetes**). That way it will be able to **replicate the containers** in the **available machines** taking into account the amount of memory needed by them, and the amount available in the machines in the cluster.

If your application is **simple**, this will probably **not be a problem**, and you might not need to specify hard memory limits. But if you are **using a lot of memory** (for example with **machine learning** models), you should check how much memory you are consuming and adjust the **number of containers** that runs in **each machine** (and maybe add more machines to your cluster).

If you run **multiple processes per container** (for example with the official Docker image) you will have to make sure that the number of processes started doesn't **consume more memory** than what is available.

### Previous Steps Before Starting and Containers

If you are using containers (e.g. Docker, Kubernetes), then there are two main approaches you can use.

#### Multiple Containers

If you have **multiple containers**, probably each one running a **single process** (for example, in a **Kubernetes** cluster), then you would probably want to have a **separate container** doing the work of the **previous steps** in a single container, running a single process, **before** running the replicated worker containers.

Info

If you are using Kubernetes, this would probably be an Init Container.

If in your use case there's no problem in running those previous steps **multiple times in parallel** (for example if you are not running database migrations, but just checking if the database is ready yet), then you could also just put them in each container right before starting the main process.

#### Single Container

If you have a simple setup, with a **single container** that then starts multiple **worker processes** (or also just one process), then you could run those previous steps in the same container, right before starting the process with the app. The official Docker image supports this internally.

### Official Docker Image with Gunicorn - Uvicorn

There is an official Docker image that includes Gunicorn running with Uvicorn workers, as detailed in a previous chapter: Server Workers - Gunicorn with Uvicorn.

This image would be useful mainly in the situations described above in: Containers with Multiple Processes and Special Cases.

- tiangolo/uvicorn-gunicorn-fastapi.

Warning

There's a high chance that you **don't** need this base image or any other similar one, and would be better off by building the image from scratch as described above in: Build a Docker Image for FastAPI.

This image has an **auto-tuning** mechanism included to set the **number of worker processes** based on the CPU cores available.

It has **sensible defaults**, but you can still change and update all the configurations with **environment variables** or configuration files.

It also supports running **previous steps before starting** with a script.

#### Number of Processes on the Official Docker Image

The **number of processes** on this image is **computed automatically** from the CPU **cores** available.

This means that it will try to **squeeze** as much **performance** from the CPU as possible.

You can also adjust it with the configurations using **environment variables**, etc.

But it also means that as the number of processes depends on the CPU the container is running, the **amount of memory consumed** will also depend on that.

So, if your application consumes a lot of memory (for example with machine learning models), and your server has a lot of CPU cores **but little memory**, then your container could end up trying to use more memory than what is available, and degrading performance a lot (or even crashing). 🚨

#### Create a `Dockerfile`

Here's how you would create a `Dockerfile` based on this image:

`FROM tiangolo/uvicorn-gunicorn-fastapi:python3.9  COPY ./requirements.txt /app/requirements.txt  RUN pip install --no-cache-dir --upgrade -r /app/requirements.txt  COPY ./app /app`

#### Bigger Applications

If you followed the section about creating Bigger Applications with Multiple Files, your `Dockerfile` might instead look like:

`FROM tiangolo/uvicorn-gunicorn-fastapi:python3.9  COPY ./requirements.txt /app/requirements.txt  RUN pip install --no-cache-dir --upgrade -r /app/requirements.txt  COPY ./app /app/app`

#### When to Use

You should probably **not** use this official base image (or any other similar one) if you are using **Kubernetes** (or others) and you are already setting **replication** at the cluster level, with multiple **containers**. In those cases, you are better off **building an image from scratch** as described above: Build a Docker Image for FastAPI.

This image would be useful mainly in the special cases described above in Containers with Multiple Processes and Special Cases. For example, if your application is **simple enough** that setting a default number of processes based on the CPU works well, you don't want to bother with manually configuring the replication at the cluster level, and you are not running more than one container with your app. Or if you are deploying with **Docker Compose**, running on a single server, etc.

### Deploy the Container Image

After having a Container (Docker) Image there are several ways to deploy it.

For example:

- With **Docker Compose** in a single server
- With a **Kubernetes** cluster
- With a Docker Swarm Mode cluster
- With another tool like Nomad
- With a cloud service that takes your container image and deploys it

### Docker Image with Poetry

If you use Poetry to manage your project's dependencies, you could use Docker multi-stage building:

`# (1) FROM python:3.9 as requirements-stage  # (2) WORKDIR /tmp  # (3) RUN pip install poetry  # (4) COPY ./pyproject.toml ./poetry.lock* /tmp/  # (5) RUN poetry export -f requirements.txt --output requirements.txt --without-hashes  # (6) FROM python:3.9  # (7) WORKDIR /code  # (8) COPY --from=requirements-stage /tmp/requirements.txt /code/requirements.txt  # (9) RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt  # (10) COPY ./app /code/app  # (11) CMD [&quot;uvicorn&quot;, &quot;app.main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;80&quot;]`

1. This is the first stage, it is named `requirements-stage`.

2. Set `/tmp` as the current working directory.

   Here's where we will generate the file `requirements.txt`

3. Install Poetry in this Docker stage.

4. Copy the `pyproject.toml` and `poetry.lock` files to the `/tmp` directory.

   Because it uses `./poetry.lock*` (ending with a `*`), it won't crash if that file is not available yet.

5. Generate the `requirements.txt` file.

6. This is the final stage, anything here will be preserved in the final container image.

7. Set the current working directory to `/code`.

8. Copy the `requirements.txt` file to the `/code` directory.

   This file only lives in the previous Docker stage, that's why we use `--from-requirements-stage` to copy it.

9. Install the package dependencies in the generated `requirements.txt` file.

10. Copy the `app` directory to the `/code` directory.

11. Run the `uvicorn` command, telling it to use the `app` object imported from `app.main`.

Tip

Click the bubble numbers to see what each line does.

A **Docker stage** is a part of a `Dockerfile` that works as a **temporary container image** that is only used to generate some files to be used later.

The first stage will only be used to **install Poetry** and to **generate the `requirements.txt`** with your project dependencies from Poetry's `pyproject.toml` file.

This `requirements.txt` file will be used with `pip` later in the **next stage**.

In the final container image **only the final stage** is preserved. The previous stage(s) will be discarded.

When using Poetry, it would make sense to use **Docker multi-stage builds** because you don't really need to have Poetry and its dependencies installed in the final container image, you **only need** to have the generated `requirements.txt` file to install your project dependencies.

Then in the next (and final) stage you would build the image more or less in the same way as described before.

#### Behind a TLS Termination Proxy - Poetry

Again, if you are running your container behind a TLS Termination Proxy (load balancer) like Nginx or Traefik, add the option `--proxy-headers` to the command:

`CMD [&quot;uvicorn&quot;, &quot;app.main:app&quot;, &quot;--proxy-headers&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;80&quot;]`

### Recap

Using container systems (e.g. with **Docker** and **Kubernetes**) it becomes fairly straightforward to handle all the **deployment concepts**:

- HTTPS
- Running on startup
- Restarts
- Replication (the number of processes running)
- Memory
- Previous steps before starting

In most cases, you probably won't want to use any base image, and instead **build a container image from scratch** one based on the official Python Docker image.

Taking care of the **order** of instructions in the `Dockerfile` and the **Docker cache** you can **minimize build times**, to maximize your productivity (and avoid boredom). 😎

In certain special cases, you might want to use the official Docker image for FastAPI. 🤓




Info

These docs are about to be updated. 🎉

The current version assumes Pydantic v1.

The new docs will hopefully use Pydantic v2 and will use ODMantic with MongoDB.

**FastAPI** can also be integrated with any NoSQL.

Here we'll see an example using **Couchbase**, a document based NoSQL database.

You can adapt it to any other NoSQL database like:

- **MongoDB**
- **Cassandra**
- **CouchDB**
- **ArangoDB**
- **ElasticSearch**, etc.

### Import Couchbase components

For now, don't pay attention to the rest, only the imports:

`from typing import Union  from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel  USERPROFILE_DOC_TYPE = &quot;userprofile&quot;  def get_bucket():     cluster = Cluster(         &quot;couchbase://couchbasehost:8091?fetch_mutation_tokens=1&amp;operation_timeout=30&amp;n1ql_timeout=300&quot;     )     authenticator = PasswordAuthenticator(&quot;username&quot;, &quot;password&quot;)     cluster.authenticate(authenticator)     bucket: Bucket = cluster.open_bucket(&quot;bucket_name&quot;, lockmode=LOCKMODE_WAIT)     bucket.timeout = 30     bucket.n1ql_timeout = 300     return bucket  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     type: str = USERPROFILE_DOC_TYPE     hashed_password: str  def get_user(bucket: Bucket, username: str):     doc_id = f&quot;userprofile::{username}&quot;     result = bucket.get(doc_id, quiet=True)     if not result.value:         return None     user = UserInDB(**result.value)     return user  # FastAPI specific code app = FastAPI()  @app.get(&quot;/users/{username}&quot;, response_model=User) def read_user(username: str):     bucket = get_bucket()     user = get_user(bucket=bucket, username=username)     return user`

### Define a constant to use as a "document type"

We will use it later as a fixed field `type` in our documents.

This is not required by Couchbase, but is a good practice that will help you afterwards.

`from typing import Union  from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel  USERPROFILE_DOC_TYPE = &quot;userprofile&quot;  def get_bucket():     cluster = Cluster(         &quot;couchbase://couchbasehost:8091?fetch_mutation_tokens=1&amp;operation_timeout=30&amp;n1ql_timeout=300&quot;     )     authenticator = PasswordAuthenticator(&quot;username&quot;, &quot;password&quot;)     cluster.authenticate(authenticator)     bucket: Bucket = cluster.open_bucket(&quot;bucket_name&quot;, lockmode=LOCKMODE_WAIT)     bucket.timeout = 30     bucket.n1ql_timeout = 300     return bucket  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     type: str = USERPROFILE_DOC_TYPE     hashed_password: str  def get_user(bucket: Bucket, username: str):     doc_id = f&quot;userprofile::{username}&quot;     result = bucket.get(doc_id, quiet=True)     if not result.value:         return None     user = UserInDB(**result.value)     return user  # FastAPI specific code app = FastAPI()  @app.get(&quot;/users/{username}&quot;, response_model=User) def read_user(username: str):     bucket = get_bucket()     user = get_user(bucket=bucket, username=username)     return user`

### Add a function to get a `Bucket`

In **Couchbase**, a bucket is a set of documents, that can be of different types.

They are generally all related to the same application.

The analogy in the relational database world would be a "database" (a specific database, not the database server).

The analogy in **MongoDB** would be a "collection".

In the code, a `Bucket` represents the main entrypoint of communication with the database.

This utility function will:

- Connect to a **Couchbase** cluster (that might be a single machine).
  - Set defaults for timeouts.
- Authenticate in the cluster.
- Get a `Bucket` instance.
  - Set defaults for timeouts.
- Return it.

`from typing import Union  from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel  USERPROFILE_DOC_TYPE = &quot;userprofile&quot;  def get_bucket():     cluster = Cluster(        &quot;couchbase://couchbasehost:8091?fetch_mutation_tokens=1&amp;operation_timeout=30&amp;n1ql_timeout=300&quot;    )    authenticator = PasswordAuthenticator(&quot;username&quot;, &quot;password&quot;)    cluster.authenticate(authenticator)    bucket: Bucket = cluster.open_bucket(&quot;bucket_name&quot;, lockmode=LOCKMODE_WAIT)    bucket.timeout = 30    bucket.n1ql_timeout = 300    return bucket  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     type: str = USERPROFILE_DOC_TYPE     hashed_password: str  def get_user(bucket: Bucket, username: str):     doc_id = f&quot;userprofile::{username}&quot;     result = bucket.get(doc_id, quiet=True)     if not result.value:         return None     user = UserInDB(**result.value)     return user  # FastAPI specific code app = FastAPI()  @app.get(&quot;/users/{username}&quot;, response_model=User) def read_user(username: str):     bucket = get_bucket()     user = get_user(bucket=bucket, username=username)     return user`

### Create Pydantic models

As **Couchbase** "documents" are actually just "JSON objects", we can model them with Pydantic.

#### `User` model

First, let's create a `User` model:

`from typing import Union  from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel  USERPROFILE_DOC_TYPE = &quot;userprofile&quot;  def get_bucket():     cluster = Cluster(         &quot;couchbase://couchbasehost:8091?fetch_mutation_tokens=1&amp;operation_timeout=30&amp;n1ql_timeout=300&quot;     )     authenticator = PasswordAuthenticator(&quot;username&quot;, &quot;password&quot;)     cluster.authenticate(authenticator)     bucket: Bucket = cluster.open_bucket(&quot;bucket_name&quot;, lockmode=LOCKMODE_WAIT)     bucket.timeout = 30     bucket.n1ql_timeout = 300     return bucket  class User(BaseModel):     username: str    email: Union[str, None] = None    full_name: Union[str, None] = None    disabled: Union[bool, None] = None  class UserInDB(User):     type: str = USERPROFILE_DOC_TYPE     hashed_password: str  def get_user(bucket: Bucket, username: str):     doc_id = f&quot;userprofile::{username}&quot;     result = bucket.get(doc_id, quiet=True)     if not result.value:         return None     user = UserInDB(**result.value)     return user  # FastAPI specific code app = FastAPI()  @app.get(&quot;/users/{username}&quot;, response_model=User) def read_user(username: str):     bucket = get_bucket()     user = get_user(bucket=bucket, username=username)     return user`

We will use this model in our *path operation function*, so, we don't include in it the `hashed_password`.

#### `UserInDB` model

Now, let's create a `UserInDB` model.

This will have the data that is actually stored in the database.

We don't create it as a subclass of Pydantic's `BaseModel` but as a subclass of our own `User`, because it will have all the attributes in `User` plus a couple more:

`from typing import Union  from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel  USERPROFILE_DOC_TYPE = &quot;userprofile&quot;  def get_bucket():     cluster = Cluster(         &quot;couchbase://couchbasehost:8091?fetch_mutation_tokens=1&amp;operation_timeout=30&amp;n1ql_timeout=300&quot;     )     authenticator = PasswordAuthenticator(&quot;username&quot;, &quot;password&quot;)     cluster.authenticate(authenticator)     bucket: Bucket = cluster.open_bucket(&quot;bucket_name&quot;, lockmode=LOCKMODE_WAIT)     bucket.timeout = 30     bucket.n1ql_timeout = 300     return bucket  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     type: str = USERPROFILE_DOC_TYPE    hashed_password: str  def get_user(bucket: Bucket, username: str):     doc_id = f&quot;userprofile::{username}&quot;     result = bucket.get(doc_id, quiet=True)     if not result.value:         return None     user = UserInDB(**result.value)     return user  # FastAPI specific code app = FastAPI()  @app.get(&quot;/users/{username}&quot;, response_model=User) def read_user(username: str):     bucket = get_bucket()     user = get_user(bucket=bucket, username=username)     return user`

Note

Notice that we have a `hashed_password` and a `type` field that will be stored in the database.

But it is not part of the general `User` model (the one we will return in the *path operation*).

### Get the user

Now create a function that will:

- Take a username.
- Generate a document ID from it.
- Get the document with that ID.
- Put the contents of the document in a `UserInDB` model.

By creating a function that is only dedicated to getting your user from a `username` (or any other parameter) independent of your *path operation function*, you can more easily re-use it in multiple parts and also add unit tests for it:

`from typing import Union  from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel  USERPROFILE_DOC_TYPE = &quot;userprofile&quot;  def get_bucket():     cluster = Cluster(         &quot;couchbase://couchbasehost:8091?fetch_mutation_tokens=1&amp;operation_timeout=30&amp;n1ql_timeout=300&quot;     )     authenticator = PasswordAuthenticator(&quot;username&quot;, &quot;password&quot;)     cluster.authenticate(authenticator)     bucket: Bucket = cluster.open_bucket(&quot;bucket_name&quot;, lockmode=LOCKMODE_WAIT)     bucket.timeout = 30     bucket.n1ql_timeout = 300     return bucket  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     type: str = USERPROFILE_DOC_TYPE     hashed_password: str  def get_user(bucket: Bucket, username: str):     doc_id = f&quot;userprofile::{username}&quot;    result = bucket.get(doc_id, quiet=True)    if not result.value:        return None    user = UserInDB(**result.value)    return user  # FastAPI specific code app = FastAPI()  @app.get(&quot;/users/{username}&quot;, response_model=User) def read_user(username: str):     bucket = get_bucket()     user = get_user(bucket=bucket, username=username)     return user`

#### f-strings

If you are not familiar with the `f&quot;userprofile::{username}&quot;`, it is a Python "f-string".

Any variable that is put inside of `{}` in an f-string will be expanded / injected in the string.

#### `dict` unpacking

If you are not familiar with the `UserInDB(**result.value)`, it is using `dict` "unpacking".

It will take the `dict` at `result.value`, and take each of its keys and values and pass them as key-values to `UserInDB` as keyword arguments.

So, if the `dict` contains:

`{     &quot;username&quot;: &quot;johndoe&quot;,     &quot;hashed_password&quot;: &quot;some_hash&quot;, }`

It will be passed to `UserInDB` as:

`UserInDB(username=&quot;johndoe&quot;, hashed_password=&quot;some_hash&quot;)`

### Create your **FastAPI** code

#### Create the `FastAPI` app

`from typing import Union  from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel  USERPROFILE_DOC_TYPE = &quot;userprofile&quot;  def get_bucket():     cluster = Cluster(         &quot;couchbase://couchbasehost:8091?fetch_mutation_tokens=1&amp;operation_timeout=30&amp;n1ql_timeout=300&quot;     )     authenticator = PasswordAuthenticator(&quot;username&quot;, &quot;password&quot;)     cluster.authenticate(authenticator)     bucket: Bucket = cluster.open_bucket(&quot;bucket_name&quot;, lockmode=LOCKMODE_WAIT)     bucket.timeout = 30     bucket.n1ql_timeout = 300     return bucket  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     type: str = USERPROFILE_DOC_TYPE     hashed_password: str  def get_user(bucket: Bucket, username: str):     doc_id = f&quot;userprofile::{username}&quot;     result = bucket.get(doc_id, quiet=True)     if not result.value:         return None     user = UserInDB(**result.value)     return user  # FastAPI specific code app = FastAPI()  @app.get(&quot;/users/{username}&quot;, response_model=User) def read_user(username: str):     bucket = get_bucket()     user = get_user(bucket=bucket, username=username)     return user`

#### Create the *path operation function*

As our code is calling Couchbase and we are not using the experimental Python `await` support, we should declare our function with normal `def` instead of `async def`.

Also, Couchbase recommends not using a single `Bucket` object in multiple "threads", so, we can just get the bucket directly and pass it to our utility functions:

`from typing import Union  from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel  USERPROFILE_DOC_TYPE = &quot;userprofile&quot;  def get_bucket():     cluster = Cluster(         &quot;couchbase://couchbasehost:8091?fetch_mutation_tokens=1&amp;operation_timeout=30&amp;n1ql_timeout=300&quot;     )     authenticator = PasswordAuthenticator(&quot;username&quot;, &quot;password&quot;)     cluster.authenticate(authenticator)     bucket: Bucket = cluster.open_bucket(&quot;bucket_name&quot;, lockmode=LOCKMODE_WAIT)     bucket.timeout = 30     bucket.n1ql_timeout = 300     return bucket  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     type: str = USERPROFILE_DOC_TYPE     hashed_password: str  def get_user(bucket: Bucket, username: str):     doc_id = f&quot;userprofile::{username}&quot;     result = bucket.get(doc_id, quiet=True)     if not result.value:         return None     user = UserInDB(**result.value)     return user  # FastAPI specific code app = FastAPI()  @app.get(&quot;/users/{username}&quot;, response_model=User) def read_user(username: str):     bucket = get_bucket()    user = get_user(bucket=bucket, username=username)    return user`

### Recap

You can integrate any third party NoSQL database, just using their standard packages.

The same applies to any other external tool, system or API.




Warning

If you are just starting, the tutorial SQL (Relational) Databases that uses SQLAlchemy should be enough.

Feel free to skip this.

Peewee is not recommended with FastAPI as it doesn't play well with anything async Python. There are several better alternatives.

Info

These docs assume Pydantic v1.

Because Pewee doesn't play well with anything async and there are better alternatives, I won't update these docs for Pydantic v2, they are kept for now only for historical purposes.

The examples here are no longer tested in CI (as they were before).

If you are starting a project from scratch, you are probably better off with SQLAlchemy ORM (SQL (Relational) Databases), or any other async ORM.

If you already have a code base that uses Peewee ORM, you can check here how to use it with **FastAPI**.

Python 3.7+ required

You will need Python 3.7 or above to safely use Peewee with FastAPI.

### Peewee for async

Peewee was not designed for async frameworks, or with them in mind.

Peewee has some heavy assumptions about its defaults and about how it should be used.

If you are developing an application with an older non-async framework, and can work with all its defaults, **it can be a great tool**.

But if you need to change some of the defaults, support more than one predefined database, work with an async framework (like FastAPI), etc, you will need to add quite some complex extra code to override those defaults.

Nevertheless, it's possible to do it, and here you'll see exactly what code you have to add to be able to use Peewee with FastAPI.

### The same app

We are going to create the same application as in the SQLAlchemy tutorial (SQL (Relational) Databases).

Most of the code is actually the same.

So, we are going to focus only on the differences.

### File structure

Let's say you have a directory named `my_super_project` that contains a sub-directory called `sql_app` with a structure like this:

`. └── sql_app     ├── __init__.py     ├── crud.py     ├── database.py     ├── main.py     └── schemas.py`

This is almost the same structure as we had for the SQLAlchemy tutorial.

Now let's see what each file/module does.

### Create the Peewee parts

Let's refer to the file `sql_app/database.py`.

#### The standard Peewee code

Let's first check all the normal Peewee code, create a Peewee database:

`from contextvars import ContextVar  import peewee DATABASE_NAME = &quot;test.db&quot; db_state_default = {&quot;closed&quot;: None, &quot;conn&quot;: None, &quot;ctx&quot;: None, &quot;transactions&quot;: None} db_state = ContextVar(&quot;db_state&quot;, default=db_state_default.copy())  class PeeweeConnectionState(peewee._ConnectionState):     def __init__(self, **kwargs):         super().__setattr__(&quot;_state&quot;, db_state)         super().__init__(**kwargs)      def __setattr__(self, name, value):         self._state.get()[name] = value      def __getattr__(self, name):         return self._state.get()[name]  db = peewee.SqliteDatabase(DATABASE_NAME, check_same_thread=False) db._state = PeeweeConnectionState()`

Tip

Have in mind that if you wanted to use a different database, like PostgreSQL, you couldn't just change the string. You would need to use a different Peewee database class.

##### Note

The argument:

is equivalent to the one in the SQLAlchemy tutorial:

`connect_args={&quot;check_same_thread&quot;: False}`

...it is needed only for `SQLite`.

#### Make Peewee async-compatible `PeeweeConnectionState`

The main issue with Peewee and FastAPI is that Peewee relies heavily on Python's `threading.local`, and it doesn't have a direct way to override it or let you handle connections/sessions directly (as is done in the SQLAlchemy tutorial).

And `threading.local` is not compatible with the new async features of modern Python.

Technical Details

`threading.local` is used to have a "magic" variable that has a different value for each thread.

This was useful in older frameworks designed to have one single thread per request, no more, no less.

Using this, each request would have its own database connection/session, which is the actual final goal.

But FastAPI, using the new async features, could handle more than one request on the same thread. And at the same time, for a single request, it could run multiple things in different threads (in a threadpool), depending on if you use `async def` or normal `def`. This is what gives all the performance improvements to FastAPI.

But Python 3.7 and above provide a more advanced alternative to `threading.local`, that can also be used in the places where `threading.local` would be used, but is compatible with the new async features.

We are going to use that. It's called `contextvars`.

We are going to override the internal parts of Peewee that use `threading.local` and replace them with `contextvars`, with the corresponding updates.

This might seem a bit complex (and it actually is), you don't really need to completely understand how it works to use it.

We will create a `PeeweeConnectionState`:

`from contextvars import ContextVar  import peewee  DATABASE_NAME = &quot;test.db&quot; db_state_default = {&quot;closed&quot;: None, &quot;conn&quot;: None, &quot;ctx&quot;: None, &quot;transactions&quot;: None} db_state = ContextVar(&quot;db_state&quot;, default=db_state_default.copy())  class PeeweeConnectionState(peewee._ConnectionState):     def __init__(self, **kwargs):        super().__setattr__(&quot;_state&quot;, db_state)        super().__init__(**kwargs)     def __setattr__(self, name, value):        self._state.get()[name] = value     def __getattr__(self, name):        return self._state.get()[name]  db = peewee.SqliteDatabase(DATABASE_NAME, check_same_thread=False)  db._state = PeeweeConnectionState()`

This class inherits from a special internal class used by Peewee.

It has all the logic to make Peewee use `contextvars` instead of `threading.local`.

`contextvars` works a bit differently than `threading.local`. But the rest of Peewee's internal code assumes that this class works with `threading.local`.

So, we need to do some extra tricks to make it work as if it was just using `threading.local`. The `__init__`, `__setattr__`, and `__getattr__` implement all the required tricks for this to be used by Peewee without knowing that it is now compatible with FastAPI.

Tip

This will just make Peewee behave correctly when used with FastAPI. Not randomly opening or closing connections that are being used, creating errors, etc.

But it doesn't give Peewee async super-powers. You should still use normal `def` functions and not `async def`.

#### Use the custom `PeeweeConnectionState` class

Now, overwrite the `._state` internal attribute in the Peewee database `db` object using the new `PeeweeConnectionState`:

`from contextvars import ContextVar  import peewee  DATABASE_NAME = &quot;test.db&quot; db_state_default = {&quot;closed&quot;: None, &quot;conn&quot;: None, &quot;ctx&quot;: None, &quot;transactions&quot;: None} db_state = ContextVar(&quot;db_state&quot;, default=db_state_default.copy())  class PeeweeConnectionState(peewee._ConnectionState):     def __init__(self, **kwargs):         super().__setattr__(&quot;_state&quot;, db_state)         super().__init__(**kwargs)      def __setattr__(self, name, value):         self._state.get()[name] = value      def __getattr__(self, name):         return self._state.get()[name]  db = peewee.SqliteDatabase(DATABASE_NAME, check_same_thread=False)  db._state = PeeweeConnectionState()`

Tip

Make sure you overwrite `db._state` *after* creating `db`.

Tip

You would do the same for any other Peewee database, including `PostgresqlDatabase`, `MySQLDatabase`, etc.

### Create the database models

Let's now see the file `sql_app/models.py`.

#### Create Peewee models for our data

Now create the Peewee models (classes) for `User` and `Item`.

This is the same you would do if you followed the Peewee tutorial and updated the models to have the same data as in the SQLAlchemy tutorial.

Tip

Peewee also uses the term "**model**" to refer to these classes and instances that interact with the database.

But Pydantic also uses the term "**model**" to refer to something different, the data validation, conversion, and documentation classes and instances.

Import `db` from `database` (the file `database.py` from above) and use it here.

`import peewee  from .database import db  class User(peewee.Model):     email = peewee.CharField(unique=True, index=True)    hashed_password = peewee.CharField()    is_active = peewee.BooleanField(default=True)     class Meta:        database = db  class Item(peewee.Model):     title = peewee.CharField(index=True)    description = peewee.CharField(index=True)    owner = peewee.ForeignKeyField(User, backref=&quot;items&quot;)     class Meta:        database = db`

Tip

Peewee creates several magic attributes.

It will automatically add an `id` attribute as an integer to be the primary key.

It will chose the name of the tables based on the class names.

For the `Item`, it will create an attribute `owner_id` with the integer ID of the `User`. But we don't declare it anywhere.

### Create the Pydantic models

Now let's check the file `sql_app/schemas.py`.

Tip

To avoid confusion between the Peewee *models* and the Pydantic *models*, we will have the file `models.py` with the Peewee models, and the file `schemas.py` with the Pydantic models.

These Pydantic models define more or less a "schema" (a valid data shape).

So this will help us avoiding confusion while using both.

#### Create the Pydantic *models* / schemas

Create all the same Pydantic models as in the SQLAlchemy tutorial:

`from typing import Any, List, Union  import peewee from pydantic import BaseModel from pydantic.utils import GetterDict  class PeeweeGetterDict(GetterDict):     def get(self, key: Any, default: Any = None):         res = getattr(self._obj, key, default)         if isinstance(res, peewee.ModelSelect):             return list(res)         return res  class ItemBase(BaseModel):     title: str    description: Union[str, None] = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int    owner_id: int     class Config:        orm_mode = True        getter_dict = PeeweeGetterDict  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int    is_active: bool    items: List[Item] = []     class Config:        orm_mode = True        getter_dict = PeeweeGetterDict`

Tip

Here we are creating the models with an `id`.

We didn't explicitly specify an `id` attribute in the Peewee models, but Peewee adds one automatically.

We are also adding the magic `owner_id` attribute to `Item`.

#### Create a `PeeweeGetterDict` for the Pydantic *models* / schemas

When you access a relationship in a Peewee object, like in `some_user.items`, Peewee doesn't provide a `list` of `Item`.

It provides a special custom object of class `ModelSelect`.

It's possible to create a `list` of its items with `list(some_user.items)`.

But the object itself is not a `list`. And it's also not an actual Python generator. Because of this, Pydantic doesn't know by default how to convert it to a `list` of Pydantic *models* / schemas.

But recent versions of Pydantic allow providing a custom class that inherits from `pydantic.utils.GetterDict`, to provide the functionality used when using the `orm_mode = True` to retrieve the values for ORM model attributes.

We are going to create a custom `PeeweeGetterDict` class and use it in all the same Pydantic *models* / schemas that use `orm_mode`:

`from typing import Any, List, Union  import peewee from pydantic import BaseModel from pydantic.utils import GetterDict  class PeeweeGetterDict(GetterDict):     def get(self, key: Any, default: Any = None):        res = getattr(self._obj, key, default)        if isinstance(res, peewee.ModelSelect):            return list(res)        return res  class ItemBase(BaseModel):     title: str     description: Union[str, None] = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int     owner_id: int      class Config:         orm_mode = True         getter_dict = PeeweeGetterDict  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int     is_active: bool     items: List[Item] = []      class Config:         orm_mode = True         getter_dict = PeeweeGetterDict`

Here we are checking if the attribute that is being accessed (e.g. `.items` in `some_user.items`) is an instance of `peewee.ModelSelect`.

And if that's the case, just return a `list` with it.

And then we use it in the Pydantic *models* / schemas that use `orm_mode = True`, with the configuration variable `getter_dict = PeeweeGetterDict`.

Tip

We only need to create one `PeeweeGetterDict` class, and we can use it in all the Pydantic *models* / schemas.

### CRUD utils

Now let's see the file `sql_app/crud.py`.

#### Create all the CRUD utils

Create all the same CRUD utils as in the SQLAlchemy tutorial, all the code is very similar:

`from . import models, schemas  def get_user(user_id: int):     return models.User.filter(models.User.id == user_id).first()  def get_user_by_email(email: str):     return models.User.filter(models.User.email == email).first()  def get_users(skip: int = 0, limit: int = 100):     return list(models.User.select().offset(skip).limit(limit))  def create_user(user: schemas.UserCreate):     fake_hashed_password = user.password + &quot;notreallyhashed&quot;    db_user = models.User(email=user.email, hashed_password=fake_hashed_password)    db_user.save()    return db_user  def get_items(skip: int = 0, limit: int = 100):     return list(models.Item.select().offset(skip).limit(limit))  def create_user_item(item: schemas.ItemCreate, user_id: int):     db_item = models.Item(**item.dict(), owner_id=user_id)    db_item.save()    return db_item`

There are some differences with the code for the SQLAlchemy tutorial.

We don't pass a `db` attribute around. Instead we use the models directly. This is because the `db` object is a global object, that includes all the connection logic. That's why we had to do all the `contextvars` updates above.

Aso, when returning several objects, like in `get_users`, we directly call `list`, like in:

`list(models.User.select())`

This is for the same reason that we had to create a custom `PeeweeGetterDict`. But by returning something that is already a `list` instead of the `peewee.ModelSelect` the `response_model` in the *path operation* with `List[models.User]` (that we'll see later) will work correctly.

### Main **FastAPI** app

And now in the file `sql_app/main.py` let's integrate and use all the other parts we created before.

#### Create the database tables

In a very simplistic way create the database tables:

`import time from typing import List  from fastapi import Depends, FastAPI, HTTPException  from . import crud, database, models, schemas from .database import db_state_default  database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close() app = FastAPI()  sleep_time = 10  async def reset_db_state():     database.db._state._state.set(db_state_default.copy())     database.db._state.reset()  def get_db(db_state=Depends(reset_db_state)):     try:         database.db.connect()         yield     finally:         if not database.db.is_closed():             database.db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate):     db_user = crud.get_user_by_email(email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(user=user)  @app.get(&quot;/users/&quot;, response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100):     users = crud.get_users(skip=skip, limit=limit)     return users  @app.get(     &quot;/users/{user_id}&quot;, response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int):     db_user = crud.get_user(user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(     &quot;/users/{user_id}/items/&quot;,     response_model=schemas.Item,     dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate):     return crud.create_user_item(item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100):     items = crud.get_items(skip=skip, limit=limit)     return items  @app.get(     &quot;/slowusers/&quot;, response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100):     global sleep_time     sleep_time = max(0, sleep_time - 1)     time.sleep(sleep_time)  # Fake long processing request     users = crud.get_users(skip=skip, limit=limit)     return users`

#### Create a dependency

Create a dependency that will connect the database right at the beginning of a request and disconnect it at the end:

`import time from typing import List  from fastapi import Depends, FastAPI, HTTPException  from . import crud, database, models, schemas from .database import db_state_default  database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close()  app = FastAPI()  sleep_time = 10  async def reset_db_state():     database.db._state._state.set(db_state_default.copy())     database.db._state.reset()  def get_db(db_state=Depends(reset_db_state)):     try:        database.db.connect()        yield    finally:        if not database.db.is_closed():            database.db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate):     db_user = crud.get_user_by_email(email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(user=user)  @app.get(&quot;/users/&quot;, response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100):     users = crud.get_users(skip=skip, limit=limit)     return users  @app.get(     &quot;/users/{user_id}&quot;, response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int):     db_user = crud.get_user(user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(     &quot;/users/{user_id}/items/&quot;,     response_model=schemas.Item,     dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate):     return crud.create_user_item(item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100):     items = crud.get_items(skip=skip, limit=limit)     return items  @app.get(     &quot;/slowusers/&quot;, response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100):     global sleep_time     sleep_time = max(0, sleep_time - 1)     time.sleep(sleep_time)  # Fake long processing request     users = crud.get_users(skip=skip, limit=limit)     return users`

Here we have an empty `yield` because we are actually not using the database object directly.

It is connecting to the database and storing the connection data in an internal variable that is independent for each request (using the `contextvars` tricks from above).

Because the database connection is potentially I/O blocking, this dependency is created with a normal `def` function.

And then, in each *path operation function* that needs to access the database we add it as a dependency.

But we are not using the value given by this dependency (it actually doesn't give any value, as it has an empty `yield`). So, we don't add it to the *path operation function* but to the *path operation decorator* in the `dependencies` parameter:

`import time from typing import List  from fastapi import Depends, FastAPI, HTTPException  from . import crud, database, models, schemas from .database import db_state_default  database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close()  app = FastAPI()  sleep_time = 10  async def reset_db_state():     database.db._state._state.set(db_state_default.copy())     database.db._state.reset()  def get_db(db_state=Depends(reset_db_state)):     try:         database.db.connect()         yield     finally:         if not database.db.is_closed():             database.db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate):     db_user = crud.get_user_by_email(email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(user=user)  @app.get(&quot;/users/&quot;, response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100):     users = crud.get_users(skip=skip, limit=limit)     return users  @app.get(     &quot;/users/{user_id}&quot;, response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int):     db_user = crud.get_user(user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(     &quot;/users/{user_id}/items/&quot;,     response_model=schemas.Item,     dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate):     return crud.create_user_item(item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100):     items = crud.get_items(skip=skip, limit=limit)     return items  @app.get(     &quot;/slowusers/&quot;, response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100):     global sleep_time     sleep_time = max(0, sleep_time - 1)     time.sleep(sleep_time)  # Fake long processing request     users = crud.get_users(skip=skip, limit=limit)     return users`

#### Context variable sub-dependency

For all the `contextvars` parts to work, we need to make sure we have an independent value in the `ContextVar` for each request that uses the database, and that value will be used as the database state (connection, transactions, etc) for the whole request.

For that, we need to create another `async` dependency `reset_db_state()` that is used as a sub-dependency in `get_db()`. It will set the value for the context variable (with just a default `dict`) that will be used as the database state for the whole request. And then the dependency `get_db()` will store in it the database state (connection, transactions, etc).

`import time from typing import List  from fastapi import Depends, FastAPI, HTTPException  from . import crud, database, models, schemas from .database import db_state_default  database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close()  app = FastAPI()  sleep_time = 10  async def reset_db_state():     database.db._state._state.set(db_state_default.copy())    database.db._state.reset()  def get_db(db_state=Depends(reset_db_state)):     try:         database.db.connect()         yield     finally:         if not database.db.is_closed():             database.db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate):     db_user = crud.get_user_by_email(email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(user=user)  @app.get(&quot;/users/&quot;, response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100):     users = crud.get_users(skip=skip, limit=limit)     return users  @app.get(     &quot;/users/{user_id}&quot;, response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int):     db_user = crud.get_user(user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(     &quot;/users/{user_id}/items/&quot;,     response_model=schemas.Item,     dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate):     return crud.create_user_item(item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100):     items = crud.get_items(skip=skip, limit=limit)     return items  @app.get(     &quot;/slowusers/&quot;, response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100):     global sleep_time     sleep_time = max(0, sleep_time - 1)     time.sleep(sleep_time)  # Fake long processing request     users = crud.get_users(skip=skip, limit=limit)     return users`

For the **next request**, as we will reset that context variable again in the `async` dependency `reset_db_state()` and then create a new connection in the `get_db()` dependency, that new request will have its own database state (connection, transactions, etc).

Tip

As FastAPI is an async framework, one request could start being processed, and before finishing, another request could be received and start processing as well, and it all could be processed in the same thread.

But context variables are aware of these async features, so, a Peewee database state set in the `async` dependency `reset_db_state()` will keep its own data throughout the entire request.

And at the same time, the other concurrent request will have its own database state that will be independent for the whole request.

##### Peewee Proxy

If you are using a Peewee Proxy, the actual database is at `db.obj`.

So, you would reset it with:

`async def reset_db_state():     database.db.obj._state._state.set(db_state_default.copy())     database.db.obj._state.reset()`

#### Create your **FastAPI** *path operations*

Now, finally, here's the standard **FastAPI** *path operations* code.

`import time from typing import List  from fastapi import Depends, FastAPI, HTTPException  from . import crud, database, models, schemas from .database import db_state_default  database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close()  app = FastAPI()  sleep_time = 10  async def reset_db_state():     database.db._state._state.set(db_state_default.copy())     database.db._state.reset()  def get_db(db_state=Depends(reset_db_state)):     try:         database.db.connect()         yield     finally:         if not database.db.is_closed():             database.db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate):     db_user = crud.get_user_by_email(email=user.email)    if db_user:        raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)    return crud.create_user(user=user)  @app.get(&quot;/users/&quot;, response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100):     users = crud.get_users(skip=skip, limit=limit)    return users  @app.get(     &quot;/users/{user_id}&quot;, response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int):     db_user = crud.get_user(user_id=user_id)    if db_user is None:        raise HTTPException(status_code=404, detail=&quot;User not found&quot;)    return db_user  @app.post(     &quot;/users/{user_id}/items/&quot;,    response_model=schemas.Item,    dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate):     return crud.create_user_item(item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100):     items = crud.get_items(skip=skip, limit=limit)    return items  @app.get(     &quot;/slowusers/&quot;, response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100):     global sleep_time    sleep_time = max(0, sleep_time - 1)    time.sleep(sleep_time)  # Fake long processing request    users = crud.get_users(skip=skip, limit=limit)    return users`

#### About `def` vs `async def`

The same as with SQLAlchemy, we are not doing something like:

`user = await models.User.select().first()`

...but instead we are using:

`user = models.User.select().first()`

So, again, we should declare the *path operation functions* and the dependency without `async def`, just with a normal `def`, as:

`# Something goes here def read_users(skip: int = 0, limit: int = 100):     # Something goes here`

### Testing Peewee with async

This example includes an extra *path operation* that simulates a long processing request with `time.sleep(sleep_time)`.

It will have the database connection open at the beginning and will just wait some seconds before replying back. And each new request will wait one second less.

This will easily let you test that your app with Peewee and FastAPI is behaving correctly with all the stuff about threads.

If you want to check how Peewee would break your app if used without modification, go the the `sql_app/database.py` file and comment the line:

`# db._state = PeeweeConnectionState()`

And in the file `sql_app/main.py` file, comment the body of the `async` dependency `reset_db_state()` and replace it with a `pass`:

`async def reset_db_state(): #     database.db._state._state.set(db_state_default.copy()) #     database.db._state.reset()     pass`

Then run your app with Uvicorn:

`$ uvicorn sql_app.main:app --reload  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

Open your browser at http://127.0.0.1:8000/docs and create a couple of users.

Then open 10 tabs at http://127.0.0.1:8000/docs#/default/read_slow_users_slowusers__get at the same time.

Go to the *path operation* "Get `/slowusers/`" in all of the tabs. Use the "Try it out" button and execute the request in each tab, one right after the other.

The tabs will wait for a bit and then some of them will show `Internal Server Error`.

#### What happens

The first tab will make your app create a connection to the database and wait for some seconds before replying back and closing the database connection.

Then, for the request in the next tab, your app will wait for one second less, and so on.

This means that it will end up finishing some of the last tabs' requests earlier than some of the previous ones.

Then one the last requests that wait less seconds will try to open a database connection, but as one of those previous requests for the other tabs will probably be handled in the same thread as the first one, it will have the same database connection that is already open, and Peewee will throw an error and you will see it in the terminal, and the response will have an `Internal Server Error`.

This will probably happen for more than one of those tabs.

If you had multiple clients talking to your app exactly at the same time, this is what could happen.

And as your app starts to handle more and more clients at the same time, the waiting time in a single request needs to be shorter and shorter to trigger the error.

#### Fix Peewee with FastAPI

Now go back to the file `sql_app/database.py`, and uncomment the line:

`db._state = PeeweeConnectionState()`

And in the file `sql_app/main.py` file, uncomment the body of the `async` dependency `reset_db_state()`:

`async def reset_db_state():     database.db._state._state.set(db_state_default.copy())     database.db._state.reset()`

Terminate your running app and start it again.

Repeat the same process with the 10 tabs. This time all of them will wait and you will get all the results without errors.

...You fixed it!

### Review all the files

Remember you should have a directory named `my_super_project` (or however you want) that contains a sub-directory called `sql_app`.

`sql_app` should have the following files:

- `sql_app/__init__.py`: is an empty file.

- `sql_app/database.py`:

`from contextvars import ContextVar  import peewee  DATABASE_NAME = &quot;test.db&quot; db_state_default = {&quot;closed&quot;: None, &quot;conn&quot;: None, &quot;ctx&quot;: None, &quot;transactions&quot;: None} db_state = ContextVar(&quot;db_state&quot;, default=db_state_default.copy())  class PeeweeConnectionState(peewee._ConnectionState):     def __init__(self, **kwargs):         super().__setattr__(&quot;_state&quot;, db_state)         super().__init__(**kwargs)      def __setattr__(self, name, value):         self._state.get()[name] = value      def __getattr__(self, name):         return self._state.get()[name]  db = peewee.SqliteDatabase(DATABASE_NAME, check_same_thread=False)  db._state = PeeweeConnectionState()`

- `sql_app/models.py`:

`import peewee  from .database import db  class User(peewee.Model):     email = peewee.CharField(unique=True, index=True)     hashed_password = peewee.CharField()     is_active = peewee.BooleanField(default=True)      class Meta:         database = db  class Item(peewee.Model):     title = peewee.CharField(index=True)     description = peewee.CharField(index=True)     owner = peewee.ForeignKeyField(User, backref=&quot;items&quot;)      class Meta:         database = db`

- `sql_app/schemas.py`:

`from typing import Any, List, Union  import peewee from pydantic import BaseModel from pydantic.utils import GetterDict  class PeeweeGetterDict(GetterDict):     def get(self, key: Any, default: Any = None):         res = getattr(self._obj, key, default)         if isinstance(res, peewee.ModelSelect):             return list(res)         return res  class ItemBase(BaseModel):     title: str     description: Union[str, None] = None  class ItemCreate(ItemBase):     pass  class Item(ItemBase):     id: int     owner_id: int      class Config:         orm_mode = True         getter_dict = PeeweeGetterDict  class UserBase(BaseModel):     email: str  class UserCreate(UserBase):     password: str  class User(UserBase):     id: int     is_active: bool     items: List[Item] = []      class Config:         orm_mode = True         getter_dict = PeeweeGetterDict`

- `sql_app/crud.py`:

`from . import models, schemas  def get_user(user_id: int):     return models.User.filter(models.User.id == user_id).first()  def get_user_by_email(email: str):     return models.User.filter(models.User.email == email).first()  def get_users(skip: int = 0, limit: int = 100):     return list(models.User.select().offset(skip).limit(limit))  def create_user(user: schemas.UserCreate):     fake_hashed_password = user.password + &quot;notreallyhashed&quot;     db_user = models.User(email=user.email, hashed_password=fake_hashed_password)     db_user.save()     return db_user  def get_items(skip: int = 0, limit: int = 100):     return list(models.Item.select().offset(skip).limit(limit))  def create_user_item(item: schemas.ItemCreate, user_id: int):     db_item = models.Item(**item.dict(), owner_id=user_id)     db_item.save()     return db_item`

- `sql_app/main.py`:

`import time from typing import List  from fastapi import Depends, FastAPI, HTTPException  from . import crud, database, models, schemas from .database import db_state_default  database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close()  app = FastAPI()  sleep_time = 10  async def reset_db_state():     database.db._state._state.set(db_state_default.copy())     database.db._state.reset()  def get_db(db_state=Depends(reset_db_state)):     try:         database.db.connect()         yield     finally:         if not database.db.is_closed():             database.db.close()  @app.post(&quot;/users/&quot;, response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate):     db_user = crud.get_user_by_email(email=user.email)     if db_user:         raise HTTPException(status_code=400, detail=&quot;Email already registered&quot;)     return crud.create_user(user=user)  @app.get(&quot;/users/&quot;, response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100):     users = crud.get_users(skip=skip, limit=limit)     return users  @app.get(     &quot;/users/{user_id}&quot;, response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int):     db_user = crud.get_user(user_id=user_id)     if db_user is None:         raise HTTPException(status_code=404, detail=&quot;User not found&quot;)     return db_user  @app.post(     &quot;/users/{user_id}/items/&quot;,     response_model=schemas.Item,     dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate):     return crud.create_user_item(item=item, user_id=user_id)  @app.get(&quot;/items/&quot;, response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100):     items = crud.get_items(skip=skip, limit=limit)     return items  @app.get(     &quot;/slowusers/&quot;, response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100):     global sleep_time     sleep_time = max(0, sleep_time - 1)     time.sleep(sleep_time)  # Fake long processing request     users = crud.get_users(skip=skip, limit=limit)     return users`

### Technical Details

Warning

These are very technical details that you probably don't need.

#### The problem

Peewee uses `threading.local` by default to store it's database "state" data (connection, transactions, etc).

`threading.local` creates a value exclusive to the current thread, but an async framework would run all the code (e.g. for each request) in the same thread, and possibly not in order.

On top of that, an async framework could run some sync code in a threadpool (using `asyncio.run_in_executor`), but belonging to the same request.

This means that, with Peewee's current implementation, multiple tasks could be using the same `threading.local` variable and end up sharing the same connection and data (that they shouldn't), and at the same time, if they execute sync I/O-blocking code in a threadpool (as with normal `def` functions in FastAPI, in *path operations* and dependencies), that code won't have access to the database state variables, even while it's part of the same request and it should be able to get access to the same database state.

#### Context variables

Python 3.7 has `contextvars` that can create a local variable very similar to `threading.local`, but also supporting these async features.

There are several things to have in mind.

The `ContextVar` has to be created at the top of the module, like:

`some_var = ContextVar(&quot;some_var&quot;, default=&quot;default value&quot;)`

To set a value used in the current "context" (e.g. for the current request) use:

`some_var.set(&quot;new value&quot;)`

To get a value anywhere inside of the context (e.g. in any part handling the current request) use:

#### Set context variables in the `async` dependency `reset_db_state()`

If some part of the async code sets the value with `some_var.set(&quot;updated in function&quot;)` (e.g. like the `async` dependency), the rest of the code in it and the code that goes after (including code inside of `async` functions called with `await`) will see that new value.

So, in our case, if we set the Peewee state variable (with a default `dict`) in the `async` dependency, all the rest of the internal code in our app will see this value and will be able to reuse it for the whole request.

And the context variable would be set again for the next request, even if they are concurrent.

#### Set database state in the dependency `get_db()`

As `get_db()` is a normal `def` function, **FastAPI** will make it run in a threadpool, with a *copy* of the "context", holding the same value for the context variable (the `dict` with the reset database state). Then it can add database state to that `dict`, like the connection, etc.

But if the value of the context variable (the default `dict`) was set in that normal `def` function, it would create a new value that would stay only in that thread of the threadpool, and the rest of the code (like the *path operation functions*) wouldn't have access to it. In `get_db()` we can only set values in the `dict`, but not the entire `dict` itself.

So, we need to have the `async` dependency `reset_db_state()` to set the `dict` in the context variable. That way, all the code has access to the same `dict` for the database state for a single request.

#### Connect and disconnect in the dependency `get_db()`

Then the next question would be, why not just connect and disconnect the database in the `async` dependency itself, instead of in `get_db()`?

The `async` dependency has to be `async` for the context variable to be preserved for the rest of the request, but creating and closing the database connection is potentially blocking, so it could degrade performance if it was there.

So we also need the normal `def` dependency `get_db()`.




If you needed to, you could use settings and environment variables to configure OpenAPI conditionally depending on the environment, and even disable it entirely.

### About security, APIs, and docs

Hiding your documentation user interfaces in production *shouldn't* be the way to protect your API.

That doesn't add any extra security to your API, the *path operations* will still be available where they are.

If there's a security flaw in your code, it will still exist.

Hiding the documentation just makes it more difficult to understand how to interact with your API, and could make it more difficult for you to debug it in production. It could be considered simply a form of Security through obscurity.

If you want to secure your API, there are several better things you can do, for example:

- Make sure you have well defined Pydantic models for your request bodies and responses.
- Configure any required permissions and roles using dependencies.
- Never store plaintext passwords, only password hashes.
- Implement and use well-known cryptographic tools, like Passlib and JWT tokens, etc.
- Add more granular permission controls with OAuth2 scopes where needed.
- ...etc.

Nevertheless, you might have a very specific use case where you really need to disable the API docs for some environment (e.g. for production) or depending on configurations from environment variables.

### Conditional OpenAPI from settings and env vars

You can easily use the same Pydantic settings to configure your generated OpenAPI and the docs UIs.

For example:

`from fastapi import FastAPI from pydantic_settings import BaseSettings  class Settings(BaseSettings):     openapi_url: str = &quot;/openapi.json&quot;  settings = Settings()  app = FastAPI(openapi_url=settings.openapi_url)  @app.get(&quot;/&quot;) def root():     return {&quot;message&quot;: &quot;Hello World&quot;}`

Here we declare the setting `openapi_url` with the same default of `&quot;/openapi.json&quot;`.

And then we use it when creating the `FastAPI` app.

Then you could disable OpenAPI (including the UI docs) by setting the environment variable `OPENAPI_URL` to the empty string, like:

`$ OPENAPI_URL= uvicorn main:app  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

Then if you go to the URLs at `/openapi.json`, `/docs`, or `/redoc` you will just get a `404 Not Found` error like:

`{     &quot;detail&quot;: &quot;Not Found&quot; }`




In some cases, you may want to override the logic used by the `Request` and `APIRoute` classes.

In particular, this may be a good alternative to logic in a middleware.

For example, if you want to read or manipulate the request body before it is processed by your application.

Danger

This is an "advanced" feature.

If you are just starting with **FastAPI** you might want to skip this section.

### Use cases

Some use cases include:

- Converting non-JSON request bodies to JSON (e.g. `msgpack`).
- Decompressing gzip-compressed request bodies.
- Automatically logging all request bodies.

### Handling custom request body encodings

Let's see how to make use of a custom `Request` subclass to decompress gzip requests.

And an `APIRoute` subclass to use that custom request class.

#### Create a custom `GzipRequest` class

Tip

This is a toy example to demonstrate how it works, if you need Gzip support, you can use the provided `GzipMiddleware`.

First, we create a `GzipRequest` class, which will overwrite the `Request.body()` method to decompress the body in the presence of an appropriate header.

If there's no `gzip` in the header, it will not try to decompress the body.

That way, the same route class can handle gzip compressed or uncompressed requests.

`import gzip from typing import Callable, List  from fastapi import Body, FastAPI, Request, Response from fastapi.routing import APIRoute  class GzipRequest(Request):     async def body(self) -&gt; bytes:        if not hasattr(self, &quot;_body&quot;):            body = await super().body()            if &quot;gzip&quot; in self.headers.getlist(&quot;Content-Encoding&quot;):                body = gzip.decompress(body)            self._body = body        return self._body  class GzipRoute(APIRoute):     def get_route_handler(self) -&gt; Callable:         original_route_handler = super().get_route_handler()          async def custom_route_handler(request: Request) -&gt; Response:             request = GzipRequest(request.scope, request.receive)             return await original_route_handler(request)          return custom_route_handler  app = FastAPI() app.router.route_class = GzipRoute  @app.post(&quot;/sum&quot;) async def sum_numbers(numbers: List[int] = Body()):     return {&quot;sum&quot;: sum(numbers)}`

#### Create a custom `GzipRoute` class

Next, we create a custom subclass of `fastapi.routing.APIRoute` that will make use of the `GzipRequest`.

This time, it will overwrite the method `APIRoute.get_route_handler()`.

This method returns a function. And that function is what will receive a request and return a response.

Here we use it to create a `GzipRequest` from the original request.

`import gzip from typing import Callable, List  from fastapi import Body, FastAPI, Request, Response from fastapi.routing import APIRoute  class GzipRequest(Request):     async def body(self) -&gt; bytes:         if not hasattr(self, &quot;_body&quot;):             body = await super().body()             if &quot;gzip&quot; in self.headers.getlist(&quot;Content-Encoding&quot;):                 body = gzip.decompress(body)             self._body = body         return self._body  class GzipRoute(APIRoute):     def get_route_handler(self) -&gt; Callable:        original_route_handler = super().get_route_handler()         async def custom_route_handler(request: Request) -&gt; Response:            request = GzipRequest(request.scope, request.receive)            return await original_route_handler(request)         return custom_route_handler  app = FastAPI() app.router.route_class = GzipRoute  @app.post(&quot;/sum&quot;) async def sum_numbers(numbers: List[int] = Body()):     return {&quot;sum&quot;: sum(numbers)}`

Technical Details

A `Request` has a `request.scope` attribute, that's just a Python `dict` containing the metadata related to the request.

A `Request` also has a `request.receive`, that's a function to "receive" the body of the request.

The `scope` `dict` and `receive` function are both part of the ASGI specification.

And those two things, `scope` and `receive`, are what is needed to create a new `Request` instance.

To learn more about the `Request` check Starlette's docs about Requests.

The only thing the function returned by `GzipRequest.get_route_handler` does differently is convert the `Request` to a `GzipRequest`.

Doing this, our `GzipRequest` will take care of decompressing the data (if necessary) before passing it to our *path operations*.

After that, all of the processing logic is the same.

But because of our changes in `GzipRequest.body`, the request body will be automatically decompressed when it is loaded by **FastAPI** when needed.

### Accessing the request body in an exception handler

Tip

To solve this same problem, it's probably a lot easier to use the `body` in a custom handler for `RequestValidationError` (Handling Errors).

But this example is still valid and it shows how to interact with the internal components.

We can also use this same approach to access the request body in an exception handler.

All we need to do is handle the request inside a `try`/`except` block:

`from typing import Callable, List  from fastapi import Body, FastAPI, HTTPException, Request, Response from fastapi.exceptions import RequestValidationError from fastapi.routing import APIRoute  class ValidationErrorLoggingRoute(APIRoute):     def get_route_handler(self) -&gt; Callable:         original_route_handler = super().get_route_handler()          async def custom_route_handler(request: Request) -&gt; Response:             try:                return await original_route_handler(request)             except RequestValidationError as exc:                body = await request.body()                 detail = {&quot;errors&quot;: exc.errors(), &quot;body&quot;: body.decode()}                 raise HTTPException(status_code=422, detail=detail)          return custom_route_handler  app = FastAPI() app.router.route_class = ValidationErrorLoggingRoute  @app.post(&quot;/&quot;) async def sum_numbers(numbers: List[int] = Body()):     return sum(numbers)`

If an exception occurs, the`Request` instance will still be in scope, so we can read and make use of the request body when handling the error:

`from typing import Callable, List  from fastapi import Body, FastAPI, HTTPException, Request, Response from fastapi.exceptions import RequestValidationError from fastapi.routing import APIRoute  class ValidationErrorLoggingRoute(APIRoute):     def get_route_handler(self) -&gt; Callable:         original_route_handler = super().get_route_handler()          async def custom_route_handler(request: Request) -&gt; Response:             try:                 return await original_route_handler(request)             except RequestValidationError as exc:                 body = await request.body()                detail = {&quot;errors&quot;: exc.errors(), &quot;body&quot;: body.decode()}                raise HTTPException(status_code=422, detail=detail)         return custom_route_handler  app = FastAPI() app.router.route_class = ValidationErrorLoggingRoute  @app.post(&quot;/&quot;) async def sum_numbers(numbers: List[int] = Body()):     return sum(numbers)`

### Custom `APIRoute` class in a router

You can also set the `route_class` parameter of an `APIRouter`:

`import time from typing import Callable  from fastapi import APIRouter, FastAPI, Request, Response from fastapi.routing import APIRoute  class TimedRoute(APIRoute):     def get_route_handler(self) -&gt; Callable:         original_route_handler = super().get_route_handler()          async def custom_route_handler(request: Request) -&gt; Response:             before = time.time()             response: Response = await original_route_handler(request)             duration = time.time() - before             response.headers[&quot;X-Response-Time&quot;] = str(duration)             print(f&quot;route duration: {duration}&quot;)             print(f&quot;route response: {response}&quot;)             print(f&quot;route response headers: {response.headers}&quot;)             return response          return custom_route_handler  app = FastAPI() router = APIRouter(route_class=TimedRoute)  @app.get(&quot;/&quot;) async def not_timed():     return {&quot;message&quot;: &quot;Not timed&quot;}  @router.get(&quot;/timed&quot;) async def timed():     return {&quot;message&quot;: &quot;It's the time of my life&quot;}  app.include_router(router)`

In this example, the *path operations* under the `router` will use the custom `TimedRoute` class, and will have an extra `X-Response-Time` header in the response with the time it took to generate the response:

`import time from typing import Callable  from fastapi import APIRouter, FastAPI, Request, Response from fastapi.routing import APIRoute  class TimedRoute(APIRoute):     def get_route_handler(self) -&gt; Callable:         original_route_handler = super().get_route_handler()          async def custom_route_handler(request: Request) -&gt; Response:             before = time.time()            response: Response = await original_route_handler(request)            duration = time.time() - before            response.headers[&quot;X-Response-Time&quot;] = str(duration)            print(f&quot;route duration: {duration}&quot;)            print(f&quot;route response: {response}&quot;)            print(f&quot;route response headers: {response.headers}&quot;)            return response         return custom_route_handler  app = FastAPI() router = APIRouter(route_class=TimedRoute)  @app.get(&quot;/&quot;) async def not_timed():     return {&quot;message&quot;: &quot;Not timed&quot;}  @router.get(&quot;/timed&quot;) async def timed():     return {&quot;message&quot;: &quot;It's the time of my life&quot;}  app.include_router(router)`




As **FastAPI** is based on the **ASGI** standard, it's very easy to integrate any **GraphQL** library also compatible with ASGI.

You can combine normal FastAPI *path operations* with GraphQL on the same application.

Tip

**GraphQL** solves some very specific use cases.

It has **advantages** and **disadvantages** when compared to common **web APIs**.

Make sure you evaluate if the **benefits** for your use case compensate the **drawbacks**. 🤓

### GraphQL Libraries

Here are some of the **GraphQL** libraries that have **ASGI** support. You could use them with **FastAPI**:

- Strawberry 🍓
  - With docs for FastAPI
- Ariadne
  - With docs for Starlette (that also apply to FastAPI)
- Tartiflette
  - With Tartiflette ASGI to provide ASGI integration
- Graphene
  - With starlette-graphene3

### GraphQL with Strawberry

If you need or want to work with **GraphQL**, **Strawberry** is the **recommended** library as it has the design closest to **FastAPI's** design, it's all based on **type annotations**.

Depending on your use case, you might prefer to use a different library, but if you asked me, I would probably suggest you try **Strawberry**.

Here's a small preview of how you could integrate Strawberry with FastAPI:

`import strawberry from fastapi import FastAPI from strawberry.asgi import GraphQL  @strawberry.type class User:     name: str     age: int  @strawberry.type class Query:     @strawberry.field     def user(self) -&gt; User:         return User(name=&quot;Patrick&quot;, age=100)  schema = strawberry.Schema(query=Query)  graphql_app = GraphQL(schema) app = FastAPI() app.add_route(&quot;/graphql&quot;, graphql_app) app.add_websocket_route(&quot;/graphql&quot;, graphql_app)`

You can learn more about Strawberry in the Strawberry documentation.

And also the docs about Strawberry with FastAPI.

### Older `GraphQLApp` from Starlette

Previous versions of Starlette included a `GraphQLApp` class to integrate with Graphene.

It was deprecated from Starlette, but if you have code that used it, you can easily **migrate** to starlette-graphene3, that covers the same use case and has an **almost identical interface**.

Tip

If you need GraphQL, I still would recommend you check out Strawberry, as it's based on type annotations instead of custom classes and types.

### Learn More

You can learn more about **GraphQL** in the official GraphQL documentation.

You can also read more about each those libraries described above in their links.




There are some cases where you might need to modify the generated OpenAPI schema.

In this section you will see how.

### The normal process

The normal (default) process, is as follows.

A `FastAPI` application (instance) has an `.openapi()` method that is expected to return the OpenAPI schema.

As part of the application object creation, a *path operation* for `/openapi.json` (or for whatever you set your `openapi_url`) is registered.

It just returns a JSON response with the result of the application's `.openapi()` method.

By default, what the method `.openapi()` does is check the property `.openapi_schema` to see if it has contents and return them.

If it doesn't, it generates them using the utility function at `fastapi.openapi.utils.get_openapi`.

And that function `get_openapi()` receives as parameters:

- `title`: The OpenAPI title, shown in the docs.
- `version`: The version of your API, e.g. `2.5.0`.
- `openapi_version`: The version of the OpenAPI specification used. By default, the latest: `3.1.0`.
- `summary`: A short summary of the API.
- `description`: The description of your API, this can include markdown and will be shown in the docs.
- `routes`: A list of routes, these are each of the registered *path operations*. They are taken from `app.routes`.

Info

The parameter `summary` is available in OpenAPI 3.1.0 and above, supported by FastAPI 0.99.0 and above.

### Overriding the defaults

Using the information above, you can use the same utility function to generate the OpenAPI schema and override each part that you need.

For example, let's add ReDoc's OpenAPI extension to include a custom logo.

#### Normal **FastAPI**

First, write all your **FastAPI** application as normally:

`from fastapi import FastAPI from fastapi.openapi.utils import get_openapi  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;name&quot;: &quot;Foo&quot;}]  def custom_openapi():     if app.openapi_schema:         return app.openapi_schema     openapi_schema = get_openapi(         title=&quot;Custom title&quot;,         version=&quot;2.5.0&quot;,         summary=&quot;This is a very custom OpenAPI schema&quot;,         description=&quot;Here's a longer description of the custom **OpenAPI** schema&quot;,         routes=app.routes,     )     openapi_schema[&quot;info&quot;][&quot;x-logo&quot;] = {         &quot;url&quot;: &quot;https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png&quot;     }     app.openapi_schema = openapi_schema     return app.openapi_schema  app.openapi = custom_openapi`

#### Generate the OpenAPI schema

Then, use the same utility function to generate the OpenAPI schema, inside a `custom_openapi()` function:

`from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;name&quot;: &quot;Foo&quot;}]  def custom_openapi():     if app.openapi_schema:         return app.openapi_schema     openapi_schema = get_openapi(        title=&quot;Custom title&quot;,        version=&quot;2.5.0&quot;,        summary=&quot;This is a very custom OpenAPI schema&quot;,        description=&quot;Here's a longer description of the custom **OpenAPI** schema&quot;,        routes=app.routes,    )    openapi_schema[&quot;info&quot;][&quot;x-logo&quot;] = {         &quot;url&quot;: &quot;https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png&quot;     }     app.openapi_schema = openapi_schema     return app.openapi_schema  app.openapi = custom_openapi`

#### Modify the OpenAPI schema

Now you can add the ReDoc extension, adding a custom `x-logo` to the `info` "object" in the OpenAPI schema:

`from fastapi import FastAPI from fastapi.openapi.utils import get_openapi  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;name&quot;: &quot;Foo&quot;}]  def custom_openapi():     if app.openapi_schema:         return app.openapi_schema     openapi_schema = get_openapi(         title=&quot;Custom title&quot;,         version=&quot;2.5.0&quot;,         summary=&quot;This is a very custom OpenAPI schema&quot;,         description=&quot;Here's a longer description of the custom **OpenAPI** schema&quot;,         routes=app.routes,     )     openapi_schema[&quot;info&quot;][&quot;x-logo&quot;] = {        &quot;url&quot;: &quot;https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png&quot;    }    app.openapi_schema = openapi_schema     return app.openapi_schema  app.openapi = custom_openapi`

#### Cache the OpenAPI schema

You can use the property `.openapi_schema` as a "cache", to store your generated schema.

That way, your application won't have to generate the schema every time a user opens your API docs.

It will be generated only once, and then the same cached schema will be used for the next requests.

`from fastapi import FastAPI from fastapi.openapi.utils import get_openapi  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;name&quot;: &quot;Foo&quot;}]  def custom_openapi():     if app.openapi_schema:        return app.openapi_schema    openapi_schema = get_openapi(         title=&quot;Custom title&quot;,         version=&quot;2.5.0&quot;,         summary=&quot;This is a very custom OpenAPI schema&quot;,         description=&quot;Here's a longer description of the custom **OpenAPI** schema&quot;,         routes=app.routes,     )     openapi_schema[&quot;info&quot;][&quot;x-logo&quot;] = {         &quot;url&quot;: &quot;https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png&quot;     }     app.openapi_schema = openapi_schema    return app.openapi_schema  app.openapi = custom_openapi`

#### Override the method

Now you can replace the `.openapi()` method with your new function.

`from fastapi import FastAPI from fastapi.openapi.utils import get_openapi  app = FastAPI()  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;name&quot;: &quot;Foo&quot;}]  def custom_openapi():     if app.openapi_schema:         return app.openapi_schema     openapi_schema = get_openapi(         title=&quot;Custom title&quot;,         version=&quot;2.5.0&quot;,         summary=&quot;This is a very custom OpenAPI schema&quot;,         description=&quot;Here's a longer description of the custom **OpenAPI** schema&quot;,         routes=app.routes,     )     openapi_schema[&quot;info&quot;][&quot;x-logo&quot;] = {         &quot;url&quot;: &quot;https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png&quot;     }     app.openapi_schema = openapi_schema     return app.openapi_schema  app.openapi = custom_openapi`

#### Check it

Once you go to http://127.0.0.1:8000/redoc you will see that you are using your custom logo (in this example, **FastAPI**'s logo):

<image @ https://fastapi.tiangolo.com/img/tutorial/extending-openapi/image01.png>




The API docs use **Swagger UI** and **ReDoc**, and each of those need some JavaScript and CSS files.

By default, those files are served from a CDN.

But it's possible to customize it, you can set a specific CDN, or serve the files yourself.

### Custom CDN for JavaScript and CSS

Let's say that you want to use a different CDN, for example you want to use `https://unpkg.com/`.

This could be useful if for example you live in a country that restricts some URLs.

#### Disable the automatic docs

The first step is to disable the automatic docs, as by default, those use the default CDN.

To disable them, set their URLs to `None` when creating your `FastAPI` app:

`from fastapi import FastAPI from fastapi.openapi.docs import (     get_redoc_html,     get_swagger_ui_html,     get_swagger_ui_oauth2_redirect_html, )  app = FastAPI(docs_url=None, redoc_url=None)  @app.get(&quot;/docs&quot;, include_in_schema=False) async def custom_swagger_ui_html():     return get_swagger_ui_html(         openapi_url=app.openapi_url,         title=app.title + &quot; - Swagger UI&quot;,         oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,         swagger_js_url=&quot;https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js&quot;,         swagger_css_url=&quot;https://unpkg.com/swagger-ui-dist@5/swagger-ui.css&quot;,     )  @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect():     return get_swagger_ui_oauth2_redirect_html()  @app.get(&quot;/redoc&quot;, include_in_schema=False) async def redoc_html():     return get_redoc_html(         openapi_url=app.openapi_url,         title=app.title + &quot; - ReDoc&quot;,         redoc_js_url=&quot;https://unpkg.com/redoc@next/bundles/redoc.standalone.js&quot;,     )  @app.get(&quot;/users/{username}&quot;) async def read_user(username: str):     return {&quot;message&quot;: f&quot;Hello {username}&quot;}`

#### Include the custom docs

Now you can create the *path operations* for the custom docs.

You can re-use FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments:

- `openapi_url`: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute `app.openapi_url`.
- `title`: the title of your API.
- `oauth2_redirect_url`: you can use `app.swagger_ui_oauth2_redirect_url` here to use the default.
- `swagger_js_url`: the URL where the HTML for your Swagger UI docs can get the **JavaScript** file. This is the custom CDN URL.
- `swagger_css_url`: the URL where the HTML for your Swagger UI docs can get the **CSS** file. This is the custom CDN URL.

And similarly for ReDoc...

`from fastapi import FastAPI from fastapi.openapi.docs import (     get_redoc_html,    get_swagger_ui_html,    get_swagger_ui_oauth2_redirect_html, ) app = FastAPI(docs_url=None, redoc_url=None)  @app.get(&quot;/docs&quot;, include_in_schema=False) async def custom_swagger_ui_html():     return get_swagger_ui_html(        openapi_url=app.openapi_url,        title=app.title + &quot; - Swagger UI&quot;,        oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,        swagger_js_url=&quot;https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js&quot;,        swagger_css_url=&quot;https://unpkg.com/swagger-ui-dist@5/swagger-ui.css&quot;,    )  @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect():     return get_swagger_ui_oauth2_redirect_html()  @app.get(&quot;/redoc&quot;, include_in_schema=False) async def redoc_html():     return get_redoc_html(        openapi_url=app.openapi_url,        title=app.title + &quot; - ReDoc&quot;,        redoc_js_url=&quot;https://unpkg.com/redoc@next/bundles/redoc.standalone.js&quot;,    )  @app.get(&quot;/users/{username}&quot;) async def read_user(username: str):     return {&quot;message&quot;: f&quot;Hello {username}&quot;}`

Tip

The *path operation* for `swagger_ui_redirect` is a helper for when you use OAuth2.

If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication.

Swagger UI will handle it behind the scenes for you, but it needs this "redirect" helper.

#### Create a *path operation* to test it

Now, to be able to test that everything works, create a *path operation*:

`from fastapi import FastAPI from fastapi.openapi.docs import (     get_redoc_html,     get_swagger_ui_html,     get_swagger_ui_oauth2_redirect_html, )  app = FastAPI(docs_url=None, redoc_url=None)  @app.get(&quot;/docs&quot;, include_in_schema=False) async def custom_swagger_ui_html():     return get_swagger_ui_html(         openapi_url=app.openapi_url,         title=app.title + &quot; - Swagger UI&quot;,         oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,         swagger_js_url=&quot;https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js&quot;,         swagger_css_url=&quot;https://unpkg.com/swagger-ui-dist@5/swagger-ui.css&quot;,     )  @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect():     return get_swagger_ui_oauth2_redirect_html()  @app.get(&quot;/redoc&quot;, include_in_schema=False) async def redoc_html():     return get_redoc_html(         openapi_url=app.openapi_url,         title=app.title + &quot; - ReDoc&quot;,         redoc_js_url=&quot;https://unpkg.com/redoc@next/bundles/redoc.standalone.js&quot;,     )  @app.get(&quot;/users/{username}&quot;) async def read_user(username: str):     return {&quot;message&quot;: f&quot;Hello {username}&quot;}`

#### Test it

Now, you should be able to go to your docs at http://127.0.0.1:8000/docs, and reload the page, it will load those assets from the new CDN.

### Self-hosting JavaScript and CSS for docs

Self-hosting the JavaScript and CSS could be useful if, for example, you need your app to keep working even while offline, without open Internet access, or in a local network.

Here you'll see how to serve those files yourself, in the same FastAPI app, and configure the docs to use them.

#### Project file structure

Let's say your project file structure looks like this:

`. ├── app │   ├── __init__.py │   ├── main.py`

Now create a directory to store those static files.

Your new file structure could look like this:

`. ├── app │   ├── __init__.py │   ├── main.py └── static/`

#### Download the files

Download the static files needed for the docs and put them on that `static/` directory.

You can probably right-click each link and select an option similar to `Save link as...`.

**Swagger UI** uses the files:

- `swagger-ui-bundle.js`
- `swagger-ui.css`

And **ReDoc** uses the file:

- `redoc.standalone.js`

After that, your file structure could look like:

`. ├── app │   ├── __init__.py │   ├── main.py └── static     ├── redoc.standalone.js     ├── swagger-ui-bundle.js     └── swagger-ui.css`

#### Serve the static files

- Import `StaticFiles`.
- "Mount" a `StaticFiles()` instance in a specific path.

`from fastapi import FastAPI from fastapi.openapi.docs import (     get_redoc_html,     get_swagger_ui_html,     get_swagger_ui_oauth2_redirect_html, ) from fastapi.staticfiles import StaticFiles app = FastAPI(docs_url=None, redoc_url=None)  app.mount(&quot;/static&quot;, StaticFiles(directory=&quot;static&quot;), name=&quot;static&quot;)  @app.get(&quot;/docs&quot;, include_in_schema=False) async def custom_swagger_ui_html():     return get_swagger_ui_html(         openapi_url=app.openapi_url,         title=app.title + &quot; - Swagger UI&quot;,         oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,         swagger_js_url=&quot;/static/swagger-ui-bundle.js&quot;,         swagger_css_url=&quot;/static/swagger-ui.css&quot;,     )  @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect():     return get_swagger_ui_oauth2_redirect_html()  @app.get(&quot;/redoc&quot;, include_in_schema=False) async def redoc_html():     return get_redoc_html(         openapi_url=app.openapi_url,         title=app.title + &quot; - ReDoc&quot;,         redoc_js_url=&quot;/static/redoc.standalone.js&quot;,     )  @app.get(&quot;/users/{username}&quot;) async def read_user(username: str):     return {&quot;message&quot;: f&quot;Hello {username}&quot;}`

#### Test the static files

Start your application and go to http://127.0.0.1:8000/static/redoc.standalone.js.

You should see a very long JavaScript file for **ReDoc**.

It could start with something like:

`/*!  * ReDoc - OpenAPI/Swagger-generated API Reference Documentation  * -------------------------------------------------------------  *   Version: &quot;2.0.0-rc.18&quot;  *   Repo: https://github.com/Redocly/redoc  */ !function(e,t){&quot;object&quot;==typeof exports&amp;&amp;&quot;object&quot;==typeof m  ...`

That confirms that you are being able to serve static files from your app, and that you placed the static files for the docs in the correct place.

Now we can configure the app to use those static files for the docs.

#### Disable the automatic docs for static files

The same as when using a custom CDN, the first step is to disable the automatic docs, as those use the CDN by default.

To disable them, set their URLs to `None` when creating your `FastAPI` app:

`from fastapi import FastAPI from fastapi.openapi.docs import (     get_redoc_html,     get_swagger_ui_html,     get_swagger_ui_oauth2_redirect_html, ) from fastapi.staticfiles import StaticFiles  app = FastAPI(docs_url=None, redoc_url=None) app.mount(&quot;/static&quot;, StaticFiles(directory=&quot;static&quot;), name=&quot;static&quot;)  @app.get(&quot;/docs&quot;, include_in_schema=False) async def custom_swagger_ui_html():     return get_swagger_ui_html(         openapi_url=app.openapi_url,         title=app.title + &quot; - Swagger UI&quot;,         oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,         swagger_js_url=&quot;/static/swagger-ui-bundle.js&quot;,         swagger_css_url=&quot;/static/swagger-ui.css&quot;,     )  @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect():     return get_swagger_ui_oauth2_redirect_html()  @app.get(&quot;/redoc&quot;, include_in_schema=False) async def redoc_html():     return get_redoc_html(         openapi_url=app.openapi_url,         title=app.title + &quot; - ReDoc&quot;,         redoc_js_url=&quot;/static/redoc.standalone.js&quot;,     )  @app.get(&quot;/users/{username}&quot;) async def read_user(username: str):     return {&quot;message&quot;: f&quot;Hello {username}&quot;}`

#### Include the custom docs for static files

And the same way as with a custom CDN, now you can create the *path operations* for the custom docs.

Again, you can re-use FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments:

- `openapi_url`: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute `app.openapi_url`.
- `title`: the title of your API.
- `oauth2_redirect_url`: you can use `app.swagger_ui_oauth2_redirect_url` here to use the default.
- `swagger_js_url`: the URL where the HTML for your Swagger UI docs can get the **JavaScript** file. **This is the one that your own app is now serving**.
- `swagger_css_url`: the URL where the HTML for your Swagger UI docs can get the **CSS** file. **This is the one that your own app is now serving**.

And similarly for ReDoc...

`from fastapi import FastAPI from fastapi.openapi.docs import (     get_redoc_html,    get_swagger_ui_html,    get_swagger_ui_oauth2_redirect_html, ) from fastapi.staticfiles import StaticFiles  app = FastAPI(docs_url=None, redoc_url=None)  app.mount(&quot;/static&quot;, StaticFiles(directory=&quot;static&quot;), name=&quot;static&quot;)  @app.get(&quot;/docs&quot;, include_in_schema=False) async def custom_swagger_ui_html():     return get_swagger_ui_html(        openapi_url=app.openapi_url,        title=app.title + &quot; - Swagger UI&quot;,        oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,        swagger_js_url=&quot;/static/swagger-ui-bundle.js&quot;,        swagger_css_url=&quot;/static/swagger-ui.css&quot;,    )  @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect():     return get_swagger_ui_oauth2_redirect_html()  @app.get(&quot;/redoc&quot;, include_in_schema=False) async def redoc_html():     return get_redoc_html(        openapi_url=app.openapi_url,        title=app.title + &quot; - ReDoc&quot;,        redoc_js_url=&quot;/static/redoc.standalone.js&quot;,    )  @app.get(&quot;/users/{username}&quot;) async def read_user(username: str):     return {&quot;message&quot;: f&quot;Hello {username}&quot;}`

Tip

The *path operation* for `swagger_ui_redirect` is a helper for when you use OAuth2.

If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication.

Swagger UI will handle it behind the scenes for you, but it needs this "redirect" helper.

#### Create a *path operation* to test static files

Now, to be able to test that everything works, create a *path operation*:

`from fastapi import FastAPI from fastapi.openapi.docs import (     get_redoc_html,     get_swagger_ui_html,     get_swagger_ui_oauth2_redirect_html, ) from fastapi.staticfiles import StaticFiles  app = FastAPI(docs_url=None, redoc_url=None)  app.mount(&quot;/static&quot;, StaticFiles(directory=&quot;static&quot;), name=&quot;static&quot;)  @app.get(&quot;/docs&quot;, include_in_schema=False) async def custom_swagger_ui_html():     return get_swagger_ui_html(         openapi_url=app.openapi_url,         title=app.title + &quot; - Swagger UI&quot;,         oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,         swagger_js_url=&quot;/static/swagger-ui-bundle.js&quot;,         swagger_css_url=&quot;/static/swagger-ui.css&quot;,     )  @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect():     return get_swagger_ui_oauth2_redirect_html()  @app.get(&quot;/redoc&quot;, include_in_schema=False) async def redoc_html():     return get_redoc_html(         openapi_url=app.openapi_url,         title=app.title + &quot; - ReDoc&quot;,         redoc_js_url=&quot;/static/redoc.standalone.js&quot;,     )  @app.get(&quot;/users/{username}&quot;) async def read_user(username: str):     return {&quot;message&quot;: f&quot;Hello {username}&quot;}`

#### Test Static Files UI

Now, you should be able to disconnect your WiFi, go to your docs at http://127.0.0.1:8000/docs, and reload the page.

And even without Internet, you would be able to see the docs for your API and interact with it.




You can configure some extra Swagger UI parameters.

To configure them, pass the `swagger_ui_parameters` argument when creating the `FastAPI()` app object or to the `get_swagger_ui_html()` function.

`swagger_ui_parameters` receives a dictionary with the configurations passed to Swagger UI directly.

FastAPI converts the configurations to **JSON** to make them compatible with JavaScript, as that's what Swagger UI needs.

### Disable Syntax Highlighting

For example, you could disable syntax highlighting in Swagger UI.

Without changing the settings, syntax highlighting is enabled by default:

<image @ https://fastapi.tiangolo.com/img/tutorial/extending-openapi/image02.png>

But you can disable it by setting `syntaxHighlight` to `False`:

`from fastapi import FastAPI  app = FastAPI(swagger_ui_parameters={&quot;syntaxHighlight&quot;: False})  @app.get(&quot;/users/{username}&quot;) async def read_user(username: str):     return {&quot;message&quot;: f&quot;Hello {username}&quot;}`

...and then Swagger UI won't show the syntax highlighting anymore:

<image @ https://fastapi.tiangolo.com/img/tutorial/extending-openapi/image03.png>

### Change the Theme

The same way you could set the syntax highlighting theme with the key `&quot;syntaxHighlight.theme&quot;` (notice that it has a dot in the middle):

`from fastapi import FastAPI  app = FastAPI(swagger_ui_parameters={&quot;syntaxHighlight.theme&quot;: &quot;obsidian&quot;})  @app.get(&quot;/users/{username}&quot;) async def read_user(username: str):     return {&quot;message&quot;: f&quot;Hello {username}&quot;}`

That configuration would change the syntax highlighting color theme:

<image @ https://fastapi.tiangolo.com/img/tutorial/extending-openapi/image04.png>

### Change Default Swagger UI Parameters

FastAPI includes some default configuration parameters appropriate for most of the use cases.

It includes these default configurations:

`swagger_ui_default_parameters = {     &quot;dom_id&quot;: &quot;#swagger-ui&quot;,     &quot;layout&quot;: &quot;BaseLayout&quot;,     &quot;deepLinking&quot;: True,     &quot;showExtensions&quot;: True,     &quot;showCommonExtensions&quot;: True, }`

You can override any of them by setting a different value in the argument `swagger_ui_parameters`.

For example, to disable `deepLinking` you could pass these settings to `swagger_ui_parameters`:

`from fastapi import FastAPI  app = FastAPI(swagger_ui_parameters={&quot;deepLinking&quot;: False})  @app.get(&quot;/users/{username}&quot;) async def read_user(username: str):     return {&quot;message&quot;: f&quot;Hello {username}&quot;}`

### Other Swagger UI Parameters

To see all the other possible configurations you can use, read the official docs for Swagger UI parameters.

### JavaScript-only settings

Swagger UI also allows other configurations to be **JavaScript-only** objects (for example, JavaScript functions).

FastAPI also includes these JavaScript-only `presets` settings:

`presets: [     SwaggerUIBundle.presets.apis,     SwaggerUIBundle.SwaggerUIStandalonePreset ]`

These are **JavaScript** objects, not strings, so you can't pass them from Python code directly.

If you need to use JavaScript-only configurations like those, you can use one of the methods above. Override all the Swagger UI *path operation* and manually write any JavaScript you need.




You can create dependencies that have **sub-dependencies**.

They can be as **deep** as you need them to be.

**FastAPI** will take care of solving them.

### First dependency "dependable"

You could create a first dependency ("dependable") like:

Python 3.10+Python 3.9+Python 3.6+Python 3.10 non-AnnotatedPython 3.6 non-Annotated

`from typing import Annotated  from fastapi import Cookie, Depends, FastAPI  app = FastAPI()  def query_extractor(q: str | None = None):     return q  def query_or_cookie_extractor(     q: Annotated[str, Depends(query_extractor)],     last_query: Annotated[str | None, Cookie()] = None, ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(     query_or_default: Annotated[str, Depends(query_or_cookie_extractor)] ):     return {&quot;q_or_cookie&quot;: query_or_default}`

`from typing import Annotated, Union  from fastapi import Cookie, Depends, FastAPI  app = FastAPI()  def query_extractor(q: Union[str, None] = None):     return q  def query_or_cookie_extractor(     q: Annotated[str, Depends(query_extractor)],     last_query: Annotated[Union[str, None], Cookie()] = None, ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(     query_or_default: Annotated[str, Depends(query_or_cookie_extractor)] ):     return {&quot;q_or_cookie&quot;: query_or_default}`

`from typing import Union  from fastapi import Cookie, Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  def query_extractor(q: Union[str, None] = None):     return q  def query_or_cookie_extractor(     q: Annotated[str, Depends(query_extractor)],     last_query: Annotated[Union[str, None], Cookie()] = None, ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(     query_or_default: Annotated[str, Depends(query_or_cookie_extractor)] ):     return {&quot;q_or_cookie&quot;: query_or_default}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Cookie, Depends, FastAPI  app = FastAPI()  def query_extractor(q: str | None = None):     return q  def query_or_cookie_extractor(     q: str = Depends(query_extractor), last_query: str | None = Cookie(default=None) ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):     return {&quot;q_or_cookie&quot;: query_or_default}`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Cookie, Depends, FastAPI  app = FastAPI()  def query_extractor(q: Union[str, None] = None):     return q  def query_or_cookie_extractor(     q: str = Depends(query_extractor),     last_query: Union[str, None] = Cookie(default=None), ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):     return {&quot;q_or_cookie&quot;: query_or_default}`

It declares an optional query parameter `q` as a `str`, and then it just returns it.

This is quite simple (not very useful), but will help us focus on how the sub-dependencies work.

### Second dependency, "dependable" and "dependant"

Then you can create another dependency function (a "dependable") that at the same time declares a dependency of its own (so it is a "dependant" too):

Python 3.10+Python 3.9+Python 3.6+Python 3.10 non-AnnotatedPython 3.6 non-Annotated

`from typing import Annotated  from fastapi import Cookie, Depends, FastAPI  app = FastAPI()  def query_extractor(q: str | None = None):     return q  def query_or_cookie_extractor(     q: Annotated[str, Depends(query_extractor)],    last_query: Annotated[str | None, Cookie()] = None, ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(     query_or_default: Annotated[str, Depends(query_or_cookie_extractor)] ):     return {&quot;q_or_cookie&quot;: query_or_default}`

`from typing import Annotated, Union  from fastapi import Cookie, Depends, FastAPI  app = FastAPI()  def query_extractor(q: Union[str, None] = None):     return q  def query_or_cookie_extractor(     q: Annotated[str, Depends(query_extractor)],    last_query: Annotated[Union[str, None], Cookie()] = None, ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(     query_or_default: Annotated[str, Depends(query_or_cookie_extractor)] ):     return {&quot;q_or_cookie&quot;: query_or_default}`

`from typing import Union  from fastapi import Cookie, Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  def query_extractor(q: Union[str, None] = None):     return q  def query_or_cookie_extractor(     q: Annotated[str, Depends(query_extractor)],    last_query: Annotated[Union[str, None], Cookie()] = None, ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(     query_or_default: Annotated[str, Depends(query_or_cookie_extractor)] ):     return {&quot;q_or_cookie&quot;: query_or_default}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Cookie, Depends, FastAPI  app = FastAPI()  def query_extractor(q: str | None = None):     return q  def query_or_cookie_extractor(     q: str = Depends(query_extractor), last_query: str | None = Cookie(default=None) ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):     return {&quot;q_or_cookie&quot;: query_or_default}`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Cookie, Depends, FastAPI  app = FastAPI()  def query_extractor(q: Union[str, None] = None):     return q  def query_or_cookie_extractor(     q: str = Depends(query_extractor),    last_query: Union[str, None] = Cookie(default=None), ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):     return {&quot;q_or_cookie&quot;: query_or_default}`

Let's focus on the parameters declared:

- Even though this function is a dependency ("dependable") itself, it also declares another dependency (it "depends" on something else).
  - It depends on the `query_extractor`, and assigns the value returned by it to the parameter `q`.
- It also declares an optional `last_query` cookie, as a `str`.
  - If the user didn't provide any query `q`, we use the last query used, which we saved to a cookie before.

### Use the dependency

Then we can use the dependency with:

Python 3.10+Python 3.9+Python 3.6+Python 3.10 non-AnnotatedPython 3.6 non-Annotated

`from typing import Annotated  from fastapi import Cookie, Depends, FastAPI  app = FastAPI()  def query_extractor(q: str | None = None):     return q  def query_or_cookie_extractor(     q: Annotated[str, Depends(query_extractor)],     last_query: Annotated[str | None, Cookie()] = None, ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(     query_or_default: Annotated[str, Depends(query_or_cookie_extractor)] ):     return {&quot;q_or_cookie&quot;: query_or_default}`

`from typing import Annotated, Union  from fastapi import Cookie, Depends, FastAPI  app = FastAPI()  def query_extractor(q: Union[str, None] = None):     return q  def query_or_cookie_extractor(     q: Annotated[str, Depends(query_extractor)],     last_query: Annotated[Union[str, None], Cookie()] = None, ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(     query_or_default: Annotated[str, Depends(query_or_cookie_extractor)] ):     return {&quot;q_or_cookie&quot;: query_or_default}`

`from typing import Union  from fastapi import Cookie, Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  def query_extractor(q: Union[str, None] = None):     return q  def query_or_cookie_extractor(     q: Annotated[str, Depends(query_extractor)],     last_query: Annotated[Union[str, None], Cookie()] = None, ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(     query_or_default: Annotated[str, Depends(query_or_cookie_extractor)] ):     return {&quot;q_or_cookie&quot;: query_or_default}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Cookie, Depends, FastAPI  app = FastAPI()  def query_extractor(q: str | None = None):     return q  def query_or_cookie_extractor(     q: str = Depends(query_extractor), last_query: str | None = Cookie(default=None) ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):     return {&quot;q_or_cookie&quot;: query_or_default}`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Cookie, Depends, FastAPI  app = FastAPI()  def query_extractor(q: Union[str, None] = None):     return q  def query_or_cookie_extractor(     q: str = Depends(query_extractor),     last_query: Union[str, None] = Cookie(default=None), ):     if not q:         return last_query     return q  @app.get(&quot;/items/&quot;) async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):     return {&quot;q_or_cookie&quot;: query_or_default}`

Info

Notice that we are only declaring one dependency in the *path operation function*, the `query_or_cookie_extractor`.

But **FastAPI** will know that it has to solve `query_extractor` first, to pass the results of that to `query_or_cookie_extractor` while calling it.

```
graph TB

query_extractor(["query_extractor"])
query_or_cookie_extractor(["query_or_cookie_extractor"])

read_query["/items/"]

query_extractor --> query_or_cookie_extractor --> read_query
```

### Using the same dependency multiple times

If one of your dependencies is declared multiple times for the same *path operation*, for example, multiple dependencies have a common sub-dependency, **FastAPI** will know to call that sub-dependency only once per request.

And it will save the returned value in a "cache" and pass it to all the "dependants" that need it in that specific request, instead of calling the dependency multiple times for the same request.

In an advanced scenario where you know you need the dependency to be called at every step (possibly multiple times) in the same request instead of using the "cached" value, you can set the parameter `use_cache=False` when using `Depends`:

Python 3.6+Python 3.6+ non-Annotated

`async def needy_dependency(fresh_value: Annotated[str, Depends(get_value, use_cache=False)]):     return {&quot;fresh_value&quot;: fresh_value}`

Tip

Prefer to use the `Annotated` version if possible.

`async def needy_dependency(fresh_value: str = Depends(get_value, use_cache=False)):     return {&quot;fresh_value&quot;: fresh_value}`

### Recap

Apart from all the fancy words used here, the **Dependency Injection** system is quite simple.

Just functions that look the same as the *path operation functions*.

But still, it is very powerful, and allows you to declare arbitrarily deeply nested dependency "graphs" (trees).

Tip

All this might not seem as useful with these simple examples.

But you will see how useful it is in the chapters about **security**.

And you will also see the amounts of code it will save you.




In some cases you don't really need the return value of a dependency inside your *path operation function*.

Or the dependency doesn't return a value.

But you still need it to be executed/solved.

For those cases, instead of declaring a *path operation function* parameter with `Depends`, you can add a `list` of `dependencies` to the *path operation decorator*.

### Add `dependencies` to the *path operation decorator*

The *path operation decorator* receives an optional argument `dependencies`.

It should be a `list` of `Depends()`:

Python 3.9+Python 3.6+Python 3.6 non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI, Header, HTTPException  app = FastAPI()  async def verify_token(x_token: Annotated[str, Header()]):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def verify_key(x_key: Annotated[str, Header()]):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)     return x_key  @app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items():     return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}]`

`from fastapi import Depends, FastAPI, Header, HTTPException from typing_extensions import Annotated  app = FastAPI()  async def verify_token(x_token: Annotated[str, Header()]):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def verify_key(x_key: Annotated[str, Header()]):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)     return x_key  @app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items():     return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}]`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI, Header, HTTPException  app = FastAPI()  async def verify_token(x_token: str = Header()):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def verify_key(x_key: str = Header()):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)     return x_key  @app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items():     return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}]`

These dependencies will be executed/solved the same way normal dependencies. But their value (if they return any) won't be passed to your *path operation function*.

Tip

Some editors check for unused function parameters, and show them as errors.

Using these `dependencies` in the *path operation decorator* you can make sure they are executed while avoiding editor/tooling errors.

It might also help avoid confusion for new developers that see an unused parameter in your code and could think it's unnecessary.

Info

In this example we use invented custom headers `X-Key` and `X-Token`.

But in real cases, when implementing security, you would get more benefits from using the integrated Security utilities (the next chapter).

### Dependencies errors and return values

You can use the same dependency *functions* you use normally.

#### Dependency requirements

They can declare request requirements (like headers) or other sub-dependencies:

Python 3.9+Python 3.6+Python 3.6 non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI, Header, HTTPException  app = FastAPI()  async def verify_token(x_token: Annotated[str, Header()]):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def verify_key(x_key: Annotated[str, Header()]):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)     return x_key  @app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items():     return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}]`

`from fastapi import Depends, FastAPI, Header, HTTPException from typing_extensions import Annotated  app = FastAPI()  async def verify_token(x_token: Annotated[str, Header()]):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def verify_key(x_key: Annotated[str, Header()]):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)     return x_key  @app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items():     return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}]`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI, Header, HTTPException  app = FastAPI()  async def verify_token(x_token: str = Header()):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def verify_key(x_key: str = Header()):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)     return x_key  @app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items():     return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}]`

#### Raise exceptions

These dependencies can `raise` exceptions, the same as normal dependencies:

Python 3.9+Python 3.6+Python 3.6 non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI, Header, HTTPException  app = FastAPI()  async def verify_token(x_token: Annotated[str, Header()]):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def verify_key(x_key: Annotated[str, Header()]):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)    return x_key  @app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items():     return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}]`

`from fastapi import Depends, FastAPI, Header, HTTPException from typing_extensions import Annotated  app = FastAPI()  async def verify_token(x_token: Annotated[str, Header()]):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def verify_key(x_key: Annotated[str, Header()]):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)    return x_key  @app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items():     return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}]`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI, Header, HTTPException  app = FastAPI()  async def verify_token(x_token: str = Header()):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def verify_key(x_key: str = Header()):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)    return x_key  @app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items():     return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}]`

#### Return values

And they can return values or not, the values won't be used.

So, you can re-use a normal dependency (that returns a value) you already use somewhere else, and even though the value won't be used, the dependency will be executed:

Python 3.9+Python 3.6+Python 3.6 non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI, Header, HTTPException  app = FastAPI()  async def verify_token(x_token: Annotated[str, Header()]):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;) async def verify_key(x_key: Annotated[str, Header()]):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)     return x_key  @app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items():     return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}]`

`from fastapi import Depends, FastAPI, Header, HTTPException from typing_extensions import Annotated  app = FastAPI()  async def verify_token(x_token: Annotated[str, Header()]):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;) async def verify_key(x_key: Annotated[str, Header()]):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)     return x_key  @app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items():     return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}]`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI, Header, HTTPException  app = FastAPI()  async def verify_token(x_token: str = Header()):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;) async def verify_key(x_key: str = Header()):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)     return x_key  @app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items():     return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}]`

### Dependencies for a group of *path operations*

Later, when reading about how to structure bigger applications (Bigger Applications - Multiple Files), possibly with multiple files, you will learn how to declare a single `dependencies` parameter for a group of *path operations*.

### Global Dependencies

Next we will see how to add dependencies to the whole `FastAPI` application, so that they apply to each *path operation*.




For some types of applications you might want to add dependencies to the whole application.

Similar to the way you can add `dependencies` to the *path operation decorators*, you can add them to the `FastAPI` application.

In that case, they will be applied to all the *path operations* in the application:

Python 3.9+Python 3.6+Python 3.6 non-Annotated

`from fastapi import Depends, FastAPI, Header, HTTPException from typing_extensions import Annotated  async def verify_token(x_token: Annotated[str, Header()]):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def verify_key(x_key: Annotated[str, Header()]):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)     return x_key  app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;item&quot;: &quot;Portal Gun&quot;}, {&quot;item&quot;: &quot;Plumbus&quot;}]  @app.get(&quot;/users/&quot;) async def read_users():     return [{&quot;username&quot;: &quot;Rick&quot;}, {&quot;username&quot;: &quot;Morty&quot;}]`

`from fastapi import Depends, FastAPI, Header, HTTPException from typing_extensions import Annotated  async def verify_token(x_token: Annotated[str, Header()]):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def verify_key(x_key: Annotated[str, Header()]):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)     return x_key  app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;item&quot;: &quot;Portal Gun&quot;}, {&quot;item&quot;: &quot;Plumbus&quot;}]  @app.get(&quot;/users/&quot;) async def read_users():     return [{&quot;username&quot;: &quot;Rick&quot;}, {&quot;username&quot;: &quot;Morty&quot;}]`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI, Header, HTTPException  async def verify_token(x_token: str = Header()):     if x_token != &quot;fake-super-secret-token&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)  async def verify_key(x_key: str = Header()):     if x_key != &quot;fake-super-secret-key&quot;:         raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;)     return x_key  app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])  @app.get(&quot;/items/&quot;) async def read_items():     return [{&quot;item&quot;: &quot;Portal Gun&quot;}, {&quot;item&quot;: &quot;Plumbus&quot;}]  @app.get(&quot;/users/&quot;) async def read_users():     return [{&quot;username&quot;: &quot;Rick&quot;}, {&quot;username&quot;: &quot;Morty&quot;}]`

And all the ideas in the section about adding `dependencies` to the *path operation decorators* still apply, but in this case, to all of the *path operations* in the app.

### Dependencies for groups of *path operations*

Later, when reading about how to structure bigger applications (Bigger Applications - Multiple Files), possibly with multiple files, you will learn how to declare a single `dependencies` parameter for a group of *path operations*.




Before diving deeper into the **Dependency Injection** system, let's upgrade the previous example.

### A `dict` from the previous example

In the previous example, we were returning a `dict` from our dependency ("dependable"):

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

`from typing import Union  from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: dict = Depends(common_parameters)):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: dict = Depends(common_parameters)):     return commons`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: dict = Depends(common_parameters)):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: dict = Depends(common_parameters)):     return commons`

But then we get a `dict` in the parameter `commons` of the *path operation function*.

And we know that editors can't provide a lot of support (like completion) for `dict`s, because they can't know their keys and value types.

We can do better...

### What makes a dependency

Up to now you have seen dependencies declared as functions.

But that's not the only way to declare dependencies (although it would probably be the more common).

The key factor is that a dependency should be a "callable".

A "**callable**" in Python is anything that Python can "call" like a function.

So, if you have an object `something` (that might *not* be a function) and you can "call" it (execute it) like:

or

`something(some_argument, some_keyword_argument=&quot;foo&quot;)`

then it is a "callable".

### Classes as dependencies

You might notice that to create an instance of a Python class, you use that same syntax.

For example:

`class Cat:     def __init__(self, name: str):         self.name = name  fluffy = Cat(name=&quot;Mr Fluffy&quot;)`

In this case, `fluffy` is an instance of the class `Cat`.

And to create `fluffy`, you are "calling" `Cat`.

So, a Python class is also a **callable**.

Then, in **FastAPI**, you could use a Python class as a dependency.

What FastAPI actually checks is that it is a "callable" (function, class or anything else) and the parameters defined.

If you pass a "callable" as a dependency in **FastAPI**, it will analyze the parameters for that "callable", and process them in the same way as the parameters for a *path operation function*. Including sub-dependencies.

That also applies to callables with no parameters at all. The same as it would be for *path operation functions* with no parameters.

Then, we can change the dependency "dependable" `common_parameters` from above to the class `CommonQueryParams`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):        self.q = q        self.skip = skip        self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):        self.q = q        self.skip = skip        self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

`from typing import Union  from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):        self.q = q        self.skip = skip        self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):        self.q = q        self.skip = skip        self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):        self.q = q        self.skip = skip        self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

Pay attention to the `__init__` method used to create the instance of the class:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):        self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):        self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

`from typing import Union  from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):        self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):        self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):        self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

...it has the same parameters as our previous `common_parameters`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

`from typing import Union  from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[dict, Depends(common_parameters)]):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: Annotated[dict, Depends(common_parameters)]):     return commons`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: dict = Depends(common_parameters)):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: dict = Depends(common_parameters)):     return commons`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI  app = FastAPI()  async def common_parameters(     q: Union[str, None] = None, skip: int = 0, limit: int = 100 ):     return {&quot;q&quot;: q, &quot;skip&quot;: skip, &quot;limit&quot;: limit}  @app.get(&quot;/items/&quot;) async def read_items(commons: dict = Depends(common_parameters)):     return commons  @app.get(&quot;/users/&quot;) async def read_users(commons: dict = Depends(common_parameters)):     return commons`

Those parameters are what **FastAPI** will use to "solve" the dependency.

In both cases, it will have:

- An optional `q` query parameter that is a `str`.
- A `skip` query parameter that is an `int`, with a default of `0`.
- A `limit` query parameter that is an `int`, with a default of `100`.

In both cases the data will be converted, validated, documented on the OpenAPI schema, etc.

### Use it

Now you can declare your dependency using this class.

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

`from typing import Union  from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

**FastAPI** calls the `CommonQueryParams` class. This creates an "instance" of that class and the instance will be passed as the parameter `commons` to your function.

### Type annotation vs `Depends`

Notice how we write `CommonQueryParams` twice in the above code:

Python 3.6+ non-AnnotatedPython 3.6+

Tip

Prefer to use the `Annotated` version if possible.

`commons: CommonQueryParams = Depends(CommonQueryParams)`

`commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]`

The last `CommonQueryParams`, in:

`... Depends(CommonQueryParams)`

...is what **FastAPI** will actually use to know what is the dependency.

From it is that FastAPI will extract the declared parameters and that is what FastAPI will actually call.

***

In this case, the first `CommonQueryParams`, in:

Python 3.6+Python 3.6+ non-Annotated

`commons: Annotated[CommonQueryParams, ...`

Tip

Prefer to use the `Annotated` version if possible.

`commons: CommonQueryParams ...`

...doesn't have any special meaning for **FastAPI**. FastAPI won't use it for data conversion, validation, etc. (as it is using the `Depends(CommonQueryParams)` for that).

You could actually write just:

Python 3.6+Python 3.6+ non-Annotated

`commons: Annotated[Any, Depends(CommonQueryParams)]`

Tip

Prefer to use the `Annotated` version if possible.

`commons = Depends(CommonQueryParams)`

..as in:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated, Any  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[Any, Depends(CommonQueryParams)]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

`from typing import Annotated, Any, Union  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[Any, Depends(CommonQueryParams)]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

`from typing import Any, Union  from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[Any, Depends(CommonQueryParams)]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons=Depends(CommonQueryParams)):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons=Depends(CommonQueryParams)):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

But declaring the type is encouraged as that way your editor will know what will be passed as the parameter `commons`, and then it can help you with code completion, type checks, etc:

<image @ https://fastapi.tiangolo.com/img/tutorial/dependencies/image02.png>

### Shortcut

But you see that we are having some code repetition here, writing `CommonQueryParams` twice:

Python 3.6+ non-AnnotatedPython 3.6+

Tip

Prefer to use the `Annotated` version if possible.

`commons: CommonQueryParams = Depends(CommonQueryParams)`

`commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]`

**FastAPI** provides a shortcut for these cases, in where the dependency is *specifically* a class that **FastAPI** will "call" to create an instance of the class itself.

For those specific cases, you can do the following:

Instead of writing:

Python 3.6+Python 3.6+ non-Annotated

`commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]`

Tip

Prefer to use the `Annotated` version if possible.

`commons: CommonQueryParams = Depends(CommonQueryParams)`

...you write:

Python 3.6+Python 3.6 non-Annotated

`commons: Annotated[CommonQueryParams, Depends()]`

Tip

Prefer to use the `Annotated` version if possible.

`commons: CommonQueryParams = Depends()`

You declare the dependency as the type of the parameter, and you use `Depends()` without any parameter, instead of having to write the full class *again* inside of `Depends(CommonQueryParams)`.

The same example would then look like:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[CommonQueryParams, Depends()]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[CommonQueryParams, Depends()]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

`from typing import Union  from fastapi import Depends, FastAPI from typing_extensions import Annotated  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: Annotated[CommonQueryParams, Depends()]):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: CommonQueryParams = Depends()):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI  app = FastAPI()  fake_items_db = [{&quot;item_name&quot;: &quot;Foo&quot;}, {&quot;item_name&quot;: &quot;Bar&quot;}, {&quot;item_name&quot;: &quot;Baz&quot;}]  class CommonQueryParams:     def __init__(self, q: Union[str, None] = None, skip: int = 0, limit: int = 100):         self.q = q         self.skip = skip         self.limit = limit  @app.get(&quot;/items/&quot;) async def read_items(commons: CommonQueryParams = Depends()):     response = {}     if commons.q:         response.update({&quot;q&quot;: commons.q})     items = fake_items_db[commons.skip : commons.skip + commons.limit]     response.update({&quot;items&quot;: items})     return response`

...and **FastAPI** will know what to do.

Tip

If that seems more confusing than helpful, disregard it, you don't *need* it.

It is just a shortcut. Because **FastAPI** cares about helping you minimize code repetition.




FastAPI supports dependencies that do some extra steps after finishing.

To do this, use `yield` instead of `return`, and write the extra steps after.

Tip

Make sure to use `yield` one single time.

### A database dependency with `yield`

For example, you could use this to create a database session and close it after finishing.

Only the code prior to and including the `yield` statement is executed before sending a response:

`async def get_db():     db = DBSession()    try:        yield db    finally:         db.close()`

The yielded value is what is injected into *path operations* and other dependencies:

`async def get_db():     db = DBSession()     try:         yield db    finally:         db.close()`

The code following the `yield` statement is executed after the response has been delivered:

`async def get_db():     db = DBSession()     try:         yield db     finally:        db.close()`

Tip

You can use `async` or normal functions.

**FastAPI** will do the right thing with each, the same as with normal dependencies.

### A dependency with `yield` and `try`

If you use a `try` block in a dependency with `yield`, you'll receive any exception that was thrown when using the dependency.

For example, if some code at some point in the middle, in another dependency or in a *path operation*, made a database transaction "rollback" or create any other error, you will receive the exception in your dependency.

So, you can look for that specific exception inside the dependency with `except SomeException`.

In the same way, you can use `finally` to make sure the exit steps are executed, no matter if there was an exception or not.

`async def get_db():     db = DBSession()     try:        yield db     finally:        db.close()`

### Sub-dependencies with `yield`

You can have sub-dependencies and "trees" of sub-dependencies of any size and shape, and any or all of them can use `yield`.

**FastAPI** will make sure that the "exit code" in each dependency with `yield` is run in the correct order.

For example, `dependency_c` can have a dependency on `dependency_b`, and `dependency_b` on `dependency_a`:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends  async def dependency_a():     dep_a = generate_dep_a()     try:         yield dep_a     finally:         dep_a.close()  async def dependency_b(dep_a: Annotated[DepA, Depends(dependency_a)]):     dep_b = generate_dep_b()     try:         yield dep_b     finally:         dep_b.close(dep_a)  async def dependency_c(dep_b: Annotated[DepB, Depends(dependency_b)]):     dep_c = generate_dep_c()     try:         yield dep_c     finally:         dep_c.close(dep_b)`

`from fastapi import Depends from typing_extensions import Annotated  async def dependency_a():     dep_a = generate_dep_a()     try:         yield dep_a     finally:         dep_a.close()  async def dependency_b(dep_a: Annotated[DepA, Depends(dependency_a)]):     dep_b = generate_dep_b()     try:         yield dep_b     finally:         dep_b.close(dep_a)  async def dependency_c(dep_b: Annotated[DepB, Depends(dependency_b)]):     dep_c = generate_dep_c()     try:         yield dep_c     finally:         dep_c.close(dep_b)`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends  async def dependency_a():     dep_a = generate_dep_a()     try:         yield dep_a     finally:         dep_a.close()  async def dependency_b(dep_a=Depends(dependency_a)):     dep_b = generate_dep_b()     try:         yield dep_b     finally:         dep_b.close(dep_a)  async def dependency_c(dep_b=Depends(dependency_b)):     dep_c = generate_dep_c()     try:         yield dep_c     finally:         dep_c.close(dep_b)`

And all of them can use `yield`.

In this case `dependency_c`, to execute its exit code, needs the value from `dependency_b` (here named `dep_b`) to still be available.

And, in turn, `dependency_b` needs the value from `dependency_a` (here named `dep_a`) to be available for its exit code.

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends  async def dependency_a():     dep_a = generate_dep_a()     try:         yield dep_a     finally:         dep_a.close()  async def dependency_b(dep_a: Annotated[DepA, Depends(dependency_a)]):     dep_b = generate_dep_b()     try:         yield dep_b     finally:        dep_b.close(dep_a)  async def dependency_c(dep_b: Annotated[DepB, Depends(dependency_b)]):     dep_c = generate_dep_c()     try:         yield dep_c     finally:        dep_c.close(dep_b)`

`from fastapi import Depends from typing_extensions import Annotated  async def dependency_a():     dep_a = generate_dep_a()     try:         yield dep_a     finally:         dep_a.close()  async def dependency_b(dep_a: Annotated[DepA, Depends(dependency_a)]):     dep_b = generate_dep_b()     try:         yield dep_b     finally:        dep_b.close(dep_a)  async def dependency_c(dep_b: Annotated[DepB, Depends(dependency_b)]):     dep_c = generate_dep_c()     try:         yield dep_c     finally:        dep_c.close(dep_b)`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends  async def dependency_a():     dep_a = generate_dep_a()     try:         yield dep_a     finally:         dep_a.close()  async def dependency_b(dep_a=Depends(dependency_a)):     dep_b = generate_dep_b()     try:         yield dep_b     finally:        dep_b.close(dep_a)  async def dependency_c(dep_b=Depends(dependency_b)):     dep_c = generate_dep_c()     try:         yield dep_c     finally:        dep_c.close(dep_b)`

The same way, you could have dependencies with `yield` and `return` mixed.

And you could have a single dependency that requires several other dependencies with `yield`, etc.

You can have any combinations of dependencies that you want.

**FastAPI** will make sure everything is run in the correct order.

Technical Details

This works thanks to Python's Context Managers.

**FastAPI** uses them internally to achieve this.

### Dependencies with `yield` and `HTTPException`

You saw that you can use dependencies with `yield` and have `try` blocks that catch exceptions.

It might be tempting to raise an `HTTPException` or similar in the exit code, after the `yield`. But **it won't work**.

The exit code in dependencies with `yield` is executed *after* the response is sent, so Exception Handlers will have already run. There's nothing catching exceptions thrown by your dependencies in the exit code (after the `yield`).

So, if you raise an `HTTPException` after the `yield`, the default (or any custom) exception handler that catches `HTTPException`s and returns an HTTP 400 response won't be there to catch that exception anymore.

This is what allows anything set in the dependency (e.g. a DB session) to, for example, be used by background tasks.

Background tasks are run *after* the response has been sent. So there's no way to raise an `HTTPException` because there's not even a way to change the response that is *already sent*.

But if a background task creates a DB error, at least you can rollback or cleanly close the session in the dependency with `yield`, and maybe log the error or report it to a remote tracking system.

If you have some code that you know could raise an exception, do the most normal/"Pythonic" thing and add a `try` block in that section of the code.

If you have custom exceptions that you would like to handle *before* returning the response and possibly modifying the response, maybe even raising an `HTTPException`, create a Custom Exception Handler.

Tip

You can still raise exceptions including `HTTPException` *before* the `yield`. But not after.

The sequence of execution is more or less like this diagram. Time flows from top to bottom. And each column is one of the parts interacting or executing code.

```
sequenceDiagram

participant client as Client
participant handler as Exception handler
participant dep as Dep with yield
participant operation as Path Operation
participant tasks as Background tasks

    Note over client,tasks: Can raise exception for dependency, handled after response is sent
    Note over client,operation: Can raise HTTPException and can change the response
    client ->> dep: Start request
    Note over dep: Run code up to yield
    opt raise
        dep -->> handler: Raise HTTPException
        handler -->> client: HTTP error response
        dep -->> dep: Raise other exception
    end
    dep ->> operation: Run dependency, e.g. DB session
    opt raise
        operation -->> dep: Raise HTTPException
        dep -->> handler: Auto forward exception
        handler -->> client: HTTP error response
        operation -->> dep: Raise other exception
        dep -->> handler: Auto forward exception
    end
    operation ->> client: Return response to client
    Note over client,operation: Response is already sent, can't change it anymore
    opt Tasks
        operation -->> tasks: Send background tasks
    end
    opt Raise other exception
        tasks -->> dep: Raise other exception
    end
    Note over dep: After yield
    opt Handle other exception
        dep -->> dep: Handle exception, can't change response. E.g. close DB session.
    end
```

Info

Only **one response** will be sent to the client. It might be one of the error responses or it will be the response from the *path operation*.

After one of those responses is sent, no other response can be sent.

Tip

This diagram shows `HTTPException`, but you could also raise any other exception for which you create a Custom Exception Handler.

If you raise any exception, it will be passed to the dependencies with yield, including `HTTPException`, and then **again** to the exception handlers. If there's no exception handler for that exception, it will then be handled by the default internal `ServerErrorMiddleware`, returning a 500 HTTP status code, to let the client know that there was an error in the server.

### Context Managers

#### What are "Context Managers"

"Context Managers" are any of those Python objects that you can use in a `with` statement.

For example, you can use `with` to read a file:

`with open(&quot;./somefile.txt&quot;) as f:     contents = f.read()     print(contents)`

Underneath, the `open(&quot;./somefile.txt&quot;)` creates an object that is a called a "Context Manager".

When the `with` block finishes, it makes sure to close the file, even if there were exceptions.

When you create a dependency with `yield`, **FastAPI** will internally convert it to a context manager, and combine it with some other related tools.

#### Using context managers in dependencies with `yield`

Warning

This is, more or less, an "advanced" idea.

If you are just starting with **FastAPI** you might want to skip it for now.

In Python, you can create Context Managers by creating a class with two methods: `__enter__()` and `__exit__()`.

You can also use them inside of **FastAPI** dependencies with `yield` by using `with` or `async with` statements inside of the dependency function:

`class MySuperContextManager:     def __init__(self):        self.db = DBSession()     def __enter__(self):        return self.db     def __exit__(self, exc_type, exc_value, traceback):        self.db.close()  async def get_db():     with MySuperContextManager() as db:        yield db`

Tip

Another way to create a context manager is with:

- `@contextlib.contextmanager` or
- `@contextlib.asynccontextmanager`

using them to decorate a function with a single `yield`.

That's what **FastAPI** uses internally for dependencies with `yield`.

But you don't have to use the decorators for FastAPI dependencies (and you shouldn't).

FastAPI will do it for you internally.




Let's imagine that you have your **backend** API in some domain.

And you have a **frontend** in another domain or in a different path of the same domain (or in a mobile application).

And you want to have a way for the frontend to authenticate with the backend, using a **username** and **password**.

We can use **OAuth2** to build that with **FastAPI**.

But let's save you the time of reading the full long specification just to find those little pieces of information you need.

Let's use the tools provided by **FastAPI** to handle security.

### How it looks

Let's first just use the code and see how it works, and then we'll come back to understand what's happening.

### Create `main.py`

Copy the example in a file `main.py`:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  @app.get(&quot;/items/&quot;) async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):     return {&quot;token&quot;: token}`

`from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from typing_extensions import Annotated  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  @app.get(&quot;/items/&quot;) async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):     return {&quot;token&quot;: token}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  @app.get(&quot;/items/&quot;) async def read_items(token: str = Depends(oauth2_scheme)):     return {&quot;token&quot;: token}`

### Run it

Info

First install `python-multipart`.

E.g. `pip install python-multipart`.

This is because **OAuth2** uses "form data" for sending the `username` and `password`.

Run the example with:

`$ uvicorn main:app --reload  &lt;span style=&quot;color: green;&quot;&gt;INFO&lt;/span&gt;:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)`

### Check it

Go to the interactive docs at: http://127.0.0.1:8000/docs.

You will see something like this:

<image @ https://fastapi.tiangolo.com/img/tutorial/security/image01.png>

Authorize button!

You already have a shiny new "Authorize" button.

And your *path operation* has a little lock in the top-right corner that you can click.

And if you click it, you have a little authorization form to type a `username` and `password` (and other optional fields):

<image @ https://fastapi.tiangolo.com/img/tutorial/security/image02.png>

Note

It doesn't matter what you type in the form, it won't work yet. But we'll get there.

This is of course not the frontend for the final users, but it's a great automatic tool to document interactively all your API.

It can be used by the frontend team (that can also be yourself).

It can be used by third party applications and systems.

And it can also be used by yourself, to debug, check and test the same application.

### The `password` flow

Now let's go back a bit and understand what is all that.

The `password` "flow" is one of the ways ("flows") defined in OAuth2, to handle security and authentication.

OAuth2 was designed so that the backend or API could be independent of the server that authenticates the user.

But in this case, the same **FastAPI** application will handle the API and the authentication.

So, let's review it from that simplified point of view:

- The user types the `username` and `password` in the frontend, and hits `Enter`.
- The frontend (running in the user's browser) sends that `username` and `password` to a specific URL in our API (declared with `tokenUrl=&quot;token&quot;`).
- The API checks that `username` and `password`, and responds with a "token" (we haven't implemented any of this yet).
  - A "token" is just a string with some content that we can use later to verify this user.
  - Normally, a token is set to expire after some time.
    - So, the user will have to log in again at some point later.
    - And if the token is stolen, the risk is less. It is not like a permanent key that will work forever (in most of the cases).
- The frontend stores that token temporarily somewhere.
- The user clicks in the frontend to go to another section of the frontend web app.
- The frontend needs to fetch some more data from the API.
  - But it needs authentication for that specific endpoint.
  - So, to authenticate with our API, it sends a header `Authorization` with a value of `Bearer` plus the token.
  - If the token contains `foobar`, the content of the `Authorization` header would be: `Bearer foobar`.

### **FastAPI**'s `OAuth2PasswordBearer`

**FastAPI** provides several tools, at different levels of abstraction, to implement these security features.

In this example we are going to use **OAuth2**, with the **Password** flow, using a **Bearer** token. We do that using the `OAuth2PasswordBearer` class.

Info

A "bearer" token is not the only option.

But it's the best one for our use case.

And it might be the best for most use cases, unless you are an OAuth2 expert and know exactly why there's another option that suits better your needs.

In that case, **FastAPI** also provides you with the tools to build it.

When we create an instance of the `OAuth2PasswordBearer` class we pass in the `tokenUrl` parameter. This parameter contains the URL that the client (the frontend running in the user's browser) will use to send the `username` and `password` in order to get a token.

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  @app.get(&quot;/items/&quot;) async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):     return {&quot;token&quot;: token}`

`from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from typing_extensions import Annotated  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  @app.get(&quot;/items/&quot;) async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):     return {&quot;token&quot;: token}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  @app.get(&quot;/items/&quot;) async def read_items(token: str = Depends(oauth2_scheme)):     return {&quot;token&quot;: token}`

Tip

Here `tokenUrl=&quot;token&quot;` refers to a relative URL `token` that we haven't created yet. As it's a relative URL, it's equivalent to `./token`.

Because we are using a relative URL, if your API was located at `https://example.com/`, then it would refer to `https://example.com/token`. But if your API was located at `https://example.com/api/v1/`, then it would refer to `https://example.com/api/v1/token`.

Using a relative URL is important to make sure your application keeps working even in an advanced use case like Behind a Proxy.

This parameter doesn't create that endpoint / *path operation*, but declares that the URL `/token` will be the one that the client should use to get the token. That information is used in OpenAPI, and then in the interactive API documentation systems.

We will soon also create the actual path operation.

Info

If you are a very strict "Pythonista" you might dislike the style of the parameter name `tokenUrl` instead of `token_url`.

That's because it is using the same name as in the OpenAPI spec. So that if you need to investigate more about any of these security schemes you can just copy and paste it to find more information about it.

The `oauth2_scheme` variable is an instance of `OAuth2PasswordBearer`, but it is also a "callable".

It could be called as:

`oauth2_scheme(some, parameters)`

So, it can be used with `Depends`.

#### Use it

Now you can pass that `oauth2_scheme` in a dependency with `Depends`.

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  @app.get(&quot;/items/&quot;) async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):     return {&quot;token&quot;: token}`

`from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from typing_extensions import Annotated  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  @app.get(&quot;/items/&quot;) async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):     return {&quot;token&quot;: token}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  @app.get(&quot;/items/&quot;) async def read_items(token: str = Depends(oauth2_scheme)):     return {&quot;token&quot;: token}`

This dependency will provide a `str` that is assigned to the parameter `token` of the *path operation function*.

**FastAPI** will know that it can use this dependency to define a "security scheme" in the OpenAPI schema (and the automatic API docs).

Technical Details

**FastAPI** will know that it can use the class `OAuth2PasswordBearer` (declared in a dependency) to define the security scheme in OpenAPI because it inherits from `fastapi.security.oauth2.OAuth2`, which in turn inherits from `fastapi.security.base.SecurityBase`.

All the security utilities that integrate with OpenAPI (and the automatic API docs) inherit from `SecurityBase`, that's how **FastAPI** can know how to integrate them in OpenAPI.

### What it does

It will go and look in the request for that `Authorization` header, check if the value is `Bearer` plus some token, and will return the token as a `str`.

If it doesn't see an `Authorization` header, or the value doesn't have a `Bearer` token, it will respond with a 401 status code error (`UNAUTHORIZED`) directly.

You don't even have to check if the token exists to return an error. You can be sure that if your function is executed, it will have a `str` in that token.

You can try it already in the interactive docs:

<image @ https://fastapi.tiangolo.com/img/tutorial/security/image03.png>

We are not verifying the validity of the token yet, but that's a start already.

### Recap

So, in just 3 or 4 extra lines, you already have some primitive form of security.




In the previous chapter the security system (which is based on the dependency injection system) was giving the *path operation function* a `token` as a `str`:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  @app.get(&quot;/items/&quot;) async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):     return {&quot;token&quot;: token}`

`from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from typing_extensions import Annotated  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  @app.get(&quot;/items/&quot;) async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):     return {&quot;token&quot;: token}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  @app.get(&quot;/items/&quot;) async def read_items(token: str = Depends(oauth2_scheme)):     return {&quot;token&quot;: token}`

But that is still not that useful.

Let's make it give us the current user.

### Create a user model

First, let's create a Pydantic user model.

The same way we use Pydantic to declare bodies, we can use it anywhere else:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str    email: str | None = None    full_name: str | None = None    disabled: bool | None = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str    email: Union[str, None] = None    full_name: Union[str, None] = None    disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

`from typing import Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel from typing_extensions import Annotated  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str    email: Union[str, None] = None    full_name: Union[str, None] = None    disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str    email: str | None = None    full_name: str | None = None    disabled: bool | None = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_user)):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str    email: Union[str, None] = None    full_name: Union[str, None] = None    disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_user)):     return current_user`

### Create a `get_current_user` dependency

Let's create a dependency `get_current_user`.

Remember that dependencies can have sub-dependencies?

`get_current_user` will have a dependency with the same `oauth2_scheme` we created before.

The same as we were doing before in the *path operation* directly, our new dependency `get_current_user` will receive a `token` as a `str` from the sub-dependency `oauth2_scheme`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

`from typing import Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel from typing_extensions import Annotated  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_user)):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_user)):     return current_user`

### Get the user

`get_current_user` will use a (fake) utility function we created, that takes a token as a `str` and returns our Pydantic `User` model:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  def fake_decode_token(token):     return User(        username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;    )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)    return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(        username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;    )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)    return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

`from typing import Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel from typing_extensions import Annotated  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(        username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;    )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)    return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  def fake_decode_token(token):     return User(        username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;    )  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)    return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_user)):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(        username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;    )  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)    return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_user)):     return current_user`

### Inject the current user

So now we can use the same `Depends` with our `get_current_user` in the *path operation*:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

`from typing import Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel from typing_extensions import Annotated  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_user)):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_user)):     return current_user`

Notice that we declare the type of `current_user` as the Pydantic model `User`.

This will help us inside of the function with all the completion and type checks.

Tip

You might remember that request bodies are also declared with Pydantic models.

Here **FastAPI** won't get confused because you are using `Depends`.

Check

The way this dependency system is designed allows us to have different dependencies (different "dependables") that all return a `User` model.

We are not restricted to having only one dependency that can return that type of data.

### Other models

You can now get the current user directly in the *path operation functions* and deal with the security mechanisms at the **Dependency Injection** level, using `Depends`.

And you can use any model or data for the security requirements (in this case, a Pydantic model `User`).

But you are not restricted to using some specific data model, class or type.

Do you want to have an `id` and `email` and not have any `username` in your model? Sure. You can use these same tools.

Do you want to just have a `str`? Or just a `dict`? Or a database class model instance directly? It all works the same way.

You actually don't have users that log in to your application but robots, bots, or other systems, that have just an access token? Again, it all works the same.

Just use any kind of model, any kind of class, any kind of database that you need for your application. **FastAPI** has you covered with the dependency injection system.

### Code size

This example might seem verbose. Have in mind that we are mixing security, data models, utility functions and *path operations* in the same file.

But here's the key point.

The security and dependency injection stuff is written once.

And you can make it as complex as you want. And still, have it written only once, in a single place. With all the flexibility.

But you can have thousands of endpoints (*path operations*) using the same security system.

And all of them (or any portion of them that you want) can take the advantage of re-using these dependencies or any other dependencies you create.

And all these thousands of *path operations* can be as small as 3 lines:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

`from typing import Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel from typing_extensions import Annotated  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_user)):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel  app = FastAPI()  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  def fake_decode_token(token):     return User(         username=token + &quot;fakedecoded&quot;, email=&quot;john@example.com&quot;, full_name=&quot;John Doe&quot;     )  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     return user  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_user)):     return current_user`

### Recap

You can now get the current user directly in your *path operation function*.

We are already halfway there.

We just need to add a *path operation* for the user/client to actually send the `username` and `password`.

That comes next.




Now let's build from the previous chapter and add the missing parts to have a complete security flow.

### Get the `username` and `password`

We are going to use **FastAPI** security utilities to get the `username` and `password`.

OAuth2 specifies that when using the "password flow" (that we are using) the client/user must send a `username` and `password` fields as form data.

And the spec says that the fields have to be named like that. So `user-name` or `email` wouldn't work.

But don't worry, you can show it as you wish to your final users in the frontend.

And your database models can use any other names you want.

But for the login *path operation*, we need to use these names to be compatible with the spec (and be able to, for example, use the integrated API documentation system).

The spec also states that the `username` and `password` must be sent as form data (so, no JSON here).

#### `scope`

The spec also says that the client can send another form field "`scope`".

The form field name is `scope` (in singular), but it is actually a long string with "scopes" separated by spaces.

Each "scope" is just a string (without spaces).

They are normally used to declare specific security permissions, for example:

- `users:read` or `users:write` are common examples.
- `instagram_basic` is used by Facebook / Instagram.
- `https://www.googleapis.com/auth/drive` is used by Google.

Info

In OAuth2 a "scope" is just a string that declares a specific permission required.

It doesn't matter if it has other characters like `:` or if it is a URL.

Those details are implementation specific.

For OAuth2 they are just strings.

### Code to get the `username` and `password`

Now let's use the utilities provided by **FastAPI** to handle this.

#### `OAuth2PasswordRequestForm`

First, import `OAuth2PasswordRequestForm`, and use it as a dependency with `Depends` in the *path operation* for `/token`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

`from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel from typing_extensions import Annotated  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: OAuth2PasswordRequestForm = Depends()):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: OAuth2PasswordRequestForm = Depends()):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user`

`OAuth2PasswordRequestForm` is a class dependency that declares a form body with:

- The `username`.
- The `password`.
- An optional `scope` field as a big string, composed of strings separated by spaces.
- An optional `grant_type`.

Tip

The OAuth2 spec actually *requires* a field `grant_type` with a fixed value of `password`, but `OAuth2PasswordRequestForm` doesn't enforce it.

If you need to enforce it, use `OAuth2PasswordRequestFormStrict` instead of `OAuth2PasswordRequestForm`.

- An optional `client_id` (we don't need it for our example).
- An optional `client_secret` (we don't need it for our example).

Info

The `OAuth2PasswordRequestForm` is not a special class for **FastAPI** as is `OAuth2PasswordBearer`.

`OAuth2PasswordBearer` makes **FastAPI** know that it is a security scheme. So it is added that way to OpenAPI.

But `OAuth2PasswordRequestForm` is just a class dependency that you could have written yourself, or you could have declared `Form` parameters directly.

But as it's a common use case, it is provided by **FastAPI** directly, just to make it easier.

#### Use the form data

Tip

The instance of the dependency class `OAuth2PasswordRequestForm` won't have an attribute `scope` with the long string separated by spaces, instead, it will have a `scopes` attribute with the actual list of strings for each scope sent.

We are not using `scopes` in this example, but the functionality is there if you need it.

Now, get the user data from the (fake) database, using the `username` from the form field.

If there is no such user, we return an error saying "incorrect username or password".

For the error, we use the exception `HTTPException`:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)    if not user_dict:        raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)    user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)    if not user_dict:        raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)    user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

`from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel from typing_extensions import Annotated  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)    if not user_dict:        raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)    user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: OAuth2PasswordRequestForm = Depends()):     user_dict = fake_users_db.get(form_data.username)    if not user_dict:        raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)    user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: OAuth2PasswordRequestForm = Depends()):     user_dict = fake_users_db.get(form_data.username)    if not user_dict:        raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)    user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user`

#### Check the password

At this point we have the user data from our database, but we haven't checked the password.

Let's put that data in the Pydantic `UserInDB` model first.

You should never save plaintext passwords, so, we'll use the (fake) password hashing system.

If the passwords don't match, we return the same error.

##### Password hashing

"Hashing" means: converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish.

Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish.

But you cannot convert from the gibberish back to the password.

###### Why use password hashing

If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes.

So, the thief won't be able to try to use those same passwords in another system (as many users use the same password everywhere, this would be dangerous).

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)    hashed_password = fake_hash_password(form_data.password)    if not hashed_password == user.hashed_password:        raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)    hashed_password = fake_hash_password(form_data.password)    if not hashed_password == user.hashed_password:        raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

`from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel from typing_extensions import Annotated  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)    hashed_password = fake_hash_password(form_data.password)    if not hashed_password == user.hashed_password:        raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: OAuth2PasswordRequestForm = Depends()):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)    hashed_password = fake_hash_password(form_data.password)    if not hashed_password == user.hashed_password:        raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: OAuth2PasswordRequestForm = Depends()):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)    hashed_password = fake_hash_password(form_data.password)    if not hashed_password == user.hashed_password:        raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user`

##### About `**user_dict`

`UserInDB(**user_dict)` means:

*Pass the keys and values of the `user_dict` directly as key-value arguments, equivalent to:*

`UserInDB(     username = user_dict[&quot;username&quot;],     email = user_dict[&quot;email&quot;],     full_name = user_dict[&quot;full_name&quot;],     disabled = user_dict[&quot;disabled&quot;],     hashed_password = user_dict[&quot;hashed_password&quot;], )`

### Return the token

The response of the `token` endpoint must be a JSON object.

It should have a `token_type`. In our case, as we are using "Bearer" tokens, the token type should be "`bearer`".

And it should have an `access_token`, with a string containing our access token.

For this simple example, we are going to just be completely insecure and return the same `username` as the token.

Tip

In the next chapter, you will see a real secure implementation, with password hashing and JWT tokens.

But for now, let's focus on the specific details we need.

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

`from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel from typing_extensions import Annotated  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: OAuth2PasswordRequestForm = Depends()):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Invalid authentication credentials&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;) async def login(form_data: OAuth2PasswordRequestForm = Depends()):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user`

Tip

By the spec, you should return a JSON with an `access_token` and a `token_type`, the same as in this example.

This is something that you have to do yourself in your code, and make sure you use those JSON keys.

It's almost the only thing that you have to remember to do correctly yourself, to be compliant with the specifications.

For the rest, **FastAPI** handles it for you.

### Update the dependencies

Now we are going to update our dependencies.

We want to get the `current_user` *only* if this user is active.

So, we create an additional dependency `get_current_active_user` that in turn uses `get_current_user` as a dependency.

Both of these dependencies will just return an HTTP error if the user doesn't exist, or if is inactive.

So, in our endpoint, we will only get a user if the user exists, was correctly authenticated, and is active:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)    if not user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail=&quot;Invalid authentication credentials&quot;,            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},        )    return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:        raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)    return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

`from typing import Annotated, Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)    if not user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail=&quot;Invalid authentication credentials&quot;,            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},        )    return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:        raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)    return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

`from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel from typing_extensions import Annotated  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     user = fake_decode_token(token)    if not user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail=&quot;Invalid authentication credentials&quot;,            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},        )    return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:        raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)    return current_user  @app.post(&quot;/token&quot;) async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)    if not user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail=&quot;Invalid authentication credentials&quot;,            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},        )    return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:        raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)    return current_user  @app.post(&quot;/token&quot;) async def login(form_data: OAuth2PasswordRequestForm = Depends()):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user`

Tip

Prefer to use the `Annotated` version if possible.

`from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Wonderson&quot;,         &quot;email&quot;: &quot;alice@example.com&quot;,         &quot;hashed_password&quot;: &quot;fakehashedsecret2&quot;,         &quot;disabled&quot;: True,     }, }  app = FastAPI()  def fake_hash_password(password: str):     return &quot;fakehashed&quot; + password  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def fake_decode_token(token):     # This doesn't provide any security at all     # Check the next version     user = get_user(fake_users_db, token)     return user  async def get_current_user(token: str = Depends(oauth2_scheme)):     user = fake_decode_token(token)    if not user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail=&quot;Invalid authentication credentials&quot;,            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},        )    return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:        raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)    return current_user  @app.post(&quot;/token&quot;) async def login(form_data: OAuth2PasswordRequestForm = Depends()):     user_dict = fake_users_db.get(form_data.username)     if not user_dict:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     user = UserInDB(**user_dict)     hashed_password = fake_hash_password(form_data.password)     if not hashed_password == user.hashed_password:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)      return {&quot;access_token&quot;: user.username, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me&quot;) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user`

Info

The additional header `WWW-Authenticate` with value `Bearer` we are returning here is also part of the spec.

Any HTTP (error) status code 401 "UNAUTHORIZED" is supposed to also return a `WWW-Authenticate` header.

In the case of bearer tokens (our case), the value of that header should be `Bearer`.

You can actually skip that extra header and it would still work.

But it's provided here to be compliant with the specifications.

Also, there might be tools that expect and use it (now or in the future) and that might be useful for you or your users, now or in the future.

That's the benefit of standards...

### See it in action

Open the interactive docs: http://127.0.0.1:8000/docs.

#### Authenticate

Click the "Authorize" button.

Use the credentials:

User: `johndoe`

Password: `secret`

<image @ https://fastapi.tiangolo.com/img/tutorial/security/image04.png>

After authenticating in the system, you will see it like:

<image @ https://fastapi.tiangolo.com/img/tutorial/security/image05.png>

#### Get your own user data

Now use the operation `GET` with the path `/users/me`.

You will get your user's data, like:

`{   &quot;username&quot;: &quot;johndoe&quot;,   &quot;email&quot;: &quot;johndoe@example.com&quot;,   &quot;full_name&quot;: &quot;John Doe&quot;,   &quot;disabled&quot;: false,   &quot;hashed_password&quot;: &quot;fakehashedsecret&quot; }`

<image @ https://fastapi.tiangolo.com/img/tutorial/security/image06.png>

If you click the lock icon and logout, and then try the same operation again, you will get an HTTP 401 error of:

`{   &quot;detail&quot;: &quot;Not authenticated&quot; }`

#### Inactive user

Now try with an inactive user, authenticate with:

User: `alice`

Password: `secret2`

And try to use the operation `GET` with the path `/users/me`.

You will get an "inactive user" error, like:

`{   &quot;detail&quot;: &quot;Inactive user&quot; }`

### Recap

You now have the tools to implement a complete security system based on `username` and `password` for your API.

Using these tools, you can make the security system compatible with any database and with any user or data model.

The only detail missing is that it is not actually "secure" yet.

In the next chapter you'll see how to use a secure password hashing library and JWT tokens.




Now that we have all the security flow, let's make the application actually secure, using JWT tokens and secure password hashing.

This code is something you can actually use in your application, save the password hashes in your database, etc.

We are going to start from where we left in the previous chapter and increment it.

### About JWT

JWT means "JSON Web Tokens".

It's a standard to codify a JSON object in a long dense string without spaces. It looks like this:

`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`

It is not encrypted, so, anyone could recover the information from the contents.

But it's signed. So, when you receive a token that you emitted, you can verify that you actually emitted it.

That way, you can create a token with an expiration of, let's say, 1 week. And then when the user comes back the next day with the token, you know that user is still logged in to your system.

After a week, the token will be expired and the user will not be authorized and will have to sign in again to get a new token. And if the user (or a third party) tried to modify the token to change the expiration, you would be able to discover it, because the signatures would not match.

If you want to play with JWT tokens and see how they work, check https://jwt.io.

### Install `python-jose`

We need to install `python-jose` to generate and verify the JWT tokens in Python:

`$ pip install &quot;python-jose[cryptography]&quot;  ---&gt; 100%`

Python-jose requires a cryptographic backend as an extra.

Here we are using the recommended one: pyca/cryptography.

Tip

This tutorial previously used PyJWT.

But it was updated to use Python-jose instead as it provides all the features from PyJWT plus some extras that you might need later when building integrations with other tools.

### Password hashing

"Hashing" means converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish.

Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish.

But you cannot convert from the gibberish back to the password.

#### Why use password hashing

If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes.

So, the thief won't be able to try to use that password in another system (as many users use the same password everywhere, this would be dangerous).

### Install `passlib`

PassLib is a great Python package to handle password hashes.

It supports many secure hashing algorithms and utilities to work with them.

The recommended algorithm is "Bcrypt".

So, install PassLib with Bcrypt:

`$ pip install &quot;passlib[bcrypt]&quot;  ---&gt; 100%`

Tip

With `passlib`, you could even configure it to be able to read passwords created by **Django**, a **Flask** security plug-in or many others.

So, you would be able to, for example, share the same data from a Django application in a database with a FastAPI application. Or gradually migrate a Django application using the same database.

And your users would be able to login from your Django app or from your **FastAPI** app, at the same time.

### Hash and verify the passwords

Import the tools we need from `passlib`.

Create a PassLib "context". This is what will be used to hash and verify passwords.

Tip

The PassLib context also has functionality to use different hashing algorithms, including deprecated old ones only to allow verifying them, etc.

For example, you could use it to read and verify passwords generated by another system (like Django) but hash any new passwords with a different algorithm like Bcrypt.

And be compatible with all of them at the same time.

Create a utility function to hash a password coming from the user.

And another utility to verify if a received password matches the hash stored.

And another one to authenticate and return a user.

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, timedelta from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;) oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)    if not user:        return False    if not verify_password(password, user.hashed_password):        return False    return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

`from datetime import datetime, timedelta from typing import Annotated, Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;) oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)    if not user:        return False    if not verify_password(password, user.hashed_password):        return False    return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel from typing_extensions import Annotated  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;) oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)    if not user:        return False    if not verify_password(password, user.hashed_password):        return False    return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;) oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)    if not user:        return False    if not verify_password(password, user.hashed_password):        return False    return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: str = Depends(oauth2_scheme)):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(current_user: User = Depends(get_current_active_user)):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;) oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)    if not user:        return False    if not verify_password(password, user.hashed_password):        return False    return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: str = Depends(oauth2_scheme)):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(current_user: User = Depends(get_current_active_user)):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

Note

If you check the new (fake) database `fake_users_db`, you will see how the hashed password looks like now: `&quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;`.

### Handle JWT tokens

Import the modules installed.

Create a random secret key that will be used to sign the JWT tokens.

To generate a secure random secret key use the command:

`$ openssl rand -hex 32  09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7`

And copy the output to the variable `SECRET_KEY` (don't use the one in the example).

Create a variable `ALGORITHM` with the algorithm used to sign the JWT token and set it to `&quot;HS256&quot;`.

Create a variable for the expiration of the token.

Define a Pydantic Model that will be used in the token endpoint for the response.

Create a utility function to generate a new access token.

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, timedelta from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str    token_type: str  class TokenData(BaseModel):     username: str | None = None  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()    if expires_delta:        expire = datetime.utcnow() + expires_delta    else:        expire = datetime.utcnow() + timedelta(minutes=15)    to_encode.update({&quot;exp&quot;: expire})    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)    return encoded_jwt  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

`from datetime import datetime, timedelta from typing import Annotated, Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str    token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()    if expires_delta:        expire = datetime.utcnow() + expires_delta    else:        expire = datetime.utcnow() + timedelta(minutes=15)    to_encode.update({&quot;exp&quot;: expire})    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)    return encoded_jwt  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel from typing_extensions import Annotated  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str    token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()    if expires_delta:        expire = datetime.utcnow() + expires_delta    else:        expire = datetime.utcnow() + timedelta(minutes=15)    to_encode.update({&quot;exp&quot;: expire})    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)    return encoded_jwt  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str    token_type: str  class TokenData(BaseModel):     username: str | None = None  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()    if expires_delta:        expire = datetime.utcnow() + expires_delta    else:        expire = datetime.utcnow() + timedelta(minutes=15)    to_encode.update({&quot;exp&quot;: expire})    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)    return encoded_jwt  async def get_current_user(token: str = Depends(oauth2_scheme)):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(current_user: User = Depends(get_current_active_user)):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str    token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()    if expires_delta:        expire = datetime.utcnow() + expires_delta    else:        expire = datetime.utcnow() + timedelta(minutes=15)    to_encode.update({&quot;exp&quot;: expire})    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)    return encoded_jwt  async def get_current_user(token: str = Depends(oauth2_scheme)):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(current_user: User = Depends(get_current_active_user)):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

### Update the dependencies

Update `get_current_user` to receive the same token as before, but this time, using JWT tokens.

Decode the received token, verify it, and return the current user.

If the token is invalid, return an HTTP error right away.

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, timedelta from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},    )    try:        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])        username: str = payload.get(&quot;sub&quot;)        if username is None:            raise credentials_exception        token_data = TokenData(username=username)    except JWTError:        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)    if user is None:        raise credentials_exception    return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

`from datetime import datetime, timedelta from typing import Annotated, Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},    )    try:        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])        username: str = payload.get(&quot;sub&quot;)        if username is None:            raise credentials_exception        token_data = TokenData(username=username)    except JWTError:        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)    if user is None:        raise credentials_exception    return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel from typing_extensions import Annotated  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},    )    try:        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])        username: str = payload.get(&quot;sub&quot;)        if username is None:            raise credentials_exception        token_data = TokenData(username=username)    except JWTError:        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)    if user is None:        raise credentials_exception    return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: str = Depends(oauth2_scheme)):     credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},    )    try:        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])        username: str = payload.get(&quot;sub&quot;)        if username is None:            raise credentials_exception        token_data = TokenData(username=username)    except JWTError:        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)    if user is None:        raise credentials_exception    return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(current_user: User = Depends(get_current_active_user)):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: str = Depends(oauth2_scheme)):     credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},    )    try:        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])        username: str = payload.get(&quot;sub&quot;)        if username is None:            raise credentials_exception        token_data = TokenData(username=username)    except JWTError:        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)    if user is None:        raise credentials_exception    return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect username or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},         )     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(current_user: User = Depends(get_current_active_user)):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

### Update the `/token` *path operation*

Create a `timedelta` with the expiration time of the token.

Create a real JWT access token and return it

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, timedelta from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)    if not user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail=&quot;Incorrect username or password&quot;,            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},        )    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)    access_token = create_access_token(        data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires    )    return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

`from datetime import datetime, timedelta from typing import Annotated, Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)    if not user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail=&quot;Incorrect username or password&quot;,            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},        )    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)    access_token = create_access_token(        data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires    )    return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel from typing_extensions import Annotated  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(     current_user: Annotated[User, Depends(get_current_user)] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)    if not user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail=&quot;Incorrect username or password&quot;,            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},        )    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)    access_token = create_access_token(        data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires    )    return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: str = Depends(oauth2_scheme)):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)    if not user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail=&quot;Incorrect username or password&quot;,            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},        )    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)    access_token = create_access_token(        data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires    )    return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(current_user: User = Depends(get_current_active_user)):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     } }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(tokenUrl=&quot;token&quot;)  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(token: str = Depends(oauth2_scheme)):     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_data = TokenData(username=username)     except JWTError:         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     return user  async def get_current_active_user(current_user: User = Depends(get_current_user)):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)    if not user:        raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail=&quot;Incorrect username or password&quot;,            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},        )    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)    access_token = create_access_token(        data={&quot;sub&quot;: user.username}, expires_delta=access_token_expires    )    return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(current_user: User = Depends(get_current_active_user)):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]`

#### Technical details about the JWT "subject" `sub`

The JWT specification says that there's a key `sub`, with the subject of the token.

It's optional to use it, but that's where you would put the user's identification, so we are using it here.

JWT might be used for other things apart from identifying a user and allowing them to perform operations directly on your API.

For example, you could identify a "car" or a "blog post".

Then you could add permissions about that entity, like "drive" (for the car) or "edit" (for the blog).

And then, you could give that JWT token to a user (or bot), and they could use it to perform those actions (drive the car, or edit the blog post) without even needing to have an account, just with the JWT token your API generated for that.

Using these ideas, JWT can be used for way more sophisticated scenarios.

In those cases, several of those entities could have the same ID, let's say `foo` (a user `foo`, a car `foo`, and a blog post `foo`).

So, to avoid ID collisions, when creating the JWT token for the user, you could prefix the value of the `sub` key, e.g. with `username:`. So, in this example, the value of `sub` could have been: `username:johndoe`.

The important thing to have in mind is that the `sub` key should have a unique identifier across the entire application, and it should be a string.

### Check it

Run the server and go to the docs: http://127.0.0.1:8000/docs.

You'll see the user interface like:

<image @ https://fastapi.tiangolo.com/img/tutorial/security/image07.png>

Authorize the application the same way as before.

Using the credentials:

Username: `johndoe` Password: `secret`

Check

Notice that nowhere in the code is the plaintext password "`secret`", we only have the hashed version.

<image @ https://fastapi.tiangolo.com/img/tutorial/security/image08.png>

Call the endpoint `/users/me/`, you will get the response as:

`{   &quot;username&quot;: &quot;johndoe&quot;,   &quot;email&quot;: &quot;johndoe@example.com&quot;,   &quot;full_name&quot;: &quot;John Doe&quot;,   &quot;disabled&quot;: false }`

<image @ https://fastapi.tiangolo.com/img/tutorial/security/image09.png>

If you open the developer tools, you could see how the data sent only includes the token, the password is only sent in the first request to authenticate the user and get that access token, but not afterwards:

<image @ https://fastapi.tiangolo.com/img/tutorial/security/image10.png>

Note

Notice the header `Authorization`, with a value that starts with `Bearer`.

### Advanced usage with `scopes`

OAuth2 has the notion of "scopes".

You can use them to add a specific set of permissions to a JWT token.

Then you can give this token to a user directly or a third party, to interact with your API with a set of restrictions.

You can learn how to use them and how they are integrated into **FastAPI** later in the **Advanced User Guide**.

### Recap

With what you have seen up to now, you can set up a secure **FastAPI** application using standards like OAuth2 and JWT.

In almost any framework handling the security becomes a rather complex subject quite quickly.

Many packages that simplify it a lot have to make many compromises with the data model, database, and available features. And some of these packages that simplify things too much actually have security flaws underneath.

***

**FastAPI** doesn't make any compromise with any database, data model or tool.

It gives you all the flexibility to choose the ones that fit your project the best.

And you can use directly many well maintained and widely used packages like `passlib` and `python-jose`, because **FastAPI** doesn't require any complex mechanisms to integrate external packages.

But it provides you the tools to simplify the process as much as possible without compromising flexibility, robustness, or security.

And you can use and implement secure, standard protocols, like OAuth2 in a relatively simple way.

You can learn more in the **Advanced User Guide** about how to use OAuth2 "scopes", for a more fine-grained permission system, following these same standards. OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, Twitter, etc. to authorize third party applications to interact with their APIs on behalf of their users.




For the simplest cases, you can use HTTP Basic Auth.

In HTTP Basic Auth, the application expects a header that contains a username and a password.

If it doesn't receive it, it returns an HTTP 401 "Unauthorized" error.

And returns a header `WWW-Authenticate` with a value of `Basic`, and an optional `realm` parameter.

That tells the browser to show the integrated prompt for a username and password.

Then, when you type that username and password, the browser sends them in the header automatically.

### Simple HTTP Basic Auth

- Import `HTTPBasic` and `HTTPBasicCredentials`.
- Create a "`security` scheme" using `HTTPBasic`.
- Use that `security` with a dependency in your *path operation*.
- It returns an object of type `HTTPBasicCredentials`:
  - It contains the `username` and `password` sent.

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`from typing import Annotated  from fastapi import Depends, FastAPI from fastapi.security import HTTPBasic, HTTPBasicCredentials app = FastAPI()  security = HTTPBasic()  @app.get(&quot;/users/me&quot;) def read_current_user(credentials: Annotated[HTTPBasicCredentials, Depends(security)]):     return {&quot;username&quot;: credentials.username, &quot;password&quot;: credentials.password}`

`from fastapi import Depends, FastAPI from fastapi.security import HTTPBasic, HTTPBasicCredentials from typing_extensions import Annotated  app = FastAPI()  security = HTTPBasic()  @app.get(&quot;/users/me&quot;) def read_current_user(credentials: Annotated[HTTPBasicCredentials, Depends(security)]):     return {&quot;username&quot;: credentials.username, &quot;password&quot;: credentials.password}`

Tip

Prefer to use the `Annotated` version if possible.

`from fastapi import Depends, FastAPI from fastapi.security import HTTPBasic, HTTPBasicCredentials app = FastAPI()  security = HTTPBasic()  @app.get(&quot;/users/me&quot;) def read_current_user(credentials: HTTPBasicCredentials = Depends(security)):     return {&quot;username&quot;: credentials.username, &quot;password&quot;: credentials.password}`

When you try to open the URL for the first time (or click the "Execute" button in the docs) the browser will ask you for your username and password:

<image @ https://fastapi.tiangolo.com/img/tutorial/security/image12.png>

### Check the username

Here's a more complete example.

Use a dependency to check if the username and password are correct.

For this, use the Python standard module `secrets` to check the username and password.

`secrets.compare_digest()` needs to take `bytes` or a `str` that only contains ASCII characters (the ones in English), this means it wouldn't work with characters like `á`, as in `Sebastián`.

To handle that, we first convert the `username` and `password` to `bytes` encoding them with UTF-8.

Then we can use `secrets.compare_digest()` to ensure that `credentials.username` is `&quot;stanleyjobson&quot;`, and that `credentials.password` is `&quot;swordfish&quot;`.

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`import secrets from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import HTTPBasic, HTTPBasicCredentials  app = FastAPI()  security = HTTPBasic()  def get_current_username(     credentials: Annotated[HTTPBasicCredentials, Depends(security)] ):     current_username_bytes = credentials.username.encode(&quot;utf8&quot;)    correct_username_bytes = b&quot;stanleyjobson&quot;    is_correct_username = secrets.compare_digest(        current_username_bytes, correct_username_bytes    )    current_password_bytes = credentials.password.encode(&quot;utf8&quot;)    correct_password_bytes = b&quot;swordfish&quot;    is_correct_password = secrets.compare_digest(        current_password_bytes, correct_password_bytes    )    if not (is_correct_username and is_correct_password):         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect email or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Basic&quot;},         )     return credentials.username  @app.get(&quot;/users/me&quot;) def read_current_user(username: Annotated[str, Depends(get_current_username)]):     return {&quot;username&quot;: username}`

`import secrets from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import HTTPBasic, HTTPBasicCredentials from typing_extensions import Annotated  app = FastAPI()  security = HTTPBasic()  def get_current_username(     credentials: Annotated[HTTPBasicCredentials, Depends(security)] ):     current_username_bytes = credentials.username.encode(&quot;utf8&quot;)    correct_username_bytes = b&quot;stanleyjobson&quot;    is_correct_username = secrets.compare_digest(        current_username_bytes, correct_username_bytes    )    current_password_bytes = credentials.password.encode(&quot;utf8&quot;)    correct_password_bytes = b&quot;swordfish&quot;    is_correct_password = secrets.compare_digest(        current_password_bytes, correct_password_bytes    )    if not (is_correct_username and is_correct_password):         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect email or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Basic&quot;},         )     return credentials.username  @app.get(&quot;/users/me&quot;) def read_current_user(username: Annotated[str, Depends(get_current_username)]):     return {&quot;username&quot;: username}`

Tip

Prefer to use the `Annotated` version if possible.

`import secrets from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import HTTPBasic, HTTPBasicCredentials  app = FastAPI()  security = HTTPBasic()  def get_current_username(credentials: HTTPBasicCredentials = Depends(security)):     current_username_bytes = credentials.username.encode(&quot;utf8&quot;)    correct_username_bytes = b&quot;stanleyjobson&quot;    is_correct_username = secrets.compare_digest(        current_username_bytes, correct_username_bytes    )    current_password_bytes = credentials.password.encode(&quot;utf8&quot;)    correct_password_bytes = b&quot;swordfish&quot;    is_correct_password = secrets.compare_digest(        current_password_bytes, correct_password_bytes    )    if not (is_correct_username and is_correct_password):         raise HTTPException(             status_code=status.HTTP_401_UNAUTHORIZED,             detail=&quot;Incorrect email or password&quot;,             headers={&quot;WWW-Authenticate&quot;: &quot;Basic&quot;},         )     return credentials.username  @app.get(&quot;/users/me&quot;) def read_current_user(username: str = Depends(get_current_username)):     return {&quot;username&quot;: username}`

This would be similar to:

`if not (credentials.username == &quot;stanleyjobson&quot;) or not (credentials.password == &quot;swordfish&quot;):     # Return some error     ...`

But by using the `secrets.compare_digest()` it will be secure against a type of attacks called "timing attacks".

#### Timing Attacks

But what's a "timing attack"?

Let's imagine some attackers are trying to guess the username and password.

And they send a request with a username `johndoe` and a password `love123`.

Then the Python code in your application would be equivalent to something like:

`if &quot;johndoe&quot; == &quot;stanleyjobson&quot; and &quot;love123&quot; == &quot;swordfish&quot;:     ...`

But right at the moment Python compares the first `j` in `johndoe` to the first `s` in `stanleyjobson`, it will return `False`, because it already knows that those two strings are not the same, thinking that "there's no need to waste more computation comparing the rest of the letters". And your application will say "incorrect user or password".

But then the attackers try with username `stanleyjobsox` and password `love123`.

And your application code does something like:

`if &quot;stanleyjobsox&quot; == &quot;stanleyjobson&quot; and &quot;love123&quot; == &quot;swordfish&quot;:     ...`

Python will have to compare the whole `stanleyjobso` in both `stanleyjobsox` and `stanleyjobson` before realizing that both strings are not the same. So it will take some extra microseconds to reply back "incorrect user or password".

##### The time to answer helps the attackers

At that point, by noticing that the server took some microseconds longer to send the "incorrect user or password" response, the attackers will know that they got *something* right, some of the initial letters were right.

And then they can try again knowing that it's probably something more similar to `stanleyjobsox` than to `johndoe`.

##### A "professional" attack

Of course, the attackers would not try all this by hand, they would write a program to do it, possibly with thousands or millions of tests per second. And would get just one extra correct letter at a time.

But doing that, in some minutes or hours the attackers would have guessed the correct username and password, with the "help" of our application, just using the time taken to answer.

##### Fix it with `secrets.compare_digest()`

But in our code we are actually using `secrets.compare_digest()`.

In short, it will take the same time to compare `stanleyjobsox` to `stanleyjobson` than it takes to compare `johndoe` to `stanleyjobson`. And the same for the password.

That way, using `secrets.compare_digest()` in your application code, it will be safe against this whole range of security attacks.

#### Return the error

After detecting that the credentials are incorrect, return an `HTTPException` with a status code 401 (the same returned when no credentials are provided) and add the header `WWW-Authenticate` to make the browser show the login prompt again:

Python 3.9+Python 3.6+Python 3.6+ non-Annotated

`import secrets from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import HTTPBasic, HTTPBasicCredentials  app = FastAPI()  security = HTTPBasic()  def get_current_username(     credentials: Annotated[HTTPBasicCredentials, Depends(security)] ):     current_username_bytes = credentials.username.encode(&quot;utf8&quot;)     correct_username_bytes = b&quot;stanleyjobson&quot;     is_correct_username = secrets.compare_digest(         current_username_bytes, correct_username_bytes     )     current_password_bytes = credentials.password.encode(&quot;utf8&quot;)     correct_password_bytes = b&quot;swordfish&quot;     is_correct_password = secrets.compare_digest(         current_password_bytes, correct_password_bytes     )     if not (is_correct_username and is_correct_password):         raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail=&quot;Incorrect email or password&quot;,            headers={&quot;WWW-Authenticate&quot;: &quot;Basic&quot;},        )    return credentials.username  @app.get(&quot;/users/me&quot;) def read_current_user(username: Annotated[str, Depends(get_current_username)]):     return {&quot;username&quot;: username}`

`import secrets  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import HTTPBasic, HTTPBasicCredentials from typing_extensions import Annotated  app = FastAPI()  security = HTTPBasic()  def get_current_username(     credentials: Annotated[HTTPBasicCredentials, Depends(security)] ):     current_username_bytes = credentials.username.encode(&quot;utf8&quot;)     correct_username_bytes = b&quot;stanleyjobson&quot;     is_correct_username = secrets.compare_digest(         current_username_bytes, correct_username_bytes     )     current_password_bytes = credentials.password.encode(&quot;utf8&quot;)     correct_password_bytes = b&quot;swordfish&quot;     is_correct_password = secrets.compare_digest(         current_password_bytes, correct_password_bytes     )     if not (is_correct_username and is_correct_password):         raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail=&quot;Incorrect email or password&quot;,            headers={&quot;WWW-Authenticate&quot;: &quot;Basic&quot;},        )    return credentials.username  @app.get(&quot;/users/me&quot;) def read_current_user(username: Annotated[str, Depends(get_current_username)]):     return {&quot;username&quot;: username}`

Tip

Prefer to use the `Annotated` version if possible.

`import secrets  from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import HTTPBasic, HTTPBasicCredentials  app = FastAPI()  security = HTTPBasic()  def get_current_username(credentials: HTTPBasicCredentials = Depends(security)):     current_username_bytes = credentials.username.encode(&quot;utf8&quot;)     correct_username_bytes = b&quot;stanleyjobson&quot;     is_correct_username = secrets.compare_digest(         current_username_bytes, correct_username_bytes     )     current_password_bytes = credentials.password.encode(&quot;utf8&quot;)     correct_password_bytes = b&quot;swordfish&quot;     is_correct_password = secrets.compare_digest(         current_password_bytes, correct_password_bytes     )     if not (is_correct_username and is_correct_password):         raise HTTPException(            status_code=status.HTTP_401_UNAUTHORIZED,            detail=&quot;Incorrect email or password&quot;,            headers={&quot;WWW-Authenticate&quot;: &quot;Basic&quot;},        )    return credentials.username  @app.get(&quot;/users/me&quot;) def read_current_user(username: str = Depends(get_current_username)):     return {&quot;username&quot;: username}`




You can use OAuth2 scopes directly with **FastAPI**, they are integrated to work seamlessly.

This would allow you to have a more fine-grained permission system, following the OAuth2 standard, integrated into your OpenAPI application (and the API docs).

OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, Twitter, etc. They use it to provide specific permissions to users and applications.

Every time you "log in with" Facebook, Google, GitHub, Microsoft, Twitter, that application is using OAuth2 with scopes.

In this section you will see how to manage authentication and authorization with the same OAuth2 with scopes in your **FastAPI** application.

Warning

This is a more or less advanced section. If you are just starting, you can skip it.

You don't necessarily need OAuth2 scopes, and you can handle authentication and authorization however you want.

But OAuth2 with scopes can be nicely integrated into your API (with OpenAPI) and your API docs.

Nevertheless, you still enforce those scopes, or any other security/authorization requirement, however you need, in your code.

In many cases, OAuth2 with scopes can be an overkill.

But if you know you need it, or you are curious, keep reading.

### OAuth2 scopes and OpenAPI

The OAuth2 specification defines "scopes" as a list of strings separated by spaces.

The content of each of these strings can have any format, but should not contain spaces.

These scopes represent "permissions".

In OpenAPI (e.g. the API docs), you can define "security schemes".

When one of these security schemes uses OAuth2, you can also declare and use scopes.

Each "scope" is just a string (without spaces).

They are normally used to declare specific security permissions, for example:

- `users:read` or `users:write` are common examples.
- `instagram_basic` is used by Facebook / Instagram.
- `https://www.googleapis.com/auth/drive` is used by Google.

Info

In OAuth2 a "scope" is just a string that declares a specific permission required.

It doesn't matter if it has other characters like `:` or if it is a URL.

Those details are implementation specific.

For OAuth2 they are just strings.

### Global view

First, let's quickly see the parts that change from the examples in the main **Tutorial - User Guide** for OAuth2 with Password (and hashing), Bearer with JWT tokens. Now using OAuth2 scopes:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.9+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, timedelta from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:        authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'    else:        authenticate_value = &quot;Bearer&quot;    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: authenticate_value},    )    try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])        token_data = TokenData(scopes=token_scopes, username=username)    except (JWTError, ValidationError):        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:        if scope not in token_data.scopes:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail=&quot;Not enough permissions&quot;,                headers={&quot;WWW-Authenticate&quot;: authenticate_value},            )    return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},        expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import Annotated, List, Union from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:        authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'    else:        authenticate_value = &quot;Bearer&quot;    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: authenticate_value},    )    try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])        token_data = TokenData(scopes=token_scopes, username=username)    except (JWTError, ValidationError):        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:        if scope not in token_data.scopes:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail=&quot;Not enough permissions&quot;,                headers={&quot;WWW-Authenticate&quot;: authenticate_value},            )    return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},        expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import List, Union from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError from typing_extensions import Annotated  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:        authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'    else:        authenticate_value = &quot;Bearer&quot;    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: authenticate_value},    )    try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])        token_data = TokenData(scopes=token_scopes, username=username)    except (JWTError, ValidationError):        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:        if scope not in token_data.scopes:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail=&quot;Not enough permissions&quot;,                headers={&quot;WWW-Authenticate&quot;: authenticate_value},            )    return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},        expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:        authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'    else:        authenticate_value = &quot;Bearer&quot;    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: authenticate_value},    )    try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])        token_data = TokenData(scopes=token_scopes, username=username)    except (JWTError, ValidationError):        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:        if scope not in token_data.scopes:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail=&quot;Not enough permissions&quot;,                headers={&quot;WWW-Authenticate&quot;: authenticate_value},            )    return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},        expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import Union from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:        authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'    else:        authenticate_value = &quot;Bearer&quot;    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: authenticate_value},    )    try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])        token_data = TokenData(scopes=token_scopes, username=username)    except (JWTError, ValidationError):        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:        if scope not in token_data.scopes:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail=&quot;Not enough permissions&quot;,                headers={&quot;WWW-Authenticate&quot;: authenticate_value},            )    return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},        expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import List, Union from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:        authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'    else:        authenticate_value = &quot;Bearer&quot;    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: authenticate_value},    )    try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])        token_data = TokenData(scopes=token_scopes, username=username)    except (JWTError, ValidationError):        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:        if scope not in token_data.scopes:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail=&quot;Not enough permissions&quot;,                headers={&quot;WWW-Authenticate&quot;: authenticate_value},            )    return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},        expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Now let's review those changes step by step.

### OAuth2 Security scheme

The first change is that now we are declaring the OAuth2 security scheme with two available scopes, `me` and `items`.

The `scopes` parameter receives a `dict` with each scope as a key and the description as the value:

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.9+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, timedelta from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,    scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, ) app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import Annotated, List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,    scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, ) app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError from typing_extensions import Annotated  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,    scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, ) app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,    scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, ) app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,    scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, ) app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,    scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, ) app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Because we are now declaring those scopes, they will show up in the API docs when you log-in/authorize.

And you will be able to select which scopes you want to give access to: `me` and `items`.

This is the same mechanism used when you give permissions while logging in with Facebook, Google, GitHub, etc:

<image @ https://fastapi.tiangolo.com/img/tutorial/security/image11.png>

### JWT token with scopes

Now, modify the token *path operation* to return the scopes requested.

We are still using the same `OAuth2PasswordRequestForm`. It includes a property `scopes` with a `list` of `str`, with each scope it received in the request.

And we return the scopes as part of the JWT token.

Danger

For simplicity, here we are just adding the scopes received directly to the token.

But in your application, for security, you should make sure you only add the scopes that the user is actually able to have, or the ones you have predefined.

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.9+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, timedelta from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},        expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import Annotated, List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},        expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError from typing_extensions import Annotated  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},        expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},        expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},        expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},        expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

### Declare scopes in *path operations* and dependencies

Now we declare that the *path operation* for `/users/me/items/` requires the scope `items`.

For this, we import and use `Security` from `fastapi`.

You can use `Security` to declare dependencies (just like `Depends`), but `Security` also receives a parameter `scopes` with a list of scopes (strings).

In this case, we pass a dependency function `get_current_active_user` to `Security` (the same way we would do with `Depends`).

But we also pass a `list` of scopes, in this case with just one scope: `items` (it could have more).

And the dependency function `get_current_active_user` can also declare sub-dependencies, not only with `Depends` but also with `Security`. Declaring its own sub-dependency function (`get_current_user`), and more scope requirements.

In this case, it requires the scope `me` (it could require more than one scope).

Note

You don't necessarily need to add different scopes in different places.

We are doing it here to demonstrate how **FastAPI** handles scopes declared at different levels.

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.9+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, timedelta from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import Annotated, List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError from typing_extensions import Annotated  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Technical Details

`Security` is actually a subclass of `Depends`, and it has just one extra parameter that we'll see later.

But by using `Security` instead of `Depends`, **FastAPI** will know that it can declare security scopes, use them internally, and document the API with OpenAPI.

But when you import `Query`, `Path`, `Depends`, `Security` and others from `fastapi`, those are actually functions that return special classes.

### Use `SecurityScopes`

Now update the dependency `get_current_user`.

This is the one used by the dependencies above.

Here's were we are using the same OAuth2 scheme we created before, declaring it as a dependency: `oauth2_scheme`.

Because this dependency function doesn't have any scope requirements itself, we can use `Depends` with `oauth2_scheme`, we don't have to use `Security` when we don't need to specify security scopes.

We also declare a special parameter of type `SecurityScopes`, imported from `fastapi.security`.

This `SecurityScopes` class is similar to `Request` (`Request` was used to get the request object directly).

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.9+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, timedelta from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import Annotated, List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError from typing_extensions import Annotated  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

### Use the `scopes`

The parameter `security_scopes` will be of type `SecurityScopes`.

It will have a property `scopes` with a list containing all the scopes required by itself and all the dependencies that use this as a sub-dependency. That means, all the "dependants"... this might sound confusing, it is explained again later below.

The `security_scopes` object (of class `SecurityScopes`) also provides a `scope_str` attribute with a single string, containing those scopes separated by spaces (we are going to use it).

We create an `HTTPException` that we can re-use (`raise`) later at several points.

In this exception, we include the scopes required (if any) as a string separated by spaces (using `scope_str`). We put that string containing the scopes in the `WWW-Authenticate` header (this is part of the spec).

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.9+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, timedelta from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:        authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'    else:        authenticate_value = &quot;Bearer&quot;    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: authenticate_value},    )    try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import Annotated, List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:        authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'    else:        authenticate_value = &quot;Bearer&quot;    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: authenticate_value},    )    try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError from typing_extensions import Annotated  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:        authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'    else:        authenticate_value = &quot;Bearer&quot;    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: authenticate_value},    )    try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:        authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'    else:        authenticate_value = &quot;Bearer&quot;    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: authenticate_value},    )    try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:        authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'    else:        authenticate_value = &quot;Bearer&quot;    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: authenticate_value},    )    try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:        authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'    else:        authenticate_value = &quot;Bearer&quot;    credentials_exception = HTTPException(        status_code=status.HTTP_401_UNAUTHORIZED,        detail=&quot;Could not validate credentials&quot;,        headers={&quot;WWW-Authenticate&quot;: authenticate_value},    )    try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

### Verify the `username` and data shape

We verify that we get a `username`, and extract the scopes.

And then we validate that data with the Pydantic model (catching the `ValidationError` exception), and if we get an error reading the JWT token or validating the data with Pydantic, we raise the `HTTPException` we created before.

For that, we update the Pydantic model `TokenData` with a new property `scopes`.

By validating the data with Pydantic we can make sure that we have, for example, exactly a `list` of `str` with the scopes and a `str` with the `username`.

Instead of, for example, a `dict`, or something else, as it could break the application at some point later, making it a security risk.

We also verify that we have a user with that username, and if not, we raise that same exception we created before.

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.9+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, timedelta from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])        username: str = payload.get(&quot;sub&quot;)        if username is None:            raise credentials_exception        token_scopes = payload.get(&quot;scopes&quot;, [])        token_data = TokenData(scopes=token_scopes, username=username)    except (JWTError, ValidationError):        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)    if user is None:        raise credentials_exception    for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import Annotated, List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])        username: str = payload.get(&quot;sub&quot;)        if username is None:            raise credentials_exception        token_scopes = payload.get(&quot;scopes&quot;, [])        token_data = TokenData(scopes=token_scopes, username=username)    except (JWTError, ValidationError):        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)    if user is None:        raise credentials_exception    for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError from typing_extensions import Annotated  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])        username: str = payload.get(&quot;sub&quot;)        if username is None:            raise credentials_exception        token_scopes = payload.get(&quot;scopes&quot;, [])        token_data = TokenData(scopes=token_scopes, username=username)    except (JWTError, ValidationError):        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)    if user is None:        raise credentials_exception    for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])        username: str = payload.get(&quot;sub&quot;)        if username is None:            raise credentials_exception        token_scopes = payload.get(&quot;scopes&quot;, [])        token_data = TokenData(scopes=token_scopes, username=username)    except (JWTError, ValidationError):        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)    if user is None:        raise credentials_exception    for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])        username: str = payload.get(&quot;sub&quot;)        if username is None:            raise credentials_exception        token_scopes = payload.get(&quot;scopes&quot;, [])        token_data = TokenData(scopes=token_scopes, username=username)    except (JWTError, ValidationError):        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)    if user is None:        raise credentials_exception    for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])        username: str = payload.get(&quot;sub&quot;)        if username is None:            raise credentials_exception        token_scopes = payload.get(&quot;scopes&quot;, [])        token_data = TokenData(scopes=token_scopes, username=username)    except (JWTError, ValidationError):        raise credentials_exception    user = get_user(fake_users_db, username=token_data.username)    if user is None:        raise credentials_exception    for scope in security_scopes.scopes:         if scope not in token_data.scopes:             raise HTTPException(                 status_code=status.HTTP_401_UNAUTHORIZED,                 detail=&quot;Not enough permissions&quot;,                 headers={&quot;WWW-Authenticate&quot;: authenticate_value},             )     return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

### Verify the `scopes`

We now verify that all the scopes required, by this dependency and all the dependants (including *path operations*), are included in the scopes provided in the token received, otherwise raise an `HTTPException`.

For this, we use `security_scopes.scopes`, that contains a `list` with all these scopes as `str`.

Python 3.10+Python 3.9+Python 3.6+Python 3.10+ non-AnnotatedPython 3.9+ non-AnnotatedPython 3.6+ non-Annotated

`from datetime import datetime, timedelta from typing import Annotated  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:        if scope not in token_data.scopes:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail=&quot;Not enough permissions&quot;,                headers={&quot;WWW-Authenticate&quot;: authenticate_value},            )    return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import Annotated, List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:        if scope not in token_data.scopes:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail=&quot;Not enough permissions&quot;,                headers={&quot;WWW-Authenticate&quot;: authenticate_value},            )    return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError from typing_extensions import Annotated  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:        if scope not in token_data.scopes:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail=&quot;Not enough permissions&quot;,                headers={&quot;WWW-Authenticate&quot;: authenticate_value},            )    return user  async def get_current_active_user(     current_user: Annotated[User, Security(get_current_user, scopes=[&quot;me&quot;])] ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(     form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(     current_user: Annotated[User, Depends(get_current_active_user)] ):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: Annotated[User, Security(get_current_active_user, scopes=[&quot;items&quot;])] ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: str | None = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: str | None = None     full_name: str | None = None     disabled: bool | None = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: timedelta | None = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:        if scope not in token_data.scopes:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail=&quot;Not enough permissions&quot;,                headers={&quot;WWW-Authenticate&quot;: authenticate_value},            )    return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: list[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:        if scope not in token_data.scopes:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail=&quot;Not enough permissions&quot;,                headers={&quot;WWW-Authenticate&quot;: authenticate_value},            )    return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

Tip

Prefer to use the `Annotated` version if possible.

`from datetime import datetime, timedelta from typing import List, Union  from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import (     OAuth2PasswordBearer,     OAuth2PasswordRequestForm,     SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError  # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = &quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot; ALGORITHM = &quot;HS256&quot; ACCESS_TOKEN_EXPIRE_MINUTES = 30  fake_users_db = {     &quot;johndoe&quot;: {         &quot;username&quot;: &quot;johndoe&quot;,         &quot;full_name&quot;: &quot;John Doe&quot;,         &quot;email&quot;: &quot;johndoe@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;,         &quot;disabled&quot;: False,     },     &quot;alice&quot;: {         &quot;username&quot;: &quot;alice&quot;,         &quot;full_name&quot;: &quot;Alice Chains&quot;,         &quot;email&quot;: &quot;alicechains@example.com&quot;,         &quot;hashed_password&quot;: &quot;$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm&quot;,         &quot;disabled&quot;: True,     }, }  class Token(BaseModel):     access_token: str     token_type: str  class TokenData(BaseModel):     username: Union[str, None] = None     scopes: List[str] = []  class User(BaseModel):     username: str     email: Union[str, None] = None     full_name: Union[str, None] = None     disabled: Union[bool, None] = None  class UserInDB(User):     hashed_password: str  pwd_context = CryptContext(schemes=[&quot;bcrypt&quot;], deprecated=&quot;auto&quot;)  oauth2_scheme = OAuth2PasswordBearer(     tokenUrl=&quot;token&quot;,     scopes={&quot;me&quot;: &quot;Read information about the current user.&quot;, &quot;items&quot;: &quot;Read items.&quot;}, )  app = FastAPI()  def verify_password(plain_password, hashed_password):     return pwd_context.verify(plain_password, hashed_password)  def get_password_hash(password):     return pwd_context.hash(password)  def get_user(db, username: str):     if username in db:         user_dict = db[username]         return UserInDB(**user_dict)  def authenticate_user(fake_db, username: str, password: str):     user = get_user(fake_db, username)     if not user:         return False     if not verify_password(password, user.hashed_password):         return False     return user  def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):     to_encode = data.copy()     if expires_delta:         expire = datetime.utcnow() + expires_delta     else:         expire = datetime.utcnow() + timedelta(minutes=15)     to_encode.update({&quot;exp&quot;: expire})     encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)     return encoded_jwt  async def get_current_user(     security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme) ):     if security_scopes.scopes:         authenticate_value = f'Bearer scope=&quot;{security_scopes.scope_str}&quot;'     else:         authenticate_value = &quot;Bearer&quot;     credentials_exception = HTTPException(         status_code=status.HTTP_401_UNAUTHORIZED,         detail=&quot;Could not validate credentials&quot;,         headers={&quot;WWW-Authenticate&quot;: authenticate_value},     )     try:         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])         username: str = payload.get(&quot;sub&quot;)         if username is None:             raise credentials_exception         token_scopes = payload.get(&quot;scopes&quot;, [])         token_data = TokenData(scopes=token_scopes, username=username)     except (JWTError, ValidationError):         raise credentials_exception     user = get_user(fake_users_db, username=token_data.username)     if user is None:         raise credentials_exception     for scope in security_scopes.scopes:        if scope not in token_data.scopes:            raise HTTPException(                status_code=status.HTTP_401_UNAUTHORIZED,                detail=&quot;Not enough permissions&quot;,                headers={&quot;WWW-Authenticate&quot;: authenticate_value},            )    return user  async def get_current_active_user(     current_user: User = Security(get_current_user, scopes=[&quot;me&quot;]) ):     if current_user.disabled:         raise HTTPException(status_code=400, detail=&quot;Inactive user&quot;)     return current_user  @app.post(&quot;/token&quot;, response_model=Token) async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):     user = authenticate_user(fake_users_db, form_data.username, form_data.password)     if not user:         raise HTTPException(status_code=400, detail=&quot;Incorrect username or password&quot;)     access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)     access_token = create_access_token(         data={&quot;sub&quot;: user.username, &quot;scopes&quot;: form_data.scopes},         expires_delta=access_token_expires,     )     return {&quot;access_token&quot;: access_token, &quot;token_type&quot;: &quot;bearer&quot;}  @app.get(&quot;/users/me/&quot;, response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)):     return current_user  @app.get(&quot;/users/me/items/&quot;) async def read_own_items(     current_user: User = Security(get_current_active_user, scopes=[&quot;items&quot;]) ):     return [{&quot;item_id&quot;: &quot;Foo&quot;, &quot;owner&quot;: current_user.username}]  @app.get(&quot;/status/&quot;) async def read_system_status(current_user: User = Depends(get_current_user)):     return {&quot;status&quot;: &quot;ok&quot;}`

### Dependency tree and scopes

Let's review again this dependency tree and the scopes.

As the `get_current_active_user` dependency has as a sub-dependency on `get_current_user`, the scope `&quot;me&quot;` declared at `get_current_active_user` will be included in the list of required scopes in the `security_scopes.scopes` passed to `get_current_user`.

The *path operation* itself also declares a scope, `&quot;items&quot;`, so this will also be in the list of `security_scopes.scopes` passed to `get_current_user`.

Here's how the hierarchy of dependencies and scopes looks like:

- The *path operation* `read_own_items` has:
  - Required scopes `[&quot;items&quot;]` with the dependency:
  - `get_current_active_user`:
    - The dependency function `get_current_active_user` has:
      - Required scopes `[&quot;me&quot;]` with the dependency:
      - `get_current_user`:
        - The dependency function `get_current_user` has:
          - No scopes required by itself.
          - A dependency using `oauth2_scheme`.
          - A `security_scopes` parameter of type `SecurityScopes`:
            -   This `security_scopes` parameter has a property `scopes` with a `list` containing all these scopes declared above, so:
            -   `security_scopes.scopes` will contain `[&quot;me&quot;, &quot;items&quot;]` for the *path operation* `read_own_items`.
            -   `security_scopes.scopes` will contain `[&quot;me&quot;]` for the *path operation* `read_users_me`, because it is declared in the dependency `get_current_active_user`.
            -   `security_scopes.scopes` will contain `[]` (nothing) for the *path operation* `read_system_status`, because it didn't declare any `Security` with `scopes`, and its dependency, `get_current_user`, doesn't declare any `scope` either.

Tip

The important and "magic" thing here is that `get_current_user` will have a different list of `scopes` to check for each *path operation*.

All depending on the `scopes` declared in each *path operation* and each dependency in the dependency tree for that specific *path operation*.

### More details about `SecurityScopes`

You can use `SecurityScopes` at any point, and in multiple places, it doesn't have to be at the "root" dependency.

It will always have the security scopes declared in the current `Security` dependencies and all the dependants for **that specific** *path operation* and **that specific** dependency tree.

Because the `SecurityScopes` will have all the scopes declared by dependants, you can use it to verify that a token has the required scopes in a central dependency function, and then declare different scope requirements in different *path operations*.

They will be checked independently for each *path operation*.

### Check it

If you open the API docs, you can authenticate and specify which scopes you want to authorize.

<image @ https://fastapi.tiangolo.com/img/tutorial/security/image11.png>

If you don't select any scope, you will be "authenticated", but when you try to access `/users/me/` or `/users/me/items/` you will get an error saying that you don't have enough permissions. You will still be able to access `/status/`.

And if you select the scope `me` but not the scope `items`, you will be able to access `/users/me/` but not `/users/me/items/`.

That's what would happen to a third party application that tried to access one of these *path operations* with a token provided by a user, depending on how many permissions the user gave the application.

### About third party integrations

In this example we are using the OAuth2 "password" flow.

This is appropriate when we are logging in to our own application, probably with our own frontend.

Because we can trust it to receive the `username` and `password`, as we control it.

But if you are building an OAuth2 application that others would connect to (i.e., if you are building an authentication provider equivalent to Facebook, Google, GitHub, etc.) you should use one of the other flows.

The most common is the implicit flow.

The most secure is the code flow, but is more complex to implement as it requires more steps. As it is more complex, many providers end up suggesting the implicit flow.

Note

It's common that each authentication provider names their flows in a different way, to make it part of their brand.

But in the end, they are implementing the same OAuth2 standard.

**FastAPI** includes utilities for all these OAuth2 authentication flows in `fastapi.security.oauth2`.

### `Security` in decorator `dependencies`

The same way you can define a `list` of `Depends` in the decorator's `dependencies` parameter (as explained in Dependencies in path operation decorators), you could also use `Security` with `scopes` there.


